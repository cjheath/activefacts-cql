#
# Autogenerated from a Treetop grammar. Edits may be lost.


#       ActiveFacts CQL Parser.
#       Parse rules relating to ObjectType definitions.
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
module ActiveFacts
  module CQL
    module ObjectTypes
      include Treetop::Runtime

      def root
        @root ||= :object_type
      end

      def _nt_object_type
        start_index = index
        if node_cache[:object_type].has_key?(index)
          cached = node_cache[:object_type][index]
          if cached
            node_cache[:object_type][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_value_type
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_entity_type
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_named_fact_type
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_anonymous_fact_type
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:object_type][start_index] = r0

        r0
      end

      module EntityType0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def term_definition_name
          elements[3]
        end

        def m1
          elements[4]
        end

        def c
          elements[5]
        end

        def sup
          elements[6]
        end

        def m2
          elements[8]
        end

        def c2
          elements[9]
        end

        def ec
          elements[10]
        end

      end

      module EntityType1
        def ast
          name = term_definition_name.value
          clauses_ast = ec.empty? ? [] : ec.ast
          pragmas = m1.value+m2.value
          pragmas << 'independent' if sup.independent
          context_note = !c.empty? ? c.ast : (!c2.empty? ? c2.ast : nil)
          Compiler::EntityType.new name, sup.supers, sup.ast, pragmas, clauses_ast, context_note
        end
      end

      def _nt_entity_type
        start_index = index
        if node_cache[:entity_type].has_key?(index)
          cached = node_cache[:entity_type][index]
          if cached
            node_cache[:entity_type][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r3 = _nt_each
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r4 = _nt_s
            s0 << r4
            if r4
              r5 = _nt_term_definition_name
              s0 << r5
              if r5
                r6 = _nt_mapping_pragmas
                s0 << r6
                if r6
                  r8 = _nt_context_note
                  if r8
                    r7 = r8
                  else
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r7
                  if r7
                    i9 = index
                    r10 = _nt_basetype
                    if r10
                      r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                      r9 = r10
                    else
                      r11 = _nt_subtype
                      if r11
                        r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                        r9 = r11
                      else
                        @index = i9
                        r9 = nil
                      end
                    end
                    s0 << r9
                    if r9
                      i12 = index
                      r13 = lambda {|s|
                                  # There's an implicit type when we use an identification mode, register it:
                                  mode = s[6].identification_mode
                                  if mode
                                    input.context.object_type(s[3].value+mode, "identification mode type")
                                    input.context.object_type(s[3].value+' '+mode, "identification mode type")
                                  end
                                  true
                                }.call(s0)
                      if !r13
                        terminal_parse_failure("<semantic predicate>")
                      end
                      if r13
                        @index = i12
                        r12 = instantiate_node(SyntaxNode,input, index...index)
                      else
                        @index = i12
                        r12 = nil
                      end
                      s0 << r12
                      if r12
                        r14 = _nt_mapping_pragmas
                        s0 << r14
                        if r14
                          r16 = _nt_context_note
                          if r16
                            r15 = r16
                          else
                            r15 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r15
                          if r15
                            r18 = _nt_entity_clauses
                            if r18
                              r17 = r18
                            else
                              r17 = instantiate_node(SyntaxNode,input, index...index)
                            end
                            s0 << r17
                            if r17
                              if (match_len = has_terminal?(';', false, index))
                                r19 = true
                                @index += match_len
                              else
                                terminal_parse_failure('\';\'')
                                r19 = nil
                              end
                              s0 << r19
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(EntityType0)
          r0.extend(EntityType1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:entity_type][start_index] = r0

        r0
      end

      module Basetype0
        def ast; identification.ast; end
        def supers; []; end
        def identification_mode; identification.mode; end
        def independent; !i.empty?; end
      end

      def _nt_basetype
        start_index = index
        if node_cache[:basetype].has_key?(index)
          cached = node_cache[:basetype][index]
          if cached
            node_cache[:basetype][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_basetype_expression
        r0.extend(Basetype0)
        r0.extend(Basetype0)

        node_cache[:basetype][start_index] = r0

        r0
      end

      module Subtype0
        def ast; ident.empty? ? nil : ident.ast; end
        def supers; supertype_list.value; end
        def identification_mode; ident.empty? ? nil : ident.mode; end
        def independent; !i.empty?; end
      end

      def _nt_subtype
        start_index = index
        if node_cache[:subtype].has_key?(index)
          cached = node_cache[:subtype][index]
          if cached
            node_cache[:subtype][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_subtype_expression
        r0.extend(Subtype0)
        r0.extend(Subtype0)

        node_cache[:subtype][start_index] = r0

        r0
      end

      module SupertypeList0
      end

      module SupertypeList1
        def s1
          elements[1]
        end

        def name
          elements[3]
        end

        def s2
          elements[4]
        end
      end

      module SupertypeList2
        def primary
          elements[0]
        end

        def s
          elements[1]
        end

        def alternate_supertypes
          elements[2]
        end
      end

      module SupertypeList3
        def value
          [primary.value, *alternate_supertypes.elements.map { |sup| sup.name.value } ]
        end
      end

      def _nt_supertype_list
        start_index = index
        if node_cache[:supertype_list].has_key?(index)
          cached = node_cache[:supertype_list][index]
          if cached
            node_cache[:supertype_list][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_term
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4, s4 = index, []
              i5 = index
              if (match_len = has_terminal?(',', false, index))
                r6 = true
                @index += match_len
              else
                terminal_parse_failure('\',\'')
                r6 = nil
              end
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r5 = r6
              else
                i7, s7 = index, []
                if (match_len = has_terminal?('and', false, index))
                  r8 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'and\'')
                  r8 = nil
                end
                s7 << r8
                if r8
                  i9 = index
                  r10 = _nt_alpha
                  if r10
                    @index = i9
                    r9 = nil
                  else
                    @index = i9
                    r9 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s7 << r9
                end
                if s7.last
                  r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                  r7.extend(SupertypeList0)
                else
                  @index = i7
                  r7 = nil
                end
                if r7
                  r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                  r5 = r7
                else
                  @index = i5
                  r5 = nil
                end
              end
              s4 << r5
              if r5
                r11 = _nt_s
                s4 << r11
                if r11
                  i12 = index
                  r13 = _nt_identified_by
                  if r13
                    @index = i12
                    r12 = nil
                  else
                    @index = i12
                    r12 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s4 << r12
                  if r12
                    r14 = _nt_term
                    s4 << r14
                    if r14
                      r15 = _nt_s
                      s4 << r15
                    end
                  end
                end
              end
              if s4.last
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
                r4.extend(SupertypeList1)
              else
                @index = i4
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SupertypeList2)
          r0.extend(SupertypeList3)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:supertype_list][start_index] = r0

        r0
      end

      module Identification0
        def value_constraint
          elements[0]
        end

        def enforcement
          elements[1]
        end
      end

      module Identification1
        def identified_by
          elements[0]
        end

        def its
          elements[1]
        end

        def s
          elements[2]
        end

        def i
          elements[3]
        end

        def value_type_parameters
          elements[4]
        end

        def r
          elements[5]
        end
      end

      module Identification2
        def ast
          if r.empty?
            value_constraint = nil
          else
            value_constraint = Compiler::ValueConstraint.new(r.value_constraint.ast, r.enforcement.ast)
          end
          Compiler::ReferenceMode.new(i.value, value_constraint, value_type_parameters.values)
        end

        def mode
          i.value
        end
      end

      module Identification3
        def identified_by
          elements[0]
        end

        def role_list
          elements[1]
        end

      end

      module Identification4
        def ast
          role_list.ast
        end

        def mode
          nil
        end
      end

      def _nt_identification
        start_index = index
        if node_cache[:identification].has_key?(index)
          cached = node_cache[:identification][index]
          if cached
            node_cache[:identification][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_identified_by
        s1 << r2
        if r2
          r3 = _nt_its
          s1 << r3
          if r3
            r4 = _nt_s
            s1 << r4
            if r4
              i5 = index
              r6 = _nt_term
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r5 = r6
              else
                r7 = _nt_implicit_value_type_name
                if r7
                  r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                  r5 = r7
                else
                  @index = i5
                  r5 = nil
                end
              end
              s1 << r5
              if r5
                r8 = _nt_value_type_parameters
                s1 << r8
                if r8
                  i10, s10 = index, []
                  r11 = _nt_value_constraint
                  s10 << r11
                  if r11
                    r12 = _nt_enforcement
                    s10 << r12
                  end
                  if s10.last
                    r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                    r10.extend(Identification0)
                  else
                    @index = i10
                    r10 = nil
                  end
                  if r10
                    r9 = r10
                  else
                    r9 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s1 << r9
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Identification1)
          r1.extend(Identification2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i13, s13 = index, []
          r14 = _nt_identified_by
          s13 << r14
          if r14
            r15 = _nt_role_list
            s13 << r15
            if r15
              i16 = index
              r17 = lambda {|s|
                          role_list = s[-1]
                          forwards = role_list.ast.
                            map do |role|
                              next nil if role.is_a?(Compiler::Clause) # Can't forward-reference unaries
                              next nil if role.leading_adjective or role.trailing_adjective
                              role.term
                            end.
                            compact
                          input.context.allowed_forward_terms(forwards)
                          true
                        }.call(s13)
              if !r17
                terminal_parse_failure("<semantic predicate>")
              end
              if r17
                @index = i16
                r16 = instantiate_node(SyntaxNode,input, index...index)
              else
                @index = i16
                r16 = nil
              end
              s13 << r16
            end
          end
          if s13.last
            r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
            r13.extend(Identification3)
            r13.extend(Identification4)
          else
            @index = i13
            r13 = nil
          end
          if r13
            r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
            r0 = r13
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:identification][start_index] = r0

        r0
      end

      module RoleList0
        def and
          elements[0]
        end

        def S
          elements[1]
        end
      end

      module RoleList1
        def s
          elements[1]
        end
      end

      module RoleList2
        def s1
          elements[2]
        end

        def term_or_unary
          elements[3]
        end

        def s2
          elements[4]
        end
      end

      module RoleList3
        def a
          elements[0]
        end

        def s1
          elements[1]
        end

        def head
          elements[2]
        end

        def s2
          elements[3]
        end

        def tail
          elements[4]
        end
      end

      module RoleList4
        def ast
          [head.ast, *tail.elements.map{|e| e.term_or_unary.ast}]
        end
      end

      def _nt_role_list
        start_index = index
        if node_cache[:role_list].has_key?(index)
          cached = node_cache[:role_list][index]
          if cached
            node_cache[:role_list][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r2 = _nt_any
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r3 = _nt_s
          s0 << r3
          if r3
            r4 = _nt_term_or_unary
            s0 << r4
            if r4
              r5 = _nt_s
              s0 << r5
              if r5
                s6, i6 = [], index
                loop do
                  i7, s7 = index, []
                  i8 = index
                  i9, s9 = index, []
                  r10 = _nt_and
                  s9 << r10
                  if r10
                    r11 = _nt_S
                    s9 << r11
                  end
                  if s9.last
                    r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
                    r9.extend(RoleList0)
                  else
                    @index = i9
                    r9 = nil
                  end
                  if r9
                    r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                    r8 = r9
                  else
                    i12, s12 = index, []
                    if (match_len = has_terminal?(',', false, index))
                      r13 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\',\'')
                      r13 = nil
                    end
                    s12 << r13
                    if r13
                      r14 = _nt_s
                      s12 << r14
                    end
                    if s12.last
                      r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
                      r12.extend(RoleList1)
                    else
                      @index = i12
                      r12 = nil
                    end
                    if r12
                      r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                      r8 = r12
                    else
                      @index = i8
                      r8 = nil
                    end
                  end
                  s7 << r8
                  if r8
                    r16 = _nt_any
                    if r16
                      r15 = r16
                    else
                      r15 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s7 << r15
                    if r15
                      r17 = _nt_s
                      s7 << r17
                      if r17
                        r18 = _nt_term_or_unary
                        s7 << r18
                        if r18
                          r19 = _nt_s
                          s7 << r19
                        end
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(RoleList2)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    s6 << r7
                  else
                    break
                  end
                end
                r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                s0 << r6
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RoleList3)
          r0.extend(RoleList4)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:role_list][start_index] = r0

        r0
      end

      module UnaryText0
        def s
          elements[0]
        end

        def id
          elements[4]
        end
      end

      module UnaryText1
        def node_type; :linking; end
      end

      def _nt_unary_text
        start_index = index
        if node_cache[:unary_text].has_key?(index)
          cached = node_cache[:unary_text][index]
          if cached
            node_cache[:unary_text][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1, s1 = index, []
          r2 = _nt_s
          s1 << r2
          if r2
            i3 = index
            r4 = _nt_any
            if r4
              @index = i3
              r3 = nil
            else
              @index = i3
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s1 << r3
            if r3
              i5 = index
              r6 = _nt_non_phrase
              if r6
                @index = i5
                r5 = nil
              else
                @index = i5
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s1 << r5
              if r5
                i7 = index
                r8 = _nt_term
                if r8
                  @index = i7
                  r7 = nil
                else
                  @index = i7
                  r7 = instantiate_node(SyntaxNode,input, index...index)
                end
                s1 << r7
                if r7
                  r9 = _nt_id
                  s1 << r9
                end
              end
            end
          end
          if s1.last
            r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
            r1.extend(UnaryText0)
          else
            @index = i1
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(UnaryText1)
        r0.extend(UnaryText1)

        node_cache[:unary_text][start_index] = r0

        r0
      end

      module TermOrUnary0
        def pre_text
          elements[0]
        end

        def s1
          elements[1]
        end

        def term
          elements[2]
        end

        def post_text
          elements[3]
        end

        def s2
          elements[4]
        end

        def ss
          elements[5]
        end
      end

      module TermOrUnary1
        def ast
          t = term.ast
          t.role_name = ss.value if !ss.empty?
          if pre_text.elements.size == 0 && post_text.elements.size == 0
            t
          else
            pre_words = pre_text.elements.map{|w| w.id.text_value}
            post_words = post_text.elements.map{|w| w.id.text_value}
            Compiler::Clause.new(pre_words + [t] + post_words, [], nil)
          end
        end
      end

      module TermOrUnary2
        def s1
          elements[0]
        end

        def id
          elements[2]
        end

        def s2
          elements[3]
        end

        def s3
          elements[5]
        end

        def ss
          elements[6]
        end
      end

      module TermOrUnary3
        # A forward-referenced entity type
                   # REVISIT: A change in this rule might allow forward-referencing a multi-word term
                   def ast
                     Compiler::Reference.new(id.text_value, nil, nil, nil, nil, ss.empty? ? nil : ss.value)
                   end
      end

      def _nt_term_or_unary
        start_index = index
        if node_cache[:term_or_unary].has_key?(index)
          cached = node_cache[:term_or_unary][index]
          if cached
            node_cache[:term_or_unary][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_unary_text
        s1 << r2
        if r2
          r3 = _nt_s
          s1 << r3
          if r3
            r4 = _nt_term
            s1 << r4
            if r4
              r5 = _nt_unary_text
              s1 << r5
              if r5
                r6 = _nt_s
                s1 << r6
                if r6
                  r8 = _nt_subscript
                  if r8
                    r7 = r8
                  else
                    r7 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s1 << r7
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(TermOrUnary0)
          r1.extend(TermOrUnary1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i9, s9 = index, []
          r10 = _nt_s
          s9 << r10
          if r10
            i11 = index
            r12 = _nt_non_phrase
            if r12
              @index = i11
              r11 = nil
            else
              @index = i11
              r11 = instantiate_node(SyntaxNode,input, index...index)
            end
            s9 << r11
            if r11
              r13 = _nt_id
              s9 << r13
              if r13
                r14 = _nt_s
                s9 << r14
                if r14
                  i15 = index
                  r16 = _nt_non_phrase
                  if r16
                    @index = i15
                    r15 = instantiate_node(SyntaxNode,input, index...index)
                  else
                    @index = i15
                    r15 = nil
                  end
                  s9 << r15
                  if r15
                    r17 = _nt_s
                    s9 << r17
                    if r17
                      r19 = _nt_subscript
                      if r19
                        r18 = r19
                      else
                        r18 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s9 << r18
                    end
                  end
                end
              end
            end
          end
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(TermOrUnary2)
            r9.extend(TermOrUnary3)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:term_or_unary][start_index] = r0

        r0
      end

      module MappingPragmas0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def mapping_pragma
          elements[3]
        end
      end

      module MappingPragmas1
        def s1
          elements[1]
        end

        def h
          elements[2]
        end

        def t
          elements[3]
        end

        def s2
          elements[4]
        end

        def s3
          elements[6]
        end
      end

      module MappingPragmas2
        def value
          t.elements.inject([h.value*' ']) do |a, e|
            a << e.mapping_pragma.value*' '
          end
        end
      end

      module MappingPragmas3
        def value; []; end
      end

      def _nt_mapping_pragmas
        start_index = index
        if node_cache[:mapping_pragmas].has_key?(index)
          cached = node_cache[:mapping_pragmas][index]
          if cached
            node_cache[:mapping_pragmas][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?('[', false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('\'[\'')
          r2 = nil
        end
        s1 << r2
        if r2
          r3 = _nt_s
          s1 << r3
          if r3
            r4 = _nt_mapping_pragma
            s1 << r4
            if r4
              s5, i5 = [], index
              loop do
                i6, s6 = index, []
                r7 = _nt_s
                s6 << r7
                if r7
                  if (match_len = has_terminal?(',', false, index))
                    r8 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\',\'')
                    r8 = nil
                  end
                  s6 << r8
                  if r8
                    r9 = _nt_s
                    s6 << r9
                    if r9
                      r10 = _nt_mapping_pragma
                      s6 << r10
                    end
                  end
                end
                if s6.last
                  r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                  r6.extend(MappingPragmas0)
                else
                  @index = i6
                  r6 = nil
                end
                if r6
                  s5 << r6
                else
                  break
                end
              end
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              s1 << r5
              if r5
                r11 = _nt_s
                s1 << r11
                if r11
                  if (match_len = has_terminal?(']', false, index))
                    r12 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\']\'')
                    r12 = nil
                  end
                  s1 << r12
                  if r12
                    r13 = _nt_s
                    s1 << r13
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(MappingPragmas1)
          r1.extend(MappingPragmas2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r14 = _nt_s
          r14.extend(MappingPragmas3)
          r14.extend(MappingPragmas3)
          if r14
            r14 = SyntaxNode.new(input, (index-1)...index) if r14 == true
            r0 = r14
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:mapping_pragmas][start_index] = r0

        r0
      end

      module MappingPragma0
        def id
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module MappingPragma1
        def was
          elements[0]
        end

        def s
          elements[1]
        end

        def names
          elements[2]
        end
      end

      module MappingPragma2
        # Old or previous name of an object type:
               def value
                 [ was.text_value ] + names.elements.map{|n|n.text_value}
               end
      end

      module MappingPragma3
        def s
          elements[0]
        end

        def id
          elements[1]
        end
      end

      module MappingPragma4
        def head
          elements[0]
        end

        def tail
          elements[1]
        end
      end

      module MappingPragma5
        # A sequence of one or more words denoting a pragma:
               def value
                 ([head]+tail.elements.map(&:id)).map(&:text_value)
               end
      end

      def _nt_mapping_pragma
        start_index = index
        if node_cache[:mapping_pragma].has_key?(index)
          cached = node_cache[:mapping_pragma][index]
          if cached
            node_cache[:mapping_pragma][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_was
        s1 << r2
        if r2
          r3 = _nt_s
          s1 << r3
          if r3
            s4, i4 = [], index
            loop do
              i5, s5 = index, []
              r6 = _nt_id
              s5 << r6
              if r6
                r7 = _nt_s
                s5 << r7
              end
              if s5.last
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                r5.extend(MappingPragma0)
              else
                @index = i5
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            if s4.empty?
              @index = i4
              r4 = nil
            else
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            end
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(MappingPragma1)
          r1.extend(MappingPragma2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i8, s8 = index, []
          r9 = _nt_id
          s8 << r9
          if r9
            s10, i10 = [], index
            loop do
              i11, s11 = index, []
              r12 = _nt_s
              s11 << r12
              if r12
                r13 = _nt_id
                s11 << r13
              end
              if s11.last
                r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                r11.extend(MappingPragma3)
              else
                @index = i11
                r11 = nil
              end
              if r11
                s10 << r11
              else
                break
              end
            end
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            s8 << r10
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(MappingPragma4)
            r8.extend(MappingPragma5)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r0 = r8
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:mapping_pragma][start_index] = r0

        r0
      end

      module EntityClauses0
        def s
          elements[1]
        end

        def query_clauses
          elements[2]
        end
      end

      module EntityClauses1
        def ast
          query_clauses.ast
        end
      end

      def _nt_entity_clauses
        start_index = index
        if node_cache[:entity_clauses].has_key?(index)
          cached = node_cache[:entity_clauses][index]
          if cached
            node_cache[:entity_clauses][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        if (match_len = has_terminal?(':', false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('\':\'')
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_where
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          r4 = _nt_s
          s0 << r4
          if r4
            r5 = _nt_query_clauses
            s0 << r5
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(EntityClauses0)
          r0.extend(EntityClauses1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:entity_clauses][start_index] = r0

        r0
      end

    end

    class ObjectTypesParser < Treetop::Runtime::CompiledParser
      include ObjectTypes
    end

  end
end
