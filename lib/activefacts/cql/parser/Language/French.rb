# Encoding: UTF-8
# Autogenerated from a Treetop grammar. Edits may be lost.


#
#       ActiveFacts CQL Parser.
#       Parse rules the French syntax elements for CQL.
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
module ActiveFacts
  module CQL
    module French
      include Treetop::Runtime

      def root
        @root ||= :written_as
      end

      module WrittenAs0
        def s1
          elements[0]
        end

        def est
          elements[1]
        end

        def s2
          elements[2]
        end

        def S
          elements[4]
        end

        def s3
          elements[6]
        end
      end

      def _nt_written_as
        start_index = index
        if node_cache[:written_as].has_key?(index)
          cached = node_cache[:written_as][index]
          if cached
            node_cache[:written_as][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_est
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              if (match_len = has_terminal?('écrit', false, index))
                r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'écrit\'')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_S
                s0 << r5
                if r5
                  if (match_len = has_terminal?('en', false, index))
                    r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'en\'')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_s
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(WrittenAs0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:written_as][start_index] = r0

        r0
      end

      module AutoAssignment0
        def S
          elements[1]
        end

        def to
          elements[2]
        end

        def time
          elements[3]
        end

        def s
          elements[5]
        end
      end

      module AutoAssignment1
        def auto_assigned_at
          time.text_value == 'assertion' ? 'assert' : 'commit'
        end
      end

      def _nt_auto_assignment
        start_index = index
        if node_cache[:auto_assignment].has_key?(index)
          cached = node_cache[:auto_assignment][index]
          if cached
            node_cache[:auto_assignment][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('auto-assigné', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'auto-assigné\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_to
            s0 << r3
            if r3
              i4 = index
              if (match_len = has_terminal?('assertion', false, index))
                r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'assertion\'')
                r5 = nil
              end
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r4 = r5
              else
                if (match_len = has_terminal?('validation', false, index))
                  r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'validation\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r4 = r6
                else
                  @index = i4
                  r4 = nil
                end
              end
              s0 << r4
              if r4
                i7 = index
                r8 = _nt_alphanumeric
                if r8
                  @index = i7
                  r7 = nil
                else
                  @index = i7
                  r7 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r7
                if r7
                  r9 = _nt_s
                  s0 << r9
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AutoAssignment0)
          r0.extend(AutoAssignment1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:auto_assignment][start_index] = r0

        r0
      end

      module IdentifiedBy0
        def s1
          elements[1]
        end

        def s2
          elements[3]
        end
      end

      def _nt_identified_by
        start_index = index
        if node_cache[:identified_by].has_key?(index)
          cached = node_cache[:identified_by][index]
          if cached
            node_cache[:identified_by][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('identifié', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'identifié\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?('par', false, index))
              r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'par\'')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IdentifiedBy0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:identified_by][start_index] = r0

        r0
      end

      module BasetypeExpression0
        def independent
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module BasetypeExpression1
        def is
          elements[0]
        end

        def s
          elements[1]
        end

        def i
          elements[2]
        end

        def identification
          elements[3]
        end
      end

      def _nt_basetype_expression
        start_index = index
        if node_cache[:basetype_expression].has_key?(index)
          cached = node_cache[:basetype_expression][index]
          if cached
            node_cache[:basetype_expression][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_is
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            i4, s4 = index, []
            r5 = _nt_independent
            s4 << r5
            if r5
              r6 = _nt_s
              s4 << r6
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(BasetypeExpression0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
            if r3
              r7 = _nt_identification
              s0 << r7
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(BasetypeExpression1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:basetype_expression][start_index] = r0

        r0
      end

      module SubtypePrefix0
        def est
          elements[0]
        end

        def s1
          elements[1]
        end

        def un
          elements[2]
        end

        def s2
          elements[3]
        end

        def s3
          elements[5]
        end

        def S
          elements[7]
        end
      end

      def _nt_subtype_prefix
        start_index = index
        if node_cache[:subtype_prefix].has_key?(index)
          cached = node_cache[:subtype_prefix][index]
          if cached
            node_cache[:subtype_prefix][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_est
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_un
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?('type', false, index))
                  r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'type\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  if (match_len = has_terminal?('genre', false, index))
                    r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'genre\'')
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r8 = _nt_s
                  s0 << r8
                  if r8
                    if (match_len = has_terminal?('de', false, index))
                      r9 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('\'de\'')
                      r9 = nil
                    end
                    s0 << r9
                    if r9
                      r10 = _nt_S
                      s0 << r10
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SubtypePrefix0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:subtype_prefix][start_index] = r0

        r0
      end

      module SubtypeExpression0
        def independent
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module SubtypeExpression1
        def subtype_prefix
          elements[0]
        end

        def i
          elements[1]
        end

        def supertype_list
          elements[2]
        end

        def ident
          elements[3]
        end
      end

      def _nt_subtype_expression
        start_index = index
        if node_cache[:subtype_expression].has_key?(index)
          cached = node_cache[:subtype_expression][index]
          if cached
            node_cache[:subtype_expression][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_subtype_prefix
        s0 << r1
        if r1
          i3, s3 = index, []
          r4 = _nt_independent
          s3 << r4
          if r4
            r5 = _nt_s
            s3 << r5
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(SubtypeExpression0)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r6 = _nt_supertype_list
            s0 << r6
            if r6
              r8 = _nt_identification
              if r8
                r7 = r8
              else
                r7 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r7
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SubtypeExpression1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:subtype_expression][start_index] = r0

        r0
      end

      module IsWhere0
        def independent
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module IsWhere1
        def existe
          elements[0]
        end

        def s
          elements[1]
        end

        def i
          elements[2]
        end

        def si
          elements[3]
        end
      end

      module IsWhere2
        def independent; !i.empty?; end
      end

      def _nt_is_where
        start_index = index
        if node_cache[:is_where].has_key?(index)
          cached = node_cache[:is_where][index]
          if cached
            node_cache[:is_where][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_existe
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            i4, s4 = index, []
            r5 = _nt_independent
            s4 << r5
            if r5
              r6 = _nt_s
              s4 << r6
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(IsWhere0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
            if r3
              r7 = _nt_si
              s0 << r7
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IsWhere1)
          r0.extend(IsWhere2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:is_where][start_index] = r0

        r0
      end

      module InWhich0
        def dans
          elements[0]
        end

        def s
          elements[1]
        end

        def laquel
          elements[2]
        end
      end

      def _nt_in_which
        start_index = index
        if node_cache[:in_which].has_key?(index)
          cached = node_cache[:in_which][index]
          if cached
            node_cache[:in_which][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_where
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i2, s2 = index, []
          r3 = _nt_dans
          s2 << r3
          if r3
            r4 = _nt_s
            s2 << r4
            if r4
              r5 = _nt_laquel
              s2 << r5
            end
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(InWhich0)
          else
            @index = i2
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:in_which][start_index] = r0

        r0
      end

      module Conversion0
        def approximately
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Conversion1
        def converts
          elements[0]
        end

        def s1
          elements[1]
        end

        def a
          elements[2]
        end

        def to
          elements[3]
        end

        def s2
          elements[4]
        end
      end

      module Conversion2
        def approximate?
          !a.empty?
        end
      end

      def _nt_conversion
        start_index = index
        if node_cache[:conversion].has_key?(index)
          cached = node_cache[:conversion][index]
          if cached
            node_cache[:conversion][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_converts
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            i4, s4 = index, []
            r5 = _nt_approximately
            s4 << r5
            if r5
              r6 = _nt_s
              s4 << r6
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(Conversion0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
            if r3
              r7 = _nt_to
              s0 << r7
              if r7
                r8 = _nt_s
                s0 << r8
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Conversion1)
          r0.extend(Conversion2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:conversion][start_index] = r0

        r0
      end

      module EachOccursInClauses0
        def S
          elements[1]
        end
      end

      module EachOccursInClauses1
        def s1
          elements[0]
        end

        def chaque
          elements[1]
        end

        def s2
          elements[2]
        end

        def role_list
          elements[4]
        end

        def s3
          elements[5]
        end

        def existe
          elements[6]
        end

        def s4
          elements[7]
        end

        def quantifier
          elements[8]
        end

        def S1
          elements[10]
        end

        def S2
          elements[12]
        end

        def ce
          elements[13]
        end

        def S3
          elements[14]
        end

        def S4
          elements[16]
        end

        def s5
          elements[18]
        end

        def s6
          elements[20]
        end

        def clauses_list
          elements[21]
        end

        def s7
          elements[22]
        end

        def c
          elements[23]
        end

      end

      module EachOccursInClauses2
        def role_list_ast
          role_list.ast
        end
        def quantifier_ast
          quantifier.ast
        end
        def clauses_ast
          clauses_list.ast
        end
      end

      def _nt_each_occurs_in_clauses
        start_index = index
        if node_cache[:each_occurs_in_clauses].has_key?(index)
          cached = node_cache[:each_occurs_in_clauses][index]
          if cached
            node_cache[:each_occurs_in_clauses][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_chaque
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              i5, s5 = index, []
              if (match_len = has_terminal?('combinaison', false, index))
                r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'combinaison\'')
                r6 = nil
              end
              s5 << r6
              if r6
                r7 = _nt_S
                s5 << r7
              end
              if s5.last
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                r5.extend(EachOccursInClauses0)
              else
                @index = i5
                r5 = nil
              end
              if r5
                r4 = r5
              else
                r4 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r4
              if r4
                r8 = _nt_role_list
                s0 << r8
                if r8
                  r9 = _nt_s
                  s0 << r9
                  if r9
                    r10 = _nt_existe
                    s0 << r10
                    if r10
                      r11 = _nt_s
                      s0 << r11
                      if r11
                        r12 = _nt_quantifier
                        s0 << r12
                        if r12
                          if (match_len = has_terminal?('fois', false, index))
                            r13 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                            @index += match_len
                          else
                            terminal_parse_failure('\'fois\'')
                            r13 = nil
                          end
                          s0 << r13
                          if r13
                            r14 = _nt_S
                            s0 << r14
                            if r14
                              if (match_len = has_terminal?('parmis', false, index))
                                r15 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                                @index += match_len
                              else
                                terminal_parse_failure('\'parmis\'')
                                r15 = nil
                              end
                              s0 << r15
                              if r15
                                r16 = _nt_S
                                s0 << r16
                                if r16
                                  r17 = _nt_ce
                                  s0 << r17
                                  if r17
                                    r18 = _nt_S
                                    s0 << r18
                                    if r18
                                      if (match_len = has_terminal?('qui', false, index))
                                        r19 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                                        @index += match_len
                                      else
                                        terminal_parse_failure('\'qui\'')
                                        r19 = nil
                                      end
                                      s0 << r19
                                      if r19
                                        r20 = _nt_S
                                        s0 << r20
                                        if r20
                                          if (match_len = has_terminal?('suit', false, index))
                                            r21 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                                            @index += match_len
                                          else
                                            terminal_parse_failure('\'suit\'')
                                            r21 = nil
                                          end
                                          s0 << r21
                                          if r21
                                            r22 = _nt_s
                                            s0 << r22
                                            if r22
                                              if (match_len = has_terminal?(':', false, index))
                                                r23 = true
                                                @index += match_len
                                              else
                                                terminal_parse_failure('\':\'')
                                                r23 = nil
                                              end
                                              s0 << r23
                                              if r23
                                                r24 = _nt_s
                                                s0 << r24
                                                if r24
                                                  r25 = _nt_clauses_list
                                                  s0 << r25
                                                  if r25
                                                    r26 = _nt_s
                                                    s0 << r26
                                                    if r26
                                                      r28 = _nt_context_note
                                                      if r28
                                                        r27 = r28
                                                      else
                                                        r27 = instantiate_node(SyntaxNode,input, index...index)
                                                      end
                                                      s0 << r27
                                                      if r27
                                                        if (match_len = has_terminal?(';', false, index))
                                                          r29 = true
                                                          @index += match_len
                                                        else
                                                          terminal_parse_failure('\';\'')
                                                          r29 = nil
                                                        end
                                                        s0 << r29
                                                      end
                                                    end
                                                  end
                                                end
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(EachOccursInClauses1)
          r0.extend(EachOccursInClauses2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:each_occurs_in_clauses][start_index] = r0

        r0
      end

      module EitherOr0
        def s1
          elements[0]
        end

        def soit
          elements[1]
        end

        def s2
          elements[2]
        end

        def r1
          elements[3]
        end

        def s3
          elements[4]
        end

        def S
          elements[6]
        end

        def r2
          elements[7]
        end

        def s4
          elements[8]
        end

        def c
          elements[9]
        end

        def enforcement
          elements[10]
        end

      end

      module EitherOr1
        def role_list_ast
          nil
        end
        def quantifier_ast
          Compiler::Quantifier.new(1, nil)
        end
        def clauses_ast
          [r1.ast, r2.ast]
        end
      end

      def _nt_either_or
        start_index = index
        if node_cache[:either_or].has_key?(index)
          cached = node_cache[:either_or][index]
          if cached
            node_cache[:either_or][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_soit
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              r4 = _nt_clauses
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  if (match_len = has_terminal?('ou', false, index))
                    r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'ou\'')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_S
                    s0 << r7
                    if r7
                      r8 = _nt_clauses
                      s0 << r8
                      if r8
                        r9 = _nt_s
                        s0 << r9
                        if r9
                          r11 = _nt_context_note
                          if r11
                            r10 = r11
                          else
                            r10 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r10
                          if r10
                            r12 = _nt_enforcement
                            s0 << r12
                            if r12
                              if (match_len = has_terminal?(';', false, index))
                                r13 = true
                                @index += match_len
                              else
                                terminal_parse_failure('\';\'')
                                r13 = nil
                              end
                              s0 << r13
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(EitherOr0)
          r0.extend(EitherOr1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:either_or][start_index] = r0

        r0
      end

      module ForEachHowMany0
        def S1
          elements[1]
        end

        def S2
          elements[3]
        end

        def role_list
          elements[4]
        end

        def s1
          elements[5]
        end

        def quantifier
          elements[6]
        end

        def s2
          elements[7]
        end

        def S3
          elements[9]
        end

        def S4
          elements[11]
        end

        def s3
          elements[13]
        end

        def s4
          elements[15]
        end

        def clauses_list
          elements[16]
        end

        def s5
          elements[17]
        end

        def c
          elements[18]
        end

      end

      module ForEachHowMany1
        def role_list_ast
          role_list.ast
        end
        def quantifier_ast
          quantifier.ast
        end
        def clauses_ast
          clauses_list.ast
        end
      end

      def _nt_for_each_how_many
        start_index = index
        if node_cache[:for_each_how_many].has_key?(index)
          cached = node_cache[:for_each_how_many][index]
          if cached
            node_cache[:for_each_how_many][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('pour', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'pour\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            if (match_len = has_terminal?('chaque', false, index))
              r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'chaque\'')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                r5 = _nt_role_list
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    r7 = _nt_quantifier
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                      if r8
                        if (match_len = has_terminal?('des', false, index))
                          r9 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                          @index += match_len
                        else
                          terminal_parse_failure('\'des\'')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_S
                          s0 << r10
                          if r10
                            if (match_len = has_terminal?('suivants', false, index))
                              r11 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                              @index += match_len
                            else
                              terminal_parse_failure('\'suivants\'')
                              r11 = nil
                            end
                            s0 << r11
                            if r11
                              r12 = _nt_S
                              s0 << r12
                              if r12
                                if (match_len = has_terminal?('s\'applique', false, index))
                                  r13 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                                  @index += match_len
                                else
                                  terminal_parse_failure('\'s\\\'applique\'')
                                  r13 = nil
                                end
                                s0 << r13
                                if r13
                                  r14 = _nt_s
                                  s0 << r14
                                  if r14
                                    if (match_len = has_terminal?(':', false, index))
                                      r15 = true
                                      @index += match_len
                                    else
                                      terminal_parse_failure('\':\'')
                                      r15 = nil
                                    end
                                    s0 << r15
                                    if r15
                                      r16 = _nt_s
                                      s0 << r16
                                      if r16
                                        r17 = _nt_clauses_list
                                        s0 << r17
                                        if r17
                                          r18 = _nt_s
                                          s0 << r18
                                          if r18
                                            r20 = _nt_context_note
                                            if r20
                                              r19 = r20
                                            else
                                              r19 = instantiate_node(SyntaxNode,input, index...index)
                                            end
                                            s0 << r19
                                            if r19
                                              if (match_len = has_terminal?(';', false, index))
                                                r21 = true
                                                @index += match_len
                                              else
                                                terminal_parse_failure('\';\'')
                                                r21 = nil
                                              end
                                              s0 << r21
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ForEachHowMany0)
          r0.extend(ForEachHowMany1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:for_each_how_many][start_index] = r0

        r0
      end

      module EitherOrNotBoth0
        def s1
          elements[0]
        end

        def soit
          elements[1]
        end

        def s2
          elements[2]
        end

        def r1
          elements[3]
        end

        def s3
          elements[4]
        end

        def S1
          elements[6]
        end

        def r2
          elements[7]
        end

        def S2
          elements[9]
        end

        def S3
          elements[11]
        end

        def S4
          elements[13]
        end

        def s4
          elements[15]
        end

        def c
          elements[16]
        end

        def enforcement
          elements[17]
        end

      end

      module EitherOrNotBoth1
        def role_list_ast
          nil
        end
        def quantifier_ast
          Compiler::Quantifier.new(1, 1)
        end
        def clauses_ast
          [r1.ast, r2.ast]
        end
      end

      def _nt_either_or_not_both
        start_index = index
        if node_cache[:either_or_not_both].has_key?(index)
          cached = node_cache[:either_or_not_both][index]
          if cached
            node_cache[:either_or_not_both][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_soit
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              r4 = _nt_clauses
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  if (match_len = has_terminal?('ou', false, index))
                    r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'ou\'')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_S
                    s0 << r7
                    if r7
                      r8 = _nt_clauses
                      s0 << r8
                      if r8
                        if (match_len = has_terminal?('mais', false, index))
                          r9 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                          @index += match_len
                        else
                          terminal_parse_failure('\'mais\'')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_S
                          s0 << r10
                          if r10
                            if (match_len = has_terminal?('pas', false, index))
                              r11 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                              @index += match_len
                            else
                              terminal_parse_failure('\'pas\'')
                              r11 = nil
                            end
                            s0 << r11
                            if r11
                              r12 = _nt_S
                              s0 << r12
                              if r12
                                if (match_len = has_terminal?('les', false, index))
                                  r13 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                                  @index += match_len
                                else
                                  terminal_parse_failure('\'les\'')
                                  r13 = nil
                                end
                                s0 << r13
                                if r13
                                  r14 = _nt_S
                                  s0 << r14
                                  if r14
                                    if (match_len = has_terminal?('deux', false, index))
                                      r15 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                                      @index += match_len
                                    else
                                      terminal_parse_failure('\'deux\'')
                                      r15 = nil
                                    end
                                    s0 << r15
                                    if r15
                                      r16 = _nt_s
                                      s0 << r16
                                      if r16
                                        r18 = _nt_context_note
                                        if r18
                                          r17 = r18
                                        else
                                          r17 = instantiate_node(SyntaxNode,input, index...index)
                                        end
                                        s0 << r17
                                        if r17
                                          r19 = _nt_enforcement
                                          s0 << r19
                                          if r19
                                            if (match_len = has_terminal?(';', false, index))
                                              r20 = true
                                              @index += match_len
                                            else
                                              terminal_parse_failure('\';\'')
                                              r20 = nil
                                            end
                                            s0 << r20
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(EitherOrNotBoth0)
          r0.extend(EitherOrNotBoth1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:either_or_not_both][start_index] = r0

        r0
      end

      module AOnlyIfB0
        def s1
          elements[0]
        end

        def clauses
          elements[1]
        end

        def s2
          elements[2]
        end

        def only_if
          elements[3]
        end

        def r2
          elements[4]
        end

        def s3
          elements[5]
        end

        def c
          elements[6]
        end

        def enforcement
          elements[7]
        end

      end

      def _nt_a_only_if_b
        start_index = index
        if node_cache[:a_only_if_b].has_key?(index)
          cached = node_cache[:a_only_if_b][index]
          if cached
            node_cache[:a_only_if_b][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_clauses
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              r4 = _nt_only_if
              s0 << r4
              if r4
                r5 = _nt_clauses
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    r8 = _nt_context_note
                    if r8
                      r7 = r8
                    else
                      r7 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r7
                    if r7
                      r9 = _nt_enforcement
                      s0 << r9
                      if r9
                        if (match_len = has_terminal?(';', false, index))
                          r10 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\';\'')
                          r10 = nil
                        end
                        s0 << r10
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AOnlyIfB0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:a_only_if_b][start_index] = r0

        r0
      end

      module OnlyIf0
        def que
          elements[0]
        end

        def s1
          elements[1]
        end

        def si
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      def _nt_only_if
        start_index = index
        if node_cache[:only_if].has_key?(index)
          cached = node_cache[:only_if][index]
          if cached
            node_cache[:only_if][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_que
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_si
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(OnlyIf0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:only_if][start_index] = r0

        r0
      end

      module IfBThenA0
        def s1
          elements[0]
        end

        def S1
          elements[2]
        end

        def clauses
          elements[3]
        end

        def s2
          elements[4]
        end

        def S2
          elements[6]
        end

        def r2
          elements[7]
        end

        def s3
          elements[8]
        end

        def c
          elements[9]
        end

        def enforcement
          elements[10]
        end

      end

      def _nt_if_b_then_a
        start_index = index
        if node_cache[:if_b_then_a].has_key?(index)
          cached = node_cache[:if_b_then_a][index]
          if cached
            node_cache[:if_b_then_a][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          if (match_len = has_terminal?('si', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'si\'')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_S
            s0 << r3
            if r3
              r4 = _nt_clauses
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  if (match_len = has_terminal?('puis', false, index))
                    r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'puis\'')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_S
                    s0 << r7
                    if r7
                      r8 = _nt_clauses
                      s0 << r8
                      if r8
                        r9 = _nt_s
                        s0 << r9
                        if r9
                          r11 = _nt_context_note
                          if r11
                            r10 = r11
                          else
                            r10 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r10
                          if r10
                            r12 = _nt_enforcement
                            s0 << r12
                            if r12
                              if (match_len = has_terminal?(';', false, index))
                                r13 = true
                                @index += match_len
                              else
                                terminal_parse_failure('\';\'')
                                r13 = nil
                              end
                              s0 << r13
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IfBThenA0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:if_b_then_a][start_index] = r0

        r0
      end

      module IfAndOnlyIf0
        def S1
          elements[1]
        end

        def S2
          elements[3]
        end

        def S3
          elements[5]
        end

        def S4
          elements[7]
        end

        def clauses
          elements[8]
        end

        def s
          elements[9]
        end
      end

      module IfAndOnlyIf1
        def s1
          elements[0]
        end

        def clauses
          elements[1]
        end

        def s2
          elements[2]
        end

        def tail
          elements[3]
        end

        def c
          elements[4]
        end

        def enforcement
          elements[5]
        end

      end

      def _nt_if_and_only_if
        start_index = index
        if node_cache[:if_and_only_if].has_key?(index)
          cached = node_cache[:if_and_only_if][index]
          if cached
            node_cache[:if_and_only_if][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_clauses
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              s4, i4 = [], index
              loop do
                i5, s5 = index, []
                if (match_len = has_terminal?('si', false, index))
                  r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'si\'')
                  r6 = nil
                end
                s5 << r6
                if r6
                  r7 = _nt_S
                  s5 << r7
                  if r7
                    if (match_len = has_terminal?('et', false, index))
                      r8 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('\'et\'')
                      r8 = nil
                    end
                    s5 << r8
                    if r8
                      r9 = _nt_S
                      s5 << r9
                      if r9
                        i10 = index
                        if (match_len = has_terminal?('seulement', false, index))
                          r11 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                          @index += match_len
                        else
                          terminal_parse_failure('\'seulement\'')
                          r11 = nil
                        end
                        if r11
                          r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                          r10 = r11
                        else
                          if (match_len = has_terminal?('uniquement', false, index))
                            r12 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                            @index += match_len
                          else
                            terminal_parse_failure('\'uniquement\'')
                            r12 = nil
                          end
                          if r12
                            r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                            r10 = r12
                          else
                            if (match_len = has_terminal?('que', false, index))
                              r13 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                              @index += match_len
                            else
                              terminal_parse_failure('\'que\'')
                              r13 = nil
                            end
                            if r13
                              r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                              r10 = r13
                            else
                              @index = i10
                              r10 = nil
                            end
                          end
                        end
                        s5 << r10
                        if r10
                          r14 = _nt_S
                          s5 << r14
                          if r14
                            if (match_len = has_terminal?('si', false, index))
                              r15 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                              @index += match_len
                            else
                              terminal_parse_failure('\'si\'')
                              r15 = nil
                            end
                            s5 << r15
                            if r15
                              r16 = _nt_S
                              s5 << r16
                              if r16
                                r17 = _nt_clauses
                                s5 << r17
                                if r17
                                  r18 = _nt_s
                                  s5 << r18
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
                if s5.last
                  r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                  r5.extend(IfAndOnlyIf0)
                else
                  @index = i5
                  r5 = nil
                end
                if r5
                  s4 << r5
                else
                  break
                end
              end
              if s4.empty?
                @index = i4
                r4 = nil
              else
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              end
              s0 << r4
              if r4
                r20 = _nt_context_note
                if r20
                  r19 = r20
                else
                  r19 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r19
                if r19
                  r21 = _nt_enforcement
                  s0 << r21
                  if r21
                    if (match_len = has_terminal?(';', false, index))
                      r22 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\';\'')
                      r22 = nil
                    end
                    s0 << r22
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IfAndOnlyIf1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:if_and_only_if][start_index] = r0

        r0
      end

      def _nt_role_list_constraint_followers
        start_index = index
        if node_cache[:role_list_constraint_followers].has_key?(index)
          cached = node_cache[:role_list_constraint_followers][index]
          if cached
            node_cache[:role_list_constraint_followers][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_existe

        node_cache[:role_list_constraint_followers][start_index] = r0

        r0
      end

      module Quantifier0
        def chaque
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantifier1
        def value; [1, nil]; end
      end

      module Quantifier2
        def un
          elements[0]
        end

        def s
          elements[1]
        end

      end

      module Quantifier3
        def s
          elements[1]
        end
      end

      module Quantifier4
        def value; nil; end
      end

      module Quantifier5
        def ce
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantifier6
        def value; nil; end
      end

      module Quantifier7
        def un
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantifier8
        def value; [1, 1]; end
      end

      module Quantifier9
        def s1
          elements[1]
        end

        def s2
          elements[3]
        end
      end

      module Quantifier10
        def value; [0, 0]; end
      end

      module Quantifier11
        def exactement
          elements[0]
        end

        def s
          elements[1]
        end

        def quantity
          elements[2]
        end
      end

      module Quantifier12
        def value; q = quantity.value; [q, q]; end
      end

      module Quantifier13
        def et
          elements[0]
        end

        def s1
          elements[1]
        end

        def au
          elements[2]
        end

        def s2
          elements[3]
        end

        def plus
          elements[4]
        end

        def q
          elements[5]
        end
      end

      module Quantifier14
        def au
          elements[0]
        end

        def s1
          elements[1]
        end

        def moins
          elements[2]
        end

        def s2
          elements[3]
        end

        def quantity
          elements[4]
        end

        def most
          elements[5]
        end
      end

      module Quantifier15
        def value; [ quantity.value, most.empty? ? nil : most.q.value ]; end
      end

      module Quantifier16
        def au
          elements[0]
        end

        def s1
          elements[1]
        end

        def plus
          elements[2]
        end

        def s2
          elements[3]
        end

        def quantity
          elements[4]
        end
      end

      module Quantifier17
        def value; [ nil, quantity.value ]; end
      end

      module Quantifier18
        def entre
          elements[0]
        end

        def s1
          elements[1]
        end

        def numeric_range
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module Quantifier19
        def value; numeric_range.value; end
      end

      module Quantifier20
        def soit1
          elements[0]
        end

        def s1
          elements[1]
        end

        def tous
          elements[2]
        end

        def s2
          elements[3]
        end

        def soit2
          elements[4]
        end

        def s3
          elements[5]
        end

        def aucun
          elements[6]
        end
      end

      module Quantifier21
        def value; [ -1, 1 ]; end
      end

      module Quantifier22
        def ast
          v = value
          Compiler::Quantifier.new(v[0], v[1])
        end
      end

      def _nt_quantifier
        start_index = index
        if node_cache[:quantifier].has_key?(index)
          cached = node_cache[:quantifier][index]
          if cached
            node_cache[:quantifier][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        i2 = index
        i3, s3 = index, []
        r4 = _nt_chaque
        s3 << r4
        if r4
          r5 = _nt_s
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Quantifier0)
          r3.extend(Quantifier1)
        else
          @index = i3
          r3 = nil
        end
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r2 = r3
        else
          i6, s6 = index, []
          r7 = _nt_un
          s6 << r7
          if r7
            r8 = _nt_s
            s6 << r8
            if r8
              if (match_len = has_terminal?('certain', false, index))
                r9 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'certain\'')
                r9 = nil
              end
              s6 << r9
              if r9
                if (match_len = has_terminal?('e', false, index))
                  r11 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'e\'')
                  r11 = nil
                end
                if r11
                  r10 = r11
                else
                  r10 = instantiate_node(SyntaxNode,input, index...index)
                end
                s6 << r10
              end
            end
          end
          if s6.last
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            r6.extend(Quantifier2)
          else
            @index = i6
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r2 = r6
          else
            @index = i2
            r2 = nil
          end
        end
        s1 << r2
        if r2
          r12 = _nt_s
          s1 << r12
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Quantifier3)
          r1.extend(Quantifier4)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(Quantifier22)
          r0.extend(Quantifier22)
        else
          i13, s13 = index, []
          r14 = _nt_ce
          s13 << r14
          if r14
            r15 = _nt_s
            s13 << r15
          end
          if s13.last
            r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
            r13.extend(Quantifier5)
            r13.extend(Quantifier6)
          else
            @index = i13
            r13 = nil
          end
          if r13
            r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
            r0 = r13
            r0.extend(Quantifier22)
            r0.extend(Quantifier22)
          else
            i16, s16 = index, []
            r17 = _nt_un
            s16 << r17
            if r17
              r18 = _nt_s
              s16 << r18
            end
            if s16.last
              r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
              r16.extend(Quantifier7)
              r16.extend(Quantifier8)
            else
              @index = i16
              r16 = nil
            end
            if r16
              r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
              r0 = r16
              r0.extend(Quantifier22)
              r0.extend(Quantifier22)
            else
              i19, s19 = index, []
              if (match_len = has_terminal?('pas', false, index))
                r20 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'pas\'')
                r20 = nil
              end
              s19 << r20
              if r20
                r21 = _nt_s
                s19 << r21
                if r21
                  if (match_len = has_terminal?('de', false, index))
                    r22 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'de\'')
                    r22 = nil
                  end
                  s19 << r22
                  if r22
                    r23 = _nt_s
                    s19 << r23
                  end
                end
              end
              if s19.last
                r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                r19.extend(Quantifier9)
                r19.extend(Quantifier10)
              else
                @index = i19
                r19 = nil
              end
              if r19
                r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
                r0 = r19
                r0.extend(Quantifier22)
                r0.extend(Quantifier22)
              else
                i24, s24 = index, []
                r25 = _nt_exactement
                s24 << r25
                if r25
                  r26 = _nt_s
                  s24 << r26
                  if r26
                    r27 = _nt_quantity
                    s24 << r27
                  end
                end
                if s24.last
                  r24 = instantiate_node(SyntaxNode,input, i24...index, s24)
                  r24.extend(Quantifier11)
                  r24.extend(Quantifier12)
                else
                  @index = i24
                  r24 = nil
                end
                if r24
                  r24 = SyntaxNode.new(input, (index-1)...index) if r24 == true
                  r0 = r24
                  r0.extend(Quantifier22)
                  r0.extend(Quantifier22)
                else
                  i28, s28 = index, []
                  r29 = _nt_au
                  s28 << r29
                  if r29
                    r30 = _nt_s
                    s28 << r30
                    if r30
                      r31 = _nt_moins
                      s28 << r31
                      if r31
                        r32 = _nt_s
                        s28 << r32
                        if r32
                          r33 = _nt_quantity
                          s28 << r33
                          if r33
                            i35, s35 = index, []
                            r36 = _nt_et
                            s35 << r36
                            if r36
                              r37 = _nt_s
                              s35 << r37
                              if r37
                                r38 = _nt_au
                                s35 << r38
                                if r38
                                  r39 = _nt_s
                                  s35 << r39
                                  if r39
                                    r40 = _nt_plus
                                    s35 << r40
                                    if r40
                                      r41 = _nt_quantity
                                      s35 << r41
                                    end
                                  end
                                end
                              end
                            end
                            if s35.last
                              r35 = instantiate_node(SyntaxNode,input, i35...index, s35)
                              r35.extend(Quantifier13)
                            else
                              @index = i35
                              r35 = nil
                            end
                            if r35
                              r34 = r35
                            else
                              r34 = instantiate_node(SyntaxNode,input, index...index)
                            end
                            s28 << r34
                          end
                        end
                      end
                    end
                  end
                  if s28.last
                    r28 = instantiate_node(SyntaxNode,input, i28...index, s28)
                    r28.extend(Quantifier14)
                    r28.extend(Quantifier15)
                  else
                    @index = i28
                    r28 = nil
                  end
                  if r28
                    r28 = SyntaxNode.new(input, (index-1)...index) if r28 == true
                    r0 = r28
                    r0.extend(Quantifier22)
                    r0.extend(Quantifier22)
                  else
                    i42, s42 = index, []
                    r43 = _nt_au
                    s42 << r43
                    if r43
                      r44 = _nt_s
                      s42 << r44
                      if r44
                        r45 = _nt_plus
                        s42 << r45
                        if r45
                          r46 = _nt_s
                          s42 << r46
                          if r46
                            r47 = _nt_quantity
                            s42 << r47
                          end
                        end
                      end
                    end
                    if s42.last
                      r42 = instantiate_node(SyntaxNode,input, i42...index, s42)
                      r42.extend(Quantifier16)
                      r42.extend(Quantifier17)
                    else
                      @index = i42
                      r42 = nil
                    end
                    if r42
                      r42 = SyntaxNode.new(input, (index-1)...index) if r42 == true
                      r0 = r42
                      r0.extend(Quantifier22)
                      r0.extend(Quantifier22)
                    else
                      i48, s48 = index, []
                      r49 = _nt_entre
                      s48 << r49
                      if r49
                        r50 = _nt_s
                        s48 << r50
                        if r50
                          r51 = _nt_numeric_range
                          s48 << r51
                          if r51
                            r52 = _nt_s
                            s48 << r52
                          end
                        end
                      end
                      if s48.last
                        r48 = instantiate_node(SyntaxNode,input, i48...index, s48)
                        r48.extend(Quantifier18)
                        r48.extend(Quantifier19)
                      else
                        @index = i48
                        r48 = nil
                      end
                      if r48
                        r48 = SyntaxNode.new(input, (index-1)...index) if r48 == true
                        r0 = r48
                        r0.extend(Quantifier22)
                        r0.extend(Quantifier22)
                      else
                        i53, s53 = index, []
                        r54 = _nt_soit
                        s53 << r54
                        if r54
                          r55 = _nt_s
                          s53 << r55
                          if r55
                            r56 = _nt_tous
                            s53 << r56
                            if r56
                              r57 = _nt_s
                              s53 << r57
                              if r57
                                r58 = _nt_soit
                                s53 << r58
                                if r58
                                  r59 = _nt_s
                                  s53 << r59
                                  if r59
                                    r60 = _nt_aucun
                                    s53 << r60
                                  end
                                end
                              end
                            end
                          end
                        end
                        if s53.last
                          r53 = instantiate_node(SyntaxNode,input, i53...index, s53)
                          r53.extend(Quantifier20)
                          r53.extend(Quantifier21)
                        else
                          @index = i53
                          r53 = nil
                        end
                        if r53
                          r53 = SyntaxNode.new(input, (index-1)...index) if r53 == true
                          r0 = r53
                          r0.extend(Quantifier22)
                          r0.extend(Quantifier22)
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:quantifier][start_index] = r0

        r0
      end

      module Quantity0
        def un
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantity1
        def value; 1; end
      end

      module Quantity2
        def number
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantity3
        def value; number.value; end
      end

      def _nt_quantity
        start_index = index
        if node_cache[:quantity].has_key?(index)
          cached = node_cache[:quantity][index]
          if cached
            node_cache[:quantity][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_un
        s1 << r2
        if r2
          r3 = _nt_s
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Quantity0)
          r1.extend(Quantity1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_number
          s4 << r5
          if r5
            r6 = _nt_s
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Quantity2)
            r4.extend(Quantity3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:quantity][start_index] = r0

        r0
      end

      module AsAgreedBy0
        def s1
          elements[1]
        end

        def date
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module AsAgreedBy1
        def s
          elements[0]
        end

        def S1
          elements[2]
        end

        def S2
          elements[4]
        end

        def d
          elements[5]
        end

        def S3
          elements[7]
        end

        def agents
          elements[8]
        end
      end

      module AsAgreedBy2
        def value; [ d.empty? ? nil : d.date.value, agents.value ]; end
      end

      def _nt_as_agreed_by
        start_index = index
        if node_cache[:as_agreed_by].has_key?(index)
          cached = node_cache[:as_agreed_by][index]
          if cached
            node_cache[:as_agreed_by][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          if (match_len = has_terminal?('comme', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'comme\'')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_S
            s0 << r3
            if r3
              if (match_len = has_terminal?('convenu', false, index))
                r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'convenu\'')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_S
                s0 << r5
                if r5
                  i7, s7 = index, []
                  if (match_len = has_terminal?('le', false, index))
                    r8 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'le\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_s
                    s7 << r9
                    if r9
                      r10 = _nt_date
                      s7 << r10
                      if r10
                        r11 = _nt_s
                        s7 << r11
                      end
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(AsAgreedBy0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r6 = r7
                  else
                    r6 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r6
                  if r6
                    if (match_len = has_terminal?('par', false, index))
                      r12 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('\'par\'')
                      r12 = nil
                    end
                    s0 << r12
                    if r12
                      r13 = _nt_S
                      s0 << r13
                      if r13
                        r14 = _nt_agents
                        s0 << r14
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AsAgreedBy1)
          r0.extend(AsAgreedBy2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:as_agreed_by][start_index] = r0

        r0
      end

      module Date0
      end

      module Date1
        def s
          elements[0]
        end

        def d
          elements[1]
        end
      end

      module Date2
        def value; d.text_value.strip; end
      end

      def _nt_date
        start_index = index
        if node_cache[:date].has_key?(index)
          cached = node_cache[:date][index]
          if cached
            node_cache[:date][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            i4 = index
            i5 = index
            r6 = _nt_by
            if r6
              r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
              r5 = r6
            else
              if (match_len = has_terminal?(')', false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('\')\'')
                r7 = nil
              end
              if r7
                r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                r5 = r7
              else
                @index = i5
                r5 = nil
              end
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure("(any alternative)", true)
            else
              @terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s3 << r4
            if r4
              if index < input_length
                r8 = true
                @index += 1
              else
                terminal_parse_failure("any character")
                r8 = nil
              end
              s3 << r8
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(Date0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Date1)
          r0.extend(Date2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:date][start_index] = r0

        r0
      end

      module Agents0
        def s1
          elements[1]
        end

        def agent
          elements[3]
        end

        def s2
          elements[4]
        end
      end

      module Agents1
        def s1
          elements[0]
        end

        def h
          elements[1]
        end

        def s2
          elements[2]
        end

        def t
          elements[3]
        end
      end

      module Agents2
        def value; [h.text_value] + t.elements.map{|e| e.agent.text_value }; end
        def node_type; :linking; end
      end

      def _nt_agents
        start_index = index
        if node_cache[:agents].has_key?(index)
          cached = node_cache[:agents][index]
          if cached
            node_cache[:agents][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_agent
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              s4, i4 = [], index
              loop do
                i5, s5 = index, []
                if (match_len = has_terminal?(',', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\',\'')
                  r6 = nil
                end
                s5 << r6
                if r6
                  r7 = _nt_s
                  s5 << r7
                  if r7
                    i8 = index
                    r9 = _nt_context_type
                    if r9
                      @index = i8
                      r8 = nil
                    else
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s5 << r8
                    if r8
                      r10 = _nt_agent
                      s5 << r10
                      if r10
                        r11 = _nt_s
                        s5 << r11
                      end
                    end
                  end
                end
                if s5.last
                  r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                  r5.extend(Agents0)
                else
                  @index = i5
                  r5 = nil
                end
                if r5
                  s4 << r5
                else
                  break
                end
              end
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Agents1)
          r0.extend(Agents2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:agents][start_index] = r0

        r0
      end

      module Agent0
        def s
          elements[0]
        end

        def id
          elements[1]
        end
      end

      module Agent1
        def id
          elements[0]
        end

      end

      def _nt_agent
        start_index = index
        if node_cache[:agent].has_key?(index)
          cached = node_cache[:agent][index]
          if cached
            node_cache[:agent][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_id
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            r4 = _nt_s
            s3 << r4
            if r4
              r5 = _nt_id
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(Agent0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Agent1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:agent][start_index] = r0

        r0
      end

      module NegativePrefix0
        def s1
          elements[0]
        end

        def S
          elements[2]
        end

        def s2
          elements[4]
        end

        def s3
          elements[6]
        end

        def s4
          elements[8]
        end

        def s5
          elements[10]
        end

      end

      def _nt_negative_prefix
        start_index = index
        if node_cache[:negative_prefix].has_key?(index)
          cached = node_cache[:negative_prefix][index]
          if cached
            node_cache[:negative_prefix][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          if (match_len = has_terminal?('ce', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'ce\'')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_S
            s0 << r3
            if r3
              if (match_len = has_terminal?("n'est", false, index))
                r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('"n\'est"')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  if (match_len = has_terminal?('pas', false, index))
                    r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'pas\'')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_s
                    s0 << r7
                    if r7
                      if (match_len = has_terminal?('le', false, index))
                        r8 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                        @index += match_len
                      else
                        terminal_parse_failure('\'le\'')
                        r8 = nil
                      end
                      s0 << r8
                      if r8
                        r9 = _nt_s
                        s0 << r9
                        if r9
                          if (match_len = has_terminal?('cas', false, index))
                            r10 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                            @index += match_len
                          else
                            terminal_parse_failure('\'cas\'')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            r11 = _nt_s
                            s0 << r11
                            if r11
                              if (match_len = has_terminal?('que', false, index))
                                r12 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                                @index += match_len
                              else
                                terminal_parse_failure('\'que\'')
                                r12 = nil
                              end
                              s0 << r12
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NegativePrefix0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:negative_prefix][start_index] = r0

        r0
      end

      def _nt_agg_of
        start_index = index
        if node_cache[:agg_of].has_key?(index)
          cached = node_cache[:agg_of][index]
          if cached
            node_cache[:agg_of][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_de

        node_cache[:agg_of][start_index] = r0

        r0
      end

      def _nt_agg_in
        start_index = index
        if node_cache[:agg_in].has_key?(index)
          cached = node_cache[:agg_in][index]
          if cached
            node_cache[:agg_in][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_dans

        node_cache[:agg_in][start_index] = r0

        r0
      end

      module RestrictedTo0
        def s1
          elements[1]
        end

        def s2
          elements[4]
        end
      end

      def _nt_restricted_to
        start_index = index
        if node_cache[:restricted_to].has_key?(index)
          cached = node_cache[:restricted_to][index]
          if cached
            node_cache[:restricted_to][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('limité', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'limité\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?('à', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\'à\'')
              r3 = nil
            end
            s0 << r3
            if r3
              i4 = index
              r5 = _nt_alphanumeric
              if r5
                @index = i4
                r4 = nil
              else
                @index = i4
                r4 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r4
              if r4
                r6 = _nt_s
                s0 << r6
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RestrictedTo0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:restricted_to][start_index] = r0

        r0
      end

      module Any0
        def un
          elements[0]
        end

      end

      def _nt_any
        start_index = index
        if node_cache[:any].has_key?(index)
          cached = node_cache[:any][index]
          if cached
            node_cache[:any][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_un
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Any0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:any][start_index] = r0

        r0
      end

      module All0
      end

      def _nt_all
        start_index = index
        if node_cache[:all].has_key?(index)
          cached = node_cache[:all][index]
          if cached
            node_cache[:all][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('tous', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'tous\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(All0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:all][start_index] = r0

        r0
      end

      module At0
      end

      def _nt_at
        start_index = index
        if node_cache[:at].has_key?(index)
          cached = node_cache[:at][index]
          if cached
            node_cache[:at][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('a', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'a\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(At0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:at][start_index] = r0

        r0
      end

      module Both0
      end

      def _nt_both
        start_index = index
        if node_cache[:both].has_key?(index)
          cached = node_cache[:both][index]
          if cached
            node_cache[:both][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('les deux', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'les deux\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Both0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:both][start_index] = r0

        r0
      end

      module Ce0
      end

      def _nt_ce
        start_index = index
        if node_cache[:ce].has_key?(index)
          cached = node_cache[:ce][index]
          if cached
            node_cache[:ce][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        if (match_len = has_terminal?('cette', false, index))
          r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'cette\'')
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          if (match_len = has_terminal?('cet', false, index))
            r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'cet\'')
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            if (match_len = has_terminal?('ce', false, index))
              r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'ce\'')
              r4 = nil
            end
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r1 = r4
            else
              @index = i1
              r1 = nil
            end
          end
        end
        s0 << r1
        if r1
          i5 = index
          r6 = _nt_alphanumeric
          if r6
            @index = i5
            r5 = nil
          else
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Ce0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ce][start_index] = r0

        r0
      end

      module Chaque0
      end

      def _nt_chaque
        start_index = index
        if node_cache[:chaque].has_key?(index)
          cached = node_cache[:chaque][index]
          if cached
            node_cache[:chaque][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('chaque', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'chaque\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Chaque0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:chaque][start_index] = r0

        r0
      end

      module Converts0
      end

      def _nt_converts
        start_index = index
        if node_cache[:converts].has_key?(index)
          cached = node_cache[:converts][index]
          if cached
            node_cache[:converts][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('convertit', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'convertit\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Converts0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:converts][start_index] = r0

        r0
      end

      module De0
      end

      def _nt_de
        start_index = index
        if node_cache[:de].has_key?(index)
          cached = node_cache[:de][index]
          if cached
            node_cache[:de][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('de', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'de\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(De0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:de][start_index] = r0

        r0
      end

      module Dans0
      end

      def _nt_dans
        start_index = index
        if node_cache[:dans].has_key?(index)
          cached = node_cache[:dans][index]
          if cached
            node_cache[:dans][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('dans', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'dans\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Dans0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:dans][start_index] = r0

        r0
      end

      module Laquel0
      end

      def _nt_laquel
        start_index = index
        if node_cache[:laquel].has_key?(index)
          cached = node_cache[:laquel][index]
          if cached
            node_cache[:laquel][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('laquel', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'laquel\'')
          r1 = nil
        end
        s0 << r1
        if r1
          if (match_len = has_terminal?('le', false, index))
            r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'le\'')
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            i4 = index
            r5 = _nt_alphanumeric
            if r5
              @index = i4
              r4 = nil
            else
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Laquel0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:laquel][start_index] = r0

        r0
      end

      module Descending0
      end

      def _nt_descending
        start_index = index
        if node_cache[:descending].has_key?(index)
          cached = node_cache[:descending][index]
          if cached
            node_cache[:descending][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('descendant', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'descendant\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Descending0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:descending][start_index] = r0

        r0
      end

      def _nt_each
        start_index = index
        if node_cache[:each].has_key?(index)
          cached = node_cache[:each][index]
          if cached
            node_cache[:each][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_chaque

        node_cache[:each][start_index] = r0

        r0
      end

      module Either0
      end

      def _nt_either
        start_index = index
        if node_cache[:either].has_key?(index)
          cached = node_cache[:either][index]
          if cached
            node_cache[:either][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('soit', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'soit\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Either0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:either][start_index] = r0

        r0
      end

      module Entity0
      end

      def _nt_entity
        start_index = index
        if node_cache[:entity].has_key?(index)
          cached = node_cache[:entity][index]
          if cached
            node_cache[:entity][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('entité', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'entité\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Entity0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:entity][start_index] = r0

        r0
      end

      module Est0
      end

      def _nt_est
        start_index = index
        if node_cache[:est].has_key?(index)
          cached = node_cache[:est][index]
          if cached
            node_cache[:est][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('est', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'est\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Est0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:est][start_index] = r0

        r0
      end

      module Exactement0
      end

      def _nt_exactement
        start_index = index
        if node_cache[:exactement].has_key?(index)
          cached = node_cache[:exactement][index]
          if cached
            node_cache[:exactement][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('exactement', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'exactement\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Exactement0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:exactement][start_index] = r0

        r0
      end

      module Existe0
      end

      def _nt_existe
        start_index = index
        if node_cache[:existe].has_key?(index)
          cached = node_cache[:existe][index]
          if cached
            node_cache[:existe][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('existe', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'existe\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Existe0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:existe][start_index] = r0

        r0
      end

      module From0
      end

      def _nt_from
        start_index = index
        if node_cache[:from].has_key?(index)
          cached = node_cache[:from][index]
          if cached
            node_cache[:from][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('à partir de', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'à partir de\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(From0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:from][start_index] = r0

        r0
      end

      module Includes0
      end

      def _nt_includes
        start_index = index
        if node_cache[:includes].has_key?(index)
          cached = node_cache[:includes][index]
          if cached
            node_cache[:includes][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('comprend', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'comprend\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Includes0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:includes][start_index] = r0

        r0
      end

      module Matches0
      end

      def _nt_matches
        start_index = index
        if node_cache[:matches].has_key?(index)
          cached = node_cache[:matches][index]
          if cached
            node_cache[:matches][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('matches', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'matches\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Matches0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:matches][start_index] = r0

        r0
      end

      module Moins0
      end

      def _nt_moins
        start_index = index
        if node_cache[:moins].has_key?(index)
          cached = node_cache[:moins][index]
          if cached
            node_cache[:moins][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('moins', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'moins\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Moins0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:moins][start_index] = r0

        r0
      end

      module None0
      end

      def _nt_none
        start_index = index
        if node_cache[:none].has_key?(index)
          cached = node_cache[:none][index]
          if cached
            node_cache[:none][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('aucun', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'aucun\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(None0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:none][start_index] = r0

        r0
      end

      module Not0
      end

      def _nt_not
        start_index = index
        if node_cache[:not].has_key?(index)
          cached = node_cache[:not][index]
          if cached
            node_cache[:not][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('not', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'not\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Not0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:not][start_index] = r0

        r0
      end

      module Plus0
      end

      def _nt_plus
        start_index = index
        if node_cache[:plus].has_key?(index)
          cached = node_cache[:plus][index]
          if cached
            node_cache[:plus][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('plus', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'plus\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Plus0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:plus][start_index] = r0

        r0
      end

      module Some0
      end

      def _nt_some
        start_index = index
        if node_cache[:some].has_key?(index)
          cached = node_cache[:some][index]
          if cached
            node_cache[:some][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('quelques', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'quelques\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Some0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:some][start_index] = r0

        r0
      end

      module Un0
      end

      def _nt_un
        start_index = index
        if node_cache[:un].has_key?(index)
          cached = node_cache[:un][index]
          if cached
            node_cache[:un][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('un', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'un\'')
          r1 = nil
        end
        s0 << r1
        if r1
          if (match_len = has_terminal?('e', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('\'e\'')
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            i4 = index
            r5 = _nt_alphanumeric
            if r5
              @index = i4
              r4 = nil
            else
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Un0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:un][start_index] = r0

        r0
      end

      module Que0
      end

      def _nt_que
        start_index = index
        if node_cache[:que].has_key?(index)
          cached = node_cache[:que][index]
          if cached
            node_cache[:que][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('que', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'que\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Que0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:que][start_index] = r0

        r0
      end

      module AccordingTo0
      end

      def _nt_according_to
        start_index = index
        if node_cache[:according_to].has_key?(index)
          cached = node_cache[:according_to][index]
          if cached
            node_cache[:according_to][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('selon', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'selon\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AccordingTo0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:according_to][start_index] = r0

        r0
      end

      module Acyclic0
      end

      def _nt_acyclic
        start_index = index
        if node_cache[:acyclic].has_key?(index)
          cached = node_cache[:acyclic][index]
          if cached
            node_cache[:acyclic][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('acyclique', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'acyclique\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Acyclic0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:acyclic][start_index] = r0

        r0
      end

      module Alias0
      end

      def _nt_alias
        start_index = index
        if node_cache[:alias].has_key?(index)
          cached = node_cache[:alias][index]
          if cached
            node_cache[:alias][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('alias', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'alias\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Alias0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:alias][start_index] = r0

        r0
      end

      module And0
      end

      def _nt_and
        start_index = index
        if node_cache[:and].has_key?(index)
          cached = node_cache[:and][index]
          if cached
            node_cache[:and][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('et', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'et\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(And0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:and][start_index] = r0

        r0
      end

      module Antisymmetric0
      end

      def _nt_antisymmetric
        start_index = index
        if node_cache[:antisymmetric].has_key?(index)
          cached = node_cache[:antisymmetric][index]
          if cached
            node_cache[:antisymmetric][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('antisymmetric', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'antisymmetric\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Antisymmetric0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:antisymmetric][start_index] = r0

        r0
      end

      module Approximately0
      end

      def _nt_approximately
        start_index = index
        if node_cache[:approximately].has_key?(index)
          cached = node_cache[:approximately][index]
          if cached
            node_cache[:approximately][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('environ', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'environ\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Approximately0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:approximately][start_index] = r0

        r0
      end

      module As0
      end

      def _nt_as
        start_index = index
        if node_cache[:as].has_key?(index)
          cached = node_cache[:as][index]
          if cached
            node_cache[:as][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('comme', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'comme\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(As0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:as][start_index] = r0

        r0
      end

      module AsOpposedTo0
        def S1
          elements[1]
        end

        def S2
          elements[3]
        end

      end

      def _nt_as_opposed_to
        start_index = index
        if node_cache[:as_opposed_to].has_key?(index)
          cached = node_cache[:as_opposed_to][index]
          if cached
            node_cache[:as_opposed_to][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('au', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'au\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            if (match_len = has_terminal?('lieu', false, index))
              r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'lieu\'')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                if (match_len = has_terminal?('de', false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'de\'')
                  r5 = nil
                end
                s0 << r5
                if r5
                  i6 = index
                  r7 = _nt_alphanumeric
                  if r7
                    @index = i6
                    r6 = nil
                  else
                    @index = i6
                    r6 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AsOpposedTo0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:as_opposed_to][start_index] = r0

        r0
      end

      module Asymmetric0
      end

      def _nt_asymmetric
        start_index = index
        if node_cache[:asymmetric].has_key?(index)
          cached = node_cache[:asymmetric][index]
          if cached
            node_cache[:asymmetric][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('asymétrique', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'asymétrique\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Asymmetric0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:asymmetric][start_index] = r0

        r0
      end

      module Au0
      end

      def _nt_au
        start_index = index
        if node_cache[:au].has_key?(index)
          cached = node_cache[:au][index]
          if cached
            node_cache[:au][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('au', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'au\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Au0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:au][start_index] = r0

        r0
      end

      module Because0
        def s
          elements[1]
        end

      end

      module Because1
      end

      def _nt_because
        start_index = index
        if node_cache[:because].has_key?(index)
          cached = node_cache[:because][index]
          if cached
            node_cache[:because][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        i2, s2 = index, []
        if (match_len = has_terminal?('parce', false, index))
          r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'parce\'')
          r3 = nil
        end
        s2 << r3
        if r3
          r4 = _nt_s
          s2 << r4
          if r4
            if (match_len = has_terminal?('que', false, index))
              r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'que\'')
              r5 = nil
            end
            s2 << r5
          end
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(Because0)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          if (match_len = has_terminal?('car', false, index))
            r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'car\'')
            r6 = nil
          end
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r1 = r6
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          i7 = index
          r8 = _nt_alphanumeric
          if r8
            @index = i7
            r7 = nil
          else
            @index = i7
            r7 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r7
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Because1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:because][start_index] = r0

        r0
      end

      module But0
      end

      def _nt_but
        start_index = index
        if node_cache[:but].has_key?(index)
          cached = node_cache[:but][index]
          if cached
            node_cache[:but][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('mais', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'mais\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(But0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:but][start_index] = r0

        r0
      end

      module By0
      end

      def _nt_by
        start_index = index
        if node_cache[:by].has_key?(index)
          cached = node_cache[:by][index]
          if cached
            node_cache[:by][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('par', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'par\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(By0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:by][start_index] = r0

        r0
      end

      module Definitely0
      end

      def _nt_definitely
        start_index = index
        if node_cache[:definitely].has_key?(index)
          cached = node_cache[:definitely][index]
          if cached
            node_cache[:definitely][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('définitivement', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'définitivement\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Definitely0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:definitely][start_index] = r0

        r0
      end

      module Entre0
      end

      def _nt_entre
        start_index = index
        if node_cache[:entre].has_key?(index)
          cached = node_cache[:entre][index]
          if cached
            node_cache[:entre][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('entre', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'entre\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Entre0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:entre][start_index] = r0

        r0
      end

      module Ephemera0
      end

      def _nt_ephemera
        start_index = index
        if node_cache[:ephemera].has_key?(index)
          cached = node_cache[:ephemera][index]
          if cached
            node_cache[:ephemera][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('éphémère', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'éphémère\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Ephemera0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ephemera][start_index] = r0

        r0
      end

      module Existe0
      end

      def _nt_existe
        start_index = index
        if node_cache[:existe].has_key?(index)
          cached = node_cache[:existe][index]
          if cached
            node_cache[:existe][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('existe', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'existe\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Existe0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:existe][start_index] = r0

        r0
      end

      module False0
      end

      def _nt_false
        start_index = index
        if node_cache[:false].has_key?(index)
          cached = node_cache[:false][index]
          if cached
            node_cache[:false][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('faux', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'faux\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(False0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:false][start_index] = r0

        r0
      end

      module Feminine0
      end

      def _nt_feminine
        start_index = index
        if node_cache[:feminine].has_key?(index)
          cached = node_cache[:feminine][index]
          if cached
            node_cache[:feminine][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('féminin', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'féminin\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Feminine0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:feminine][start_index] = r0

        r0
      end

      module Identified0
      end

      def _nt_identified
        start_index = index
        if node_cache[:identified].has_key?(index)
          cached = node_cache[:identified][index]
          if cached
            node_cache[:identified][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('identifié', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'identifié\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Identified0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:identified][start_index] = r0

        r0
      end

      module If0
      end

      def _nt_if
        start_index = index
        if node_cache[:if].has_key?(index)
          cached = node_cache[:if][index]
          if cached
            node_cache[:if][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('si', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'si\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(If0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:if][start_index] = r0

        r0
      end

      module Import0
      end

      def _nt_import
        start_index = index
        if node_cache[:import].has_key?(index)
          cached = node_cache[:import][index]
          if cached
            node_cache[:import][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('import', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'import\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Import0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:import][start_index] = r0

        r0
      end

      module Independent0
      end

      def _nt_independent
        start_index = index
        if node_cache[:independent].has_key?(index)
          cached = node_cache[:independent][index]
          if cached
            node_cache[:independent][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('indépendant', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'indépendant\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Independent0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:independent][start_index] = r0

        r0
      end

      module Stronglyintransitive0
      end

      def _nt_stronglyintransitive
        start_index = index
        if node_cache[:stronglyintransitive].has_key?(index)
          cached = node_cache[:stronglyintransitive][index]
          if cached
            node_cache[:stronglyintransitive][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('stronglyintransitif', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'stronglyintransitif\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Stronglyintransitive0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:stronglyintransitive][start_index] = r0

        r0
      end

      module Intransitive0
      end

      def _nt_intransitive
        start_index = index
        if node_cache[:intransitive].has_key?(index)
          cached = node_cache[:intransitive][index]
          if cached
            node_cache[:intransitive][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('intransitif', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'intransitif\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Intransitive0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:intransitive][start_index] = r0

        r0
      end

      module Irreflexive0
      end

      def _nt_irreflexive
        start_index = index
        if node_cache[:irreflexive].has_key?(index)
          cached = node_cache[:irreflexive][index]
          if cached
            node_cache[:irreflexive][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('irréflexive', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'irréflexive\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Irreflexive0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:irreflexive][start_index] = r0

        r0
      end

      def _nt_is
        start_index = index
        if node_cache[:is].has_key?(index)
          cached = node_cache[:is][index]
          if cached
            node_cache[:is][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_est

        node_cache[:is][start_index] = r0

        r0
      end

      module Its0
      end

      def _nt_its
        start_index = index
        if node_cache[:its].has_key?(index)
          cached = node_cache[:its][index]
          if cached
            node_cache[:its][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        if (match_len = has_terminal?('sa', false, index))
          r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'sa\'')
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          if (match_len = has_terminal?('son', false, index))
            r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'son\'')
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          i4 = index
          r5 = _nt_alphanumeric
          if r5
            @index = i4
            r4 = nil
          else
            @index = i4
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Its0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:its][start_index] = r0

        r0
      end

      module Masculine0
      end

      def _nt_masculine
        start_index = index
        if node_cache[:masculine].has_key?(index)
          cached = node_cache[:masculine][index]
          if cached
            node_cache[:masculine][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('masculin', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'masculin\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Masculine0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:masculine][start_index] = r0

        r0
      end

      module Maybe0
      end

      def _nt_maybe
        start_index = index
        if node_cache[:maybe].has_key?(index)
          cached = node_cache[:maybe][index]
          if cached
            node_cache[:maybe][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('peut-être', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'peut-être\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Maybe0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:maybe][start_index] = r0

        r0
      end

      module Model0
      end

      def _nt_model
        start_index = index
        if node_cache[:model].has_key?(index)
          cached = node_cache[:model][index]
          if cached
            node_cache[:model][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('model', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'model\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Model0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:model][start_index] = r0

        r0
      end

      module Only0
      end

      def _nt_only
        start_index = index
        if node_cache[:only].has_key?(index)
          cached = node_cache[:only][index]
          if cached
            node_cache[:only][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('que', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'que\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Only0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:only][start_index] = r0

        r0
      end

      module Or0
      end

      def _nt_or
        start_index = index
        if node_cache[:or].has_key?(index)
          cached = node_cache[:or][index]
          if cached
            node_cache[:or][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ou', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ou\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Or0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:or][start_index] = r0

        r0
      end

      module OrderingPrefix0
        def by
          elements[0]
        end

        def s1
          elements[1]
        end

        def s2
          elements[3]
        end
      end

      def _nt_ordering_prefix
        start_index = index
        if node_cache[:ordering_prefix].has_key?(index)
          cached = node_cache[:ordering_prefix][index]
          if cached
            node_cache[:ordering_prefix][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_by
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            i4 = index
            r5 = _nt_ascending
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r4 = r5
            else
              r6 = _nt_descending
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r4 = r6
              else
                @index = i4
                r4 = nil
              end
            end
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
            if r3
              r7 = _nt_s
              s0 << r7
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(OrderingPrefix0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ordering_prefix][start_index] = r0

        r0
      end

      module Otherwise0
      end

      def _nt_otherwise
        start_index = index
        if node_cache[:otherwise].has_key?(index)
          cached = node_cache[:otherwise][index]
          if cached
            node_cache[:otherwise][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('sinon', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'sinon\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Otherwise0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:otherwise][start_index] = r0

        r0
      end

      module Partitioned0
      end

      def _nt_partitioned
        start_index = index
        if node_cache[:partitioned].has_key?(index)
          cached = node_cache[:partitioned][index]
          if cached
            node_cache[:partitioned][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('partitionné', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'partitionné\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Partitioned0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:partitioned][start_index] = r0

        r0
      end

      module Personal0
      end

      def _nt_personal
        start_index = index
        if node_cache[:personal].has_key?(index)
          cached = node_cache[:personal][index]
          if cached
            node_cache[:personal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('personelle', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'personelle\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Personal0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:personal][start_index] = r0

        r0
      end

      def _nt_radix_point
        start_index = index
        if node_cache[:radix_point].has_key?(index)
          cached = node_cache[:radix_point][index]
          if cached
            node_cache[:radix_point][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?(',', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\',\'')
          r0 = nil
        end

        node_cache[:radix_point][start_index] = r0

        r0
      end

      module Reflexive0
      end

      def _nt_reflexive
        start_index = index
        if node_cache[:reflexive].has_key?(index)
          cached = node_cache[:reflexive][index]
          if cached
            node_cache[:reflexive][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('réflexive', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'réflexive\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Reflexive0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:reflexive][start_index] = r0

        r0
      end

      module Returning0
      end

      def _nt_returning
        start_index = index
        if node_cache[:returning].has_key?(index)
          cached = node_cache[:returning][index]
          if cached
            node_cache[:returning][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('retour', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'retour\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Returning0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:returning][start_index] = r0

        r0
      end

      module Separate0
      end

      def _nt_separate
        start_index = index
        if node_cache[:separate].has_key?(index)
          cached = node_cache[:separate][index]
          if cached
            node_cache[:separate][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('distincte', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'distincte\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Separate0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:separate][start_index] = r0

        r0
      end

      module Si0
      end

      def _nt_si
        start_index = index
        if node_cache[:si].has_key?(index)
          cached = node_cache[:si][index]
          if cached
            node_cache[:si][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('si', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'si\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Si0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:si][start_index] = r0

        r0
      end

      module SoThat0
        def s
          elements[1]
        end

      end

      def _nt_so_that
        start_index = index
        if node_cache[:so_that].has_key?(index)
          cached = node_cache[:so_that][index]
          if cached
            node_cache[:so_that][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('pour', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'pour\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?('que', false, index))
              r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'que\'')
              r3 = nil
            end
            s0 << r3
            if r3
              i4 = index
              r5 = _nt_alphanumeric
              if r5
                @index = i4
                r4 = nil
              else
                @index = i4
                r4 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SoThat0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:so_that][start_index] = r0

        r0
      end

      module Soit0
      end

      def _nt_soit
        start_index = index
        if node_cache[:soit].has_key?(index)
          cached = node_cache[:soit][index]
          if cached
            node_cache[:soit][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('soit', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'soit\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Soit0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:soit][start_index] = r0

        r0
      end

      module Static0
      end

      def _nt_static
        start_index = index
        if node_cache[:static].has_key?(index)
          cached = node_cache[:static][index]
          if cached
            node_cache[:static][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('statique', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'statique\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Static0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:static][start_index] = r0

        r0
      end

      module Symmetric0
      end

      def _nt_symmetric
        start_index = index
        if node_cache[:symmetric].has_key?(index)
          cached = node_cache[:symmetric][index]
          if cached
            node_cache[:symmetric][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('symétrique', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'symétrique\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Symmetric0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:symmetric][start_index] = r0

        r0
      end

      def _nt_that
        start_index = index
        if node_cache[:that].has_key?(index)
          cached = node_cache[:that][index]
          if cached
            node_cache[:that][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_que

        node_cache[:that][start_index] = r0

        r0
      end

      module Then0
      end

      def _nt_then
        start_index = index
        if node_cache[:then].has_key?(index)
          cached = node_cache[:then][index]
          if cached
            node_cache[:then][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('puis', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'puis\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Then0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:then][start_index] = r0

        r0
      end

      module To0
      end

      def _nt_to
        start_index = index
        if node_cache[:to].has_key?(index)
          cached = node_cache[:to][index]
          if cached
            node_cache[:to][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('à', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'à\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(To0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:to][start_index] = r0

        r0
      end

      module ToAvoid0
        def s1
          elements[1]
        end

        def s2
          elements[3]
        end

      end

      module ToAvoid1
        def s1
          elements[1]
        end

        def s2
          elements[3]
        end

      end

      module ToAvoid2
      end

      def _nt_to_avoid
        start_index = index
        if node_cache[:to_avoid].has_key?(index)
          cached = node_cache[:to_avoid][index]
          if cached
            node_cache[:to_avoid][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        i2, s2 = index, []
        if (match_len = has_terminal?('pour', false, index))
          r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'pour\'')
          r3 = nil
        end
        s2 << r3
        if r3
          r4 = _nt_s
          s2 << r4
          if r4
            if (match_len = has_terminal?('empecher', false, index))
              r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'empecher\'')
              r5 = nil
            end
            s2 << r5
            if r5
              r6 = _nt_s
              s2 << r6
              if r6
                if (match_len = has_terminal?('de', false, index))
                  r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'de\'')
                  r7 = nil
                end
                s2 << r7
              end
            end
          end
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(ToAvoid0)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          i8, s8 = index, []
          if (match_len = has_terminal?('pour', false, index))
            r9 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'pour\'')
            r9 = nil
          end
          s8 << r9
          if r9
            r10 = _nt_s
            s8 << r10
            if r10
              if (match_len = has_terminal?('ne', false, index))
                r11 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'ne\'')
                r11 = nil
              end
              s8 << r11
              if r11
                r12 = _nt_s
                s8 << r12
                if r12
                  if (match_len = has_terminal?('pas', false, index))
                    r13 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'pas\'')
                    r13 = nil
                  end
                  s8 << r13
                end
              end
            end
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(ToAvoid1)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r1 = r8
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          i14 = index
          r15 = _nt_alphanumeric
          if r15
            @index = i14
            r14 = nil
          else
            @index = i14
            r14 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r14
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToAvoid2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:to_avoid][start_index] = r0

        r0
      end

      module Topic0
      end

      def _nt_topic
        start_index = index
        if node_cache[:topic].has_key?(index)
          cached = node_cache[:topic][index]
          if cached
            node_cache[:topic][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('sujet', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'sujet\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Topic0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:topic][start_index] = r0

        r0
      end

      module Transform0
      end

      def _nt_transform
        start_index = index
        if node_cache[:transform].has_key?(index)
          cached = node_cache[:transform][index]
          if cached
            node_cache[:transform][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('transform', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'transform\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Transform0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:transform][start_index] = r0

        r0
      end

      module Transient0
      end

      def _nt_transient
        start_index = index
        if node_cache[:transient].has_key?(index)
          cached = node_cache[:transient][index]
          if cached
            node_cache[:transient][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('transitoires', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'transitoires\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Transient0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:transient][start_index] = r0

        r0
      end

      module Transitive0
      end

      def _nt_transitive
        start_index = index
        if node_cache[:transitive].has_key?(index)
          cached = node_cache[:transitive][index]
          if cached
            node_cache[:transitive][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('transitif', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'transitif\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Transitive0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:transitive][start_index] = r0

        r0
      end

      module True0
      end

      def _nt_true
        start_index = index
        if node_cache[:true].has_key?(index)
          cached = node_cache[:true][index]
          if cached
            node_cache[:true][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('vrai', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'vrai\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(True0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:true][start_index] = r0

        r0
      end

      module Vocabulary0
      end

      def _nt_vocabulary
        start_index = index
        if node_cache[:vocabulary].has_key?(index)
          cached = node_cache[:vocabulary][index]
          if cached
            node_cache[:vocabulary][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('vocabulaire', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'vocabulaire\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Vocabulary0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:vocabulary][start_index] = r0

        r0
      end

      module Where0
      end

      def _nt_where
        start_index = index
        if node_cache[:where].has_key?(index)
          cached = node_cache[:where][index]
          if cached
            node_cache[:where][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('où', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'où\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Where0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:where][start_index] = r0

        r0
      end

      module Who0
      end

      def _nt_who
        start_index = index
        if node_cache[:who].has_key?(index)
          cached = node_cache[:who][index]
          if cached
            node_cache[:who][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('qui', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'qui\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Who0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:who][start_index] = r0

        r0
      end

    end

    class FrenchParser < Treetop::Runtime::CompiledParser
      include French
    end

  end
end
# vi:encoding=utf-8
