#
# Autogenerated from a Treetop grammar. Edits may be lost.


#       ActiveFacts CQL Parser.
#       Parse rules the English syntax of CQL.
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
module ActiveFacts
  module CQL
    module English
      include Treetop::Runtime

      def root
        @root ||= :written_as
      end

      module WrittenAs0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def S
          elements[4]
        end

        def as
          elements[5]
        end

        def s3
          elements[6]
        end
      end

      def _nt_written_as
        start_index = index
        if node_cache[:written_as].has_key?(index)
          cached = node_cache[:written_as][index]
          if cached
            node_cache[:written_as][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          if (match_len = has_terminal?('is', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'is\'')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              if (match_len = has_terminal?('written', false, index))
                r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'written\'')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_S
                s0 << r5
                if r5
                  r6 = _nt_as
                  s0 << r6
                  if r6
                    r7 = _nt_s
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(WrittenAs0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:written_as][start_index] = r0

        r0
      end

      module AutoAssignment0
        def S
          elements[1]
        end

        def at
          elements[2]
        end

        def s1
          elements[3]
        end

        def time
          elements[4]
        end

        def s2
          elements[6]
        end
      end

      module AutoAssignment1
        def auto_assigned_at
          time.text_value
        end
      end

      def _nt_auto_assignment
        start_index = index
        if node_cache[:auto_assignment].has_key?(index)
          cached = node_cache[:auto_assignment][index]
          if cached
            node_cache[:auto_assignment][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('auto-assigned', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'auto-assigned\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_at
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?('assert', false, index))
                  r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'assert\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  if (match_len = has_terminal?('commit', false, index))
                    r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'commit\'')
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  i8 = index
                  r9 = _nt_alphanumeric
                  if r9
                    @index = i8
                    r8 = nil
                  else
                    @index = i8
                    r8 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r8
                  if r8
                    r10 = _nt_s
                    s0 << r10
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AutoAssignment0)
          r0.extend(AutoAssignment1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:auto_assignment][start_index] = r0

        r0
      end

      module IdentifiedBy0
        def identified
          elements[0]
        end

        def s1
          elements[1]
        end

        def by
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      def _nt_identified_by
        start_index = index
        if node_cache[:identified_by].has_key?(index)
          cached = node_cache[:identified_by][index]
          if cached
            node_cache[:identified_by][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_identified
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_by
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IdentifiedBy0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:identified_by][start_index] = r0

        r0
      end

      module BasetypeExpression0
        def independent
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module BasetypeExpression1
        def is
          elements[0]
        end

        def s
          elements[1]
        end

        def i
          elements[2]
        end

        def identification
          elements[3]
        end
      end

      def _nt_basetype_expression
        start_index = index
        if node_cache[:basetype_expression].has_key?(index)
          cached = node_cache[:basetype_expression][index]
          if cached
            node_cache[:basetype_expression][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_is
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            i4, s4 = index, []
            r5 = _nt_independent
            s4 << r5
            if r5
              r6 = _nt_s
              s4 << r6
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(BasetypeExpression0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
            if r3
              r7 = _nt_identification
              s0 << r7
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(BasetypeExpression1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:basetype_expression][start_index] = r0

        r0
      end

      module SubtypePrefix0
        def s1
          elements[1]
        end

        def s2
          elements[3]
        end

        def s3
          elements[5]
        end

        def S
          elements[7]
        end
      end

      def _nt_subtype_prefix
        start_index = index
        if node_cache[:subtype_prefix].has_key?(index)
          cached = node_cache[:subtype_prefix][index]
          if cached
            node_cache[:subtype_prefix][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('is', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'is\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?('a', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\'a\'')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                if (match_len = has_terminal?('kind', false, index))
                  r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'kind\'')
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  if (match_len = has_terminal?('subtype', false, index))
                    r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'subtype\'')
                    r7 = nil
                  end
                  if r7
                    r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                    r5 = r7
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r8 = _nt_s
                  s0 << r8
                  if r8
                    if (match_len = has_terminal?('of', false, index))
                      r9 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('\'of\'')
                      r9 = nil
                    end
                    s0 << r9
                    if r9
                      r10 = _nt_S
                      s0 << r10
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SubtypePrefix0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:subtype_prefix][start_index] = r0

        r0
      end

      module SubtypeExpression0
        def independent
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module SubtypeExpression1
        def subtype_prefix
          elements[0]
        end

        def i
          elements[1]
        end

        def supertype_list
          elements[2]
        end

        def ident
          elements[3]
        end
      end

      def _nt_subtype_expression
        start_index = index
        if node_cache[:subtype_expression].has_key?(index)
          cached = node_cache[:subtype_expression][index]
          if cached
            node_cache[:subtype_expression][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_subtype_prefix
        s0 << r1
        if r1
          i3, s3 = index, []
          r4 = _nt_independent
          s3 << r4
          if r4
            r5 = _nt_s
            s3 << r5
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(SubtypeExpression0)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r6 = _nt_supertype_list
            s0 << r6
            if r6
              r8 = _nt_identification
              if r8
                r7 = r8
              else
                r7 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r7
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SubtypeExpression1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:subtype_expression][start_index] = r0

        r0
      end

      module IsWhere0
        def independent
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module IsWhere1
        def is
          elements[0]
        end

        def s
          elements[1]
        end

        def i
          elements[2]
        end

        def where
          elements[3]
        end
      end

      module IsWhere2
        def independent; !i.empty?; end
      end

      def _nt_is_where
        start_index = index
        if node_cache[:is_where].has_key?(index)
          cached = node_cache[:is_where][index]
          if cached
            node_cache[:is_where][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_is
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            i4, s4 = index, []
            r5 = _nt_independent
            s4 << r5
            if r5
              r6 = _nt_s
              s4 << r6
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(IsWhere0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
            if r3
              r7 = _nt_where
              s0 << r7
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IsWhere1)
          r0.extend(IsWhere2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:is_where][start_index] = r0

        r0
      end

      module InWhich0
        def in
          elements[0]
        end

        def s
          elements[1]
        end

        def which
          elements[2]
        end
      end

      def _nt_in_which
        start_index = index
        if node_cache[:in_which].has_key?(index)
          cached = node_cache[:in_which][index]
          if cached
            node_cache[:in_which][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_where
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i2, s2 = index, []
          r3 = _nt_in
          s2 << r3
          if r3
            r4 = _nt_s
            s2 << r4
            if r4
              r5 = _nt_which
              s2 << r5
            end
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(InWhich0)
          else
            @index = i2
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:in_which][start_index] = r0

        r0
      end

      module Conversion0
        def approximately
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Conversion1
        def converts
          elements[0]
        end

        def s1
          elements[1]
        end

        def a
          elements[2]
        end

        def to
          elements[3]
        end

        def s2
          elements[4]
        end
      end

      module Conversion2
        def approximate?
          !a.empty?
        end
      end

      def _nt_conversion
        start_index = index
        if node_cache[:conversion].has_key?(index)
          cached = node_cache[:conversion][index]
          if cached
            node_cache[:conversion][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_converts
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            i4, s4 = index, []
            r5 = _nt_approximately
            s4 << r5
            if r5
              r6 = _nt_s
              s4 << r6
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(Conversion0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
            if r3
              r7 = _nt_to
              s0 << r7
              if r7
                r8 = _nt_s
                s0 << r8
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Conversion1)
          r0.extend(Conversion2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:conversion][start_index] = r0

        r0
      end

      module EachOccursInClauses0
        def S
          elements[1]
        end
      end

      module EachOccursInClauses1
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def role_list
          elements[4]
        end

        def s3
          elements[5]
        end

        def occurs
          elements[6]
        end

        def s4
          elements[7]
        end

        def quantifier
          elements[8]
        end

        def s5
          elements[9]
        end

        def s6
          elements[12]
        end

        def enforcement
          elements[13]
        end

        def s7
          elements[15]
        end

        def clauses_list
          elements[16]
        end

        def s8
          elements[17]
        end

        def c
          elements[18]
        end

      end

      module EachOccursInClauses2
        def role_list_ast
          role_list.ast
        end
        def quantifier_ast
          quantifier.ast
        end
        def clauses_ast
          clauses_list.ast
        end
      end

      def _nt_each_occurs_in_clauses
        start_index = index
        if node_cache[:each_occurs_in_clauses].has_key?(index)
          cached = node_cache[:each_occurs_in_clauses][index]
          if cached
            node_cache[:each_occurs_in_clauses][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          if (match_len = has_terminal?('each', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'each\'')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              i5, s5 = index, []
              if (match_len = has_terminal?('combination', false, index))
                r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'combination\'')
                r6 = nil
              end
              s5 << r6
              if r6
                r7 = _nt_S
                s5 << r7
              end
              if s5.last
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                r5.extend(EachOccursInClauses0)
              else
                @index = i5
                r5 = nil
              end
              if r5
                r4 = r5
              else
                r4 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r4
              if r4
                r8 = _nt_role_list
                s0 << r8
                if r8
                  r9 = _nt_s
                  s0 << r9
                  if r9
                    r10 = _nt_occurs
                    s0 << r10
                    if r10
                      r11 = _nt_s
                      s0 << r11
                      if r11
                        r12 = _nt_quantifier
                        s0 << r12
                        if r12
                          r13 = _nt_s
                          s0 << r13
                          if r13
                            if (match_len = has_terminal?('time', false, index))
                              r14 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                              @index += match_len
                            else
                              terminal_parse_failure('\'time\'')
                              r14 = nil
                            end
                            s0 << r14
                            if r14
                              if (match_len = has_terminal?('s', false, index))
                                r16 = true
                                @index += match_len
                              else
                                terminal_parse_failure('\'s\'')
                                r16 = nil
                              end
                              if r16
                                r15 = r16
                              else
                                r15 = instantiate_node(SyntaxNode,input, index...index)
                              end
                              s0 << r15
                              if r15
                                r17 = _nt_s
                                s0 << r17
                                if r17
                                  r18 = _nt_enforcement
                                  s0 << r18
                                  if r18
                                    if (match_len = has_terminal?('in', false, index))
                                      r19 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                                      @index += match_len
                                    else
                                      terminal_parse_failure('\'in\'')
                                      r19 = nil
                                    end
                                    s0 << r19
                                    if r19
                                      r20 = _nt_s
                                      s0 << r20
                                      if r20
                                        r21 = _nt_clauses_list
                                        s0 << r21
                                        if r21
                                          r22 = _nt_s
                                          s0 << r22
                                          if r22
                                            r24 = _nt_context_note
                                            if r24
                                              r23 = r24
                                            else
                                              r23 = instantiate_node(SyntaxNode,input, index...index)
                                            end
                                            s0 << r23
                                            if r23
                                              if (match_len = has_terminal?(';', false, index))
                                                r25 = true
                                                @index += match_len
                                              else
                                                terminal_parse_failure('\';\'')
                                                r25 = nil
                                              end
                                              s0 << r25
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(EachOccursInClauses1)
          r0.extend(EachOccursInClauses2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:each_occurs_in_clauses][start_index] = r0

        r0
      end

      module EitherOr0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def r1
          elements[3]
        end

        def s3
          elements[4]
        end

        def or
          elements[5]
        end

        def s4
          elements[6]
        end

        def r2
          elements[7]
        end

        def c
          elements[8]
        end

        def enforcement
          elements[9]
        end

      end

      module EitherOr1
        def role_list_ast
          nil
        end
        def quantifier_ast
          Compiler::Quantifier.new(1, nil)
        end
        def clauses_ast
          [r1.ast, r2.ast]
        end
      end

      def _nt_either_or
        start_index = index
        if node_cache[:either_or].has_key?(index)
          cached = node_cache[:either_or][index]
          if cached
            node_cache[:either_or][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r3 = _nt_either
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r4 = _nt_s
            s0 << r4
            if r4
              r5 = _nt_clauses
              s0 << r5
              if r5
                r6 = _nt_s
                s0 << r6
                if r6
                  r7 = _nt_or
                  s0 << r7
                  if r7
                    r8 = _nt_s
                    s0 << r8
                    if r8
                      r9 = _nt_clauses
                      s0 << r9
                      if r9
                        r11 = _nt_context_note
                        if r11
                          r10 = r11
                        else
                          r10 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s0 << r10
                        if r10
                          r12 = _nt_enforcement
                          s0 << r12
                          if r12
                            if (match_len = has_terminal?(';', false, index))
                              r13 = true
                              @index += match_len
                            else
                              terminal_parse_failure('\';\'')
                              r13 = nil
                            end
                            s0 << r13
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(EitherOr0)
          r0.extend(EitherOr1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:either_or][start_index] = r0

        r0
      end

      module ForEachHowMany0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def s3
          elements[4]
        end

        def role_list
          elements[5]
        end

        def s4
          elements[6]
        end

        def quantifier
          elements[7]
        end

        def s5
          elements[8]
        end

        def s6
          elements[10]
        end

        def s7
          elements[12]
        end

        def s8
          elements[14]
        end

        def enforcement
          elements[15]
        end

        def s9
          elements[17]
        end

        def clauses_list
          elements[18]
        end

        def s10
          elements[19]
        end

        def c
          elements[20]
        end

      end

      module ForEachHowMany1
        def role_list_ast
          role_list.ast
        end
        def quantifier_ast
          quantifier.ast
        end
        def clauses_ast
          clauses_list.ast
        end
      end

      def _nt_for_each_how_many
        start_index = index
        if node_cache[:for_each_how_many].has_key?(index)
          cached = node_cache[:for_each_how_many][index]
          if cached
            node_cache[:for_each_how_many][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          if (match_len = has_terminal?('for', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'for\'')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              if (match_len = has_terminal?('each', false, index))
                r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'each\'')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  r6 = _nt_role_list
                  s0 << r6
                  if r6
                    r7 = _nt_s
                    s0 << r7
                    if r7
                      r8 = _nt_quantifier
                      s0 << r8
                      if r8
                        r9 = _nt_s
                        s0 << r9
                        if r9
                          if (match_len = has_terminal?('of', false, index))
                            r10 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                            @index += match_len
                          else
                            terminal_parse_failure('\'of\'')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            r11 = _nt_s
                            s0 << r11
                            if r11
                              if (match_len = has_terminal?('these', false, index))
                                r12 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                                @index += match_len
                              else
                                terminal_parse_failure('\'these\'')
                                r12 = nil
                              end
                              s0 << r12
                              if r12
                                r13 = _nt_s
                                s0 << r13
                                if r13
                                  if (match_len = has_terminal?('holds', false, index))
                                    r14 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                                    @index += match_len
                                  else
                                    terminal_parse_failure('\'holds\'')
                                    r14 = nil
                                  end
                                  s0 << r14
                                  if r14
                                    r15 = _nt_s
                                    s0 << r15
                                    if r15
                                      r16 = _nt_enforcement
                                      s0 << r16
                                      if r16
                                        if (match_len = has_terminal?(':', false, index))
                                          r17 = true
                                          @index += match_len
                                        else
                                          terminal_parse_failure('\':\'')
                                          r17 = nil
                                        end
                                        s0 << r17
                                        if r17
                                          r18 = _nt_s
                                          s0 << r18
                                          if r18
                                            r19 = _nt_clauses_list
                                            s0 << r19
                                            if r19
                                              r20 = _nt_s
                                              s0 << r20
                                              if r20
                                                r22 = _nt_context_note
                                                if r22
                                                  r21 = r22
                                                else
                                                  r21 = instantiate_node(SyntaxNode,input, index...index)
                                                end
                                                s0 << r21
                                                if r21
                                                  if (match_len = has_terminal?(';', false, index))
                                                    r23 = true
                                                    @index += match_len
                                                  else
                                                    terminal_parse_failure('\';\'')
                                                    r23 = nil
                                                  end
                                                  s0 << r23
                                                end
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ForEachHowMany0)
          r0.extend(ForEachHowMany1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:for_each_how_many][start_index] = r0

        r0
      end

      module EitherOrNotBoth0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def r1
          elements[3]
        end

        def s3
          elements[4]
        end

        def or
          elements[5]
        end

        def s4
          elements[6]
        end

        def r2
          elements[7]
        end

        def but
          elements[8]
        end

        def s5
          elements[9]
        end

        def not
          elements[10]
        end

        def s6
          elements[11]
        end

        def both
          elements[12]
        end

        def s7
          elements[13]
        end

        def c
          elements[14]
        end

        def enforcement
          elements[15]
        end

      end

      module EitherOrNotBoth1
        def role_list_ast
          nil
        end
        def quantifier_ast
          Compiler::Quantifier.new(1, 1)
        end
        def clauses_ast
          [r1.ast, r2.ast]
        end
      end

      def _nt_either_or_not_both
        start_index = index
        if node_cache[:either_or_not_both].has_key?(index)
          cached = node_cache[:either_or_not_both][index]
          if cached
            node_cache[:either_or_not_both][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r3 = _nt_either
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r4 = _nt_s
            s0 << r4
            if r4
              r5 = _nt_clauses
              s0 << r5
              if r5
                r6 = _nt_s
                s0 << r6
                if r6
                  r7 = _nt_or
                  s0 << r7
                  if r7
                    r8 = _nt_s
                    s0 << r8
                    if r8
                      r9 = _nt_clauses
                      s0 << r9
                      if r9
                        r10 = _nt_but
                        s0 << r10
                        if r10
                          r11 = _nt_s
                          s0 << r11
                          if r11
                            r12 = _nt_not
                            s0 << r12
                            if r12
                              r13 = _nt_s
                              s0 << r13
                              if r13
                                r14 = _nt_both
                                s0 << r14
                                if r14
                                  r15 = _nt_s
                                  s0 << r15
                                  if r15
                                    r17 = _nt_context_note
                                    if r17
                                      r16 = r17
                                    else
                                      r16 = instantiate_node(SyntaxNode,input, index...index)
                                    end
                                    s0 << r16
                                    if r16
                                      r18 = _nt_enforcement
                                      s0 << r18
                                      if r18
                                        if (match_len = has_terminal?(';', false, index))
                                          r19 = true
                                          @index += match_len
                                        else
                                          terminal_parse_failure('\';\'')
                                          r19 = nil
                                        end
                                        s0 << r19
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(EitherOrNotBoth0)
          r0.extend(EitherOrNotBoth1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:either_or_not_both][start_index] = r0

        r0
      end

      module AOnlyIfB0
        def s1
          elements[0]
        end

        def clauses
          elements[1]
        end

        def s2
          elements[2]
        end

        def only
          elements[3]
        end

        def s3
          elements[4]
        end

        def if
          elements[5]
        end

        def s4
          elements[6]
        end

        def r2
          elements[7]
        end

        def s5
          elements[8]
        end

        def c
          elements[9]
        end

        def enforcement
          elements[10]
        end

      end

      def _nt_a_only_if_b
        start_index = index
        if node_cache[:a_only_if_b].has_key?(index)
          cached = node_cache[:a_only_if_b][index]
          if cached
            node_cache[:a_only_if_b][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_query_clauses
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              r4 = _nt_only
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  r6 = _nt_if
                  s0 << r6
                  if r6
                    r7 = _nt_s
                    s0 << r7
                    if r7
                      r8 = _nt_query_clauses
                      s0 << r8
                      if r8
                        r9 = _nt_s
                        s0 << r9
                        if r9
                          r11 = _nt_context_note
                          if r11
                            r10 = r11
                          else
                            r10 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r10
                          if r10
                            r12 = _nt_enforcement
                            s0 << r12
                            if r12
                              if (match_len = has_terminal?(';', false, index))
                                r13 = true
                                @index += match_len
                              else
                                terminal_parse_failure('\';\'')
                                r13 = nil
                              end
                              s0 << r13
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AOnlyIfB0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:a_only_if_b][start_index] = r0

        r0
      end

      module OnlyIf0
        def only
          elements[0]
        end

        def s1
          elements[1]
        end

        def if
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      def _nt_only_if
        start_index = index
        if node_cache[:only_if].has_key?(index)
          cached = node_cache[:only_if][index]
          if cached
            node_cache[:only_if][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_only
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_if
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(OnlyIf0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:only_if][start_index] = r0

        r0
      end

      module IfBThenA0
        def s1
          elements[0]
        end

        def if
          elements[1]
        end

        def s2
          elements[2]
        end

        def clauses
          elements[3]
        end

        def s3
          elements[4]
        end

        def then
          elements[5]
        end

        def s4
          elements[6]
        end

        def r2
          elements[7]
        end

        def s5
          elements[8]
        end

        def c
          elements[9]
        end

        def enforcement
          elements[10]
        end

      end

      def _nt_if_b_then_a
        start_index = index
        if node_cache[:if_b_then_a].has_key?(index)
          cached = node_cache[:if_b_then_a][index]
          if cached
            node_cache[:if_b_then_a][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_if
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              r4 = _nt_clauses
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  r6 = _nt_then
                  s0 << r6
                  if r6
                    r7 = _nt_s
                    s0 << r7
                    if r7
                      r8 = _nt_clauses
                      s0 << r8
                      if r8
                        r9 = _nt_s
                        s0 << r9
                        if r9
                          r11 = _nt_context_note
                          if r11
                            r10 = r11
                          else
                            r10 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r10
                          if r10
                            r12 = _nt_enforcement
                            s0 << r12
                            if r12
                              if (match_len = has_terminal?(';', false, index))
                                r13 = true
                                @index += match_len
                              else
                                terminal_parse_failure('\';\'')
                                r13 = nil
                              end
                              s0 << r13
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IfBThenA0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:if_b_then_a][start_index] = r0

        r0
      end

      module IfAndOnlyIf0
        def if1
          elements[0]
        end

        def s1
          elements[1]
        end

        def and
          elements[2]
        end

        def s2
          elements[3]
        end

        def only
          elements[4]
        end

        def s3
          elements[5]
        end

        def if2
          elements[6]
        end

        def s4
          elements[7]
        end

        def clauses
          elements[8]
        end

        def s5
          elements[9]
        end
      end

      module IfAndOnlyIf1
        def s1
          elements[0]
        end

        def clauses
          elements[1]
        end

        def s2
          elements[2]
        end

        def tail
          elements[3]
        end

        def c
          elements[4]
        end

        def enforcement
          elements[5]
        end

      end

      def _nt_if_and_only_if
        start_index = index
        if node_cache[:if_and_only_if].has_key?(index)
          cached = node_cache[:if_and_only_if][index]
          if cached
            node_cache[:if_and_only_if][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_clauses
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              s4, i4 = [], index
              loop do
                i5, s5 = index, []
                r6 = _nt_if
                s5 << r6
                if r6
                  r7 = _nt_s
                  s5 << r7
                  if r7
                    r8 = _nt_and
                    s5 << r8
                    if r8
                      r9 = _nt_s
                      s5 << r9
                      if r9
                        r10 = _nt_only
                        s5 << r10
                        if r10
                          r11 = _nt_s
                          s5 << r11
                          if r11
                            r12 = _nt_if
                            s5 << r12
                            if r12
                              r13 = _nt_s
                              s5 << r13
                              if r13
                                r14 = _nt_clauses
                                s5 << r14
                                if r14
                                  r15 = _nt_s
                                  s5 << r15
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
                if s5.last
                  r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                  r5.extend(IfAndOnlyIf0)
                else
                  @index = i5
                  r5 = nil
                end
                if r5
                  s4 << r5
                else
                  break
                end
              end
              if s4.empty?
                @index = i4
                r4 = nil
              else
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              end
              s0 << r4
              if r4
                r17 = _nt_context_note
                if r17
                  r16 = r17
                else
                  r16 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r16
                if r16
                  r18 = _nt_enforcement
                  s0 << r18
                  if r18
                    if (match_len = has_terminal?(';', false, index))
                      r19 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\';\'')
                      r19 = nil
                    end
                    s0 << r19
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(IfAndOnlyIf1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:if_and_only_if][start_index] = r0

        r0
      end

      module RoleListConstraintFollowers0
        def occurs
          elements[0]
        end

        def s1
          elements[1]
        end

        def quantifier
          elements[2]
        end

        def s2
          elements[3]
        end

      end

      def _nt_role_list_constraint_followers
        start_index = index
        if node_cache[:role_list_constraint_followers].has_key?(index)
          cached = node_cache[:role_list_constraint_followers][index]
          if cached
            node_cache[:role_list_constraint_followers][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_occurs
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_quantifier
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                if (match_len = has_terminal?('time', false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'time\'')
                  r5 = nil
                end
                s0 << r5
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RoleListConstraintFollowers0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:role_list_constraint_followers][start_index] = r0

        r0
      end

      module Quantifier0
        def ast
          v = value
          Compiler::Quantifier.new(v[0], v[1])
        end
      end

      def _nt_quantifier
        start_index = index
        if node_cache[:quantifier].has_key?(index)
          cached = node_cache[:quantifier][index]
          if cached
            node_cache[:quantifier][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_quantifier1
        r0.extend(Quantifier0)
        r0.extend(Quantifier0)

        node_cache[:quantifier][start_index] = r0

        r0
      end

      module Quantifier10
        def each
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantifier11
        def value; [1, nil]; end
      end

      module Quantifier12
        def some
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantifier13
        def value; nil; end
      end

      module Quantifier14
        def that
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantifier15
        def value; nil; end
      end

      module Quantifier16
        def which
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantifier17
        def value; nil; end
      end

      module Quantifier18
        def one
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantifier19
        def value; [1, 1]; end
      end

      module Quantifier110
        def no
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantifier111
        def value; [0, 0]; end
      end

      module Quantifier112
        def exactly
          elements[0]
        end

        def s
          elements[1]
        end

        def quantity
          elements[2]
        end
      end

      module Quantifier113
        def value; q = quantity.value; [q, q]; end
      end

      module Quantifier114
        def and
          elements[0]
        end

        def s1
          elements[1]
        end

        def at
          elements[2]
        end

        def s2
          elements[3]
        end

        def most
          elements[4]
        end

        def s3
          elements[5]
        end

        def q
          elements[6]
        end
      end

      module Quantifier115
        def at
          elements[0]
        end

        def s1
          elements[1]
        end

        def least
          elements[2]
        end

        def s2
          elements[3]
        end

        def quantity
          elements[4]
        end

        def most
          elements[5]
        end
      end

      module Quantifier116
        def value;
                                             [ quantity.value,
                                               most.empty? ? nil : most.q.value
                                             ]
                                           end
      end

      module Quantifier117
        def at
          elements[0]
        end

        def s1
          elements[1]
        end

        def most
          elements[2]
        end

        def s2
          elements[3]
        end

        def quantity
          elements[4]
        end
      end

      module Quantifier118
        def value; [ nil, quantity.value ]; end
      end

      module Quantifier119
        def from
          elements[0]
        end

        def s1
          elements[1]
        end

        def numeric_range
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module Quantifier120
        def value; numeric_range.value; end
      end

      def _nt_quantifier1
        start_index = index
        if node_cache[:quantifier1].has_key?(index)
          cached = node_cache[:quantifier1][index]
          if cached
            node_cache[:quantifier1][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_each
        s1 << r2
        if r2
          r3 = _nt_s
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Quantifier10)
          r1.extend(Quantifier11)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_some
          s4 << r5
          if r5
            r6 = _nt_s
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Quantifier12)
            r4.extend(Quantifier13)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i7, s7 = index, []
            r8 = _nt_that
            s7 << r8
            if r8
              r9 = _nt_s
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(Quantifier14)
              r7.extend(Quantifier15)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r0 = r7
            else
              i10, s10 = index, []
              r11 = _nt_which
              s10 << r11
              if r11
                r12 = _nt_s
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(Quantifier16)
                r10.extend(Quantifier17)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                r0 = r10
              else
                i13, s13 = index, []
                r14 = _nt_one
                s13 << r14
                if r14
                  r15 = _nt_s
                  s13 << r15
                end
                if s13.last
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  r13.extend(Quantifier18)
                  r13.extend(Quantifier19)
                else
                  @index = i13
                  r13 = nil
                end
                if r13
                  r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                  r0 = r13
                else
                  i16, s16 = index, []
                  r17 = _nt_no
                  s16 << r17
                  if r17
                    r18 = _nt_s
                    s16 << r18
                  end
                  if s16.last
                    r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
                    r16.extend(Quantifier110)
                    r16.extend(Quantifier111)
                  else
                    @index = i16
                    r16 = nil
                  end
                  if r16
                    r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
                    r0 = r16
                  else
                    i19, s19 = index, []
                    r20 = _nt_exactly
                    s19 << r20
                    if r20
                      r21 = _nt_s
                      s19 << r21
                      if r21
                        r22 = _nt_quantity
                        s19 << r22
                      end
                    end
                    if s19.last
                      r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                      r19.extend(Quantifier112)
                      r19.extend(Quantifier113)
                    else
                      @index = i19
                      r19 = nil
                    end
                    if r19
                      r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
                      r0 = r19
                    else
                      i23, s23 = index, []
                      r24 = _nt_at
                      s23 << r24
                      if r24
                        r25 = _nt_s
                        s23 << r25
                        if r25
                          r26 = _nt_least
                          s23 << r26
                          if r26
                            r27 = _nt_s
                            s23 << r27
                            if r27
                              r28 = _nt_quantity
                              s23 << r28
                              if r28
                                i30, s30 = index, []
                                r31 = _nt_and
                                s30 << r31
                                if r31
                                  r32 = _nt_s
                                  s30 << r32
                                  if r32
                                    r33 = _nt_at
                                    s30 << r33
                                    if r33
                                      r34 = _nt_s
                                      s30 << r34
                                      if r34
                                        r35 = _nt_most
                                        s30 << r35
                                        if r35
                                          r36 = _nt_s
                                          s30 << r36
                                          if r36
                                            r37 = _nt_quantity
                                            s30 << r37
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                                if s30.last
                                  r30 = instantiate_node(SyntaxNode,input, i30...index, s30)
                                  r30.extend(Quantifier114)
                                else
                                  @index = i30
                                  r30 = nil
                                end
                                if r30
                                  r29 = r30
                                else
                                  r29 = instantiate_node(SyntaxNode,input, index...index)
                                end
                                s23 << r29
                              end
                            end
                          end
                        end
                      end
                      if s23.last
                        r23 = instantiate_node(SyntaxNode,input, i23...index, s23)
                        r23.extend(Quantifier115)
                        r23.extend(Quantifier116)
                      else
                        @index = i23
                        r23 = nil
                      end
                      if r23
                        r23 = SyntaxNode.new(input, (index-1)...index) if r23 == true
                        r0 = r23
                      else
                        i38, s38 = index, []
                        r39 = _nt_at
                        s38 << r39
                        if r39
                          r40 = _nt_s
                          s38 << r40
                          if r40
                            r41 = _nt_most
                            s38 << r41
                            if r41
                              r42 = _nt_s
                              s38 << r42
                              if r42
                                r43 = _nt_quantity
                                s38 << r43
                              end
                            end
                          end
                        end
                        if s38.last
                          r38 = instantiate_node(SyntaxNode,input, i38...index, s38)
                          r38.extend(Quantifier117)
                          r38.extend(Quantifier118)
                        else
                          @index = i38
                          r38 = nil
                        end
                        if r38
                          r38 = SyntaxNode.new(input, (index-1)...index) if r38 == true
                          r0 = r38
                        else
                          i44, s44 = index, []
                          r45 = _nt_from
                          s44 << r45
                          if r45
                            r46 = _nt_s
                            s44 << r46
                            if r46
                              r47 = _nt_numeric_range
                              s44 << r47
                              if r47
                                r48 = _nt_s
                                s44 << r48
                              end
                            end
                          end
                          if s44.last
                            r44 = instantiate_node(SyntaxNode,input, i44...index, s44)
                            r44.extend(Quantifier119)
                            r44.extend(Quantifier120)
                          else
                            @index = i44
                            r44 = nil
                          end
                          if r44
                            r44 = SyntaxNode.new(input, (index-1)...index) if r44 == true
                            r0 = r44
                          else
                            @index = i0
                            r0 = nil
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:quantifier1][start_index] = r0

        r0
      end

      module Quantity0
        def one
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantity1
        def value; 1; end
      end

      module Quantity2
        def number
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Quantity3
        def value; number.value; end
      end

      def _nt_quantity
        start_index = index
        if node_cache[:quantity].has_key?(index)
          cached = node_cache[:quantity][index]
          if cached
            node_cache[:quantity][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_one
        s1 << r2
        if r2
          r3 = _nt_s
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Quantity0)
          r1.extend(Quantity1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          r5 = _nt_number
          s4 << r5
          if r5
            r6 = _nt_s
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Quantity2)
            r4.extend(Quantity3)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:quantity][start_index] = r0

        r0
      end

      module AsAgreedBy0
        def S
          elements[1]
        end

        def date
          elements[2]
        end
      end

      module AsAgreedBy1
        def s1
          elements[0]
        end

        def as
          elements[1]
        end

        def s2
          elements[2]
        end

        def s3
          elements[4]
        end

        def d
          elements[5]
        end

        def by
          elements[6]
        end

        def s4
          elements[7]
        end

        def agents
          elements[8]
        end
      end

      module AsAgreedBy2
        def value; [ d.empty? ? nil : d.date.value, agents.value ]; end
      end

      def _nt_as_agreed_by
        start_index = index
        if node_cache[:as_agreed_by].has_key?(index)
          cached = node_cache[:as_agreed_by][index]
          if cached
            node_cache[:as_agreed_by][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_as
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              if (match_len = has_terminal?('agreed', false, index))
                r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'agreed\'')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  i7, s7 = index, []
                  if (match_len = has_terminal?('on', false, index))
                    r8 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'on\'')
                    r8 = nil
                  end
                  s7 << r8
                  if r8
                    r9 = _nt_S
                    s7 << r9
                    if r9
                      r10 = _nt_date
                      s7 << r10
                    end
                  end
                  if s7.last
                    r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                    r7.extend(AsAgreedBy0)
                  else
                    @index = i7
                    r7 = nil
                  end
                  if r7
                    r6 = r7
                  else
                    r6 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r6
                  if r6
                    r11 = _nt_by
                    s0 << r11
                    if r11
                      r12 = _nt_s
                      s0 << r12
                      if r12
                        r13 = _nt_agents
                        s0 << r13
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AsAgreedBy1)
          r0.extend(AsAgreedBy2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:as_agreed_by][start_index] = r0

        r0
      end

      module Date0
      end

      module Date1
        def s
          elements[0]
        end

        def d
          elements[1]
        end
      end

      module Date2
        def value; d.text_value.strip; end
      end

      def _nt_date
        start_index = index
        if node_cache[:date].has_key?(index)
          cached = node_cache[:date][index]
          if cached
            node_cache[:date][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            i4 = index
            i5 = index
            r6 = _nt_by
            if r6
              r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
              r5 = r6
            else
              if (match_len = has_terminal?(')', false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('\')\'')
                r7 = nil
              end
              if r7
                r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                r5 = r7
              else
                @index = i5
                r5 = nil
              end
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure("(any alternative)", true)
            else
              @terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s3 << r4
            if r4
              if index < input_length
                r8 = true
                @index += 1
              else
                terminal_parse_failure("any character")
                r8 = nil
              end
              s3 << r8
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(Date0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Date1)
          r0.extend(Date2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:date][start_index] = r0

        r0
      end

      module Agents0
        def s1
          elements[1]
        end

        def agent
          elements[3]
        end

        def s2
          elements[4]
        end
      end

      module Agents1
        def s1
          elements[0]
        end

        def h
          elements[1]
        end

        def s2
          elements[2]
        end

        def t
          elements[3]
        end
      end

      module Agents2
        def value; [h.text_value] + t.elements.map{|e| e.agent.text_value }; end
        def node_type; :linking; end
      end

      def _nt_agents
        start_index = index
        if node_cache[:agents].has_key?(index)
          cached = node_cache[:agents][index]
          if cached
            node_cache[:agents][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_agent
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              s4, i4 = [], index
              loop do
                i5, s5 = index, []
                if (match_len = has_terminal?(',', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\',\'')
                  r6 = nil
                end
                s5 << r6
                if r6
                  r7 = _nt_s
                  s5 << r7
                  if r7
                    i8 = index
                    r9 = _nt_context_type
                    if r9
                      @index = i8
                      r8 = nil
                    else
                      @index = i8
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s5 << r8
                    if r8
                      r10 = _nt_agent
                      s5 << r10
                      if r10
                        r11 = _nt_s
                        s5 << r11
                      end
                    end
                  end
                end
                if s5.last
                  r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                  r5.extend(Agents0)
                else
                  @index = i5
                  r5 = nil
                end
                if r5
                  s4 << r5
                else
                  break
                end
              end
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Agents1)
          r0.extend(Agents2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:agents][start_index] = r0

        r0
      end

      module Agent0
        def s
          elements[0]
        end

        def id
          elements[1]
        end
      end

      module Agent1
        def id
          elements[0]
        end

      end

      def _nt_agent
        start_index = index
        if node_cache[:agent].has_key?(index)
          cached = node_cache[:agent][index]
          if cached
            node_cache[:agent][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_id
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            r4 = _nt_s
            s3 << r4
            if r4
              r5 = _nt_id
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(Agent0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Agent1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:agent][start_index] = r0

        r0
      end

      module NegativePrefix0
        def s1
          elements[0]
        end

        def it
          elements[1]
        end

        def s2
          elements[2]
        end

        def is
          elements[3]
        end

        def s3
          elements[4]
        end

        def not
          elements[5]
        end

        def s4
          elements[6]
        end

        def the
          elements[7]
        end

        def s5
          elements[8]
        end

        def case
          elements[9]
        end

        def s6
          elements[10]
        end

        def that
          elements[11]
        end

        def s7
          elements[12]
        end
      end

      def _nt_negative_prefix
        start_index = index
        if node_cache[:negative_prefix].has_key?(index)
          cached = node_cache[:negative_prefix][index]
          if cached
            node_cache[:negative_prefix][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_it
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              r4 = _nt_is
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  r6 = _nt_not
                  s0 << r6
                  if r6
                    r7 = _nt_s
                    s0 << r7
                    if r7
                      r8 = _nt_the
                      s0 << r8
                      if r8
                        r9 = _nt_s
                        s0 << r9
                        if r9
                          r10 = _nt_case
                          s0 << r10
                          if r10
                            r11 = _nt_s
                            s0 << r11
                            if r11
                              r12 = _nt_that
                              s0 << r12
                              if r12
                                r13 = _nt_s
                                s0 << r13
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NegativePrefix0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:negative_prefix][start_index] = r0

        r0
      end

      def _nt_agg_of
        start_index = index
        if node_cache[:agg_of].has_key?(index)
          cached = node_cache[:agg_of][index]
          if cached
            node_cache[:agg_of][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_of

        node_cache[:agg_of][start_index] = r0

        r0
      end

      def _nt_agg_in
        start_index = index
        if node_cache[:agg_in].has_key?(index)
          cached = node_cache[:agg_in][index]
          if cached
            node_cache[:agg_in][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_in

        node_cache[:agg_in][start_index] = r0

        r0
      end

      module RestrictedTo0
        def s1
          elements[1]
        end

        def s2
          elements[3]
        end

      end

      def _nt_restricted_to
        start_index = index
        if node_cache[:restricted_to].has_key?(index)
          cached = node_cache[:restricted_to][index]
          if cached
            node_cache[:restricted_to][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('restricted', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'restricted\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?('to', false, index))
              r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'to\'')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                r6 = _nt_alphanumeric
                if r6
                  @index = i5
                  r5 = nil
                else
                  @index = i5
                  r5 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r5
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RestrictedTo0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:restricted_to][start_index] = r0

        r0
      end

      def _nt_any
        start_index = index
        if node_cache[:any].has_key?(index)
          cached = node_cache[:any][index]
          if cached
            node_cache[:any][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_one
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_a
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:any][start_index] = r0

        r0
      end

      module A0
      end

      module A1
      end

      def _nt_a
        start_index = index
        if node_cache[:a].has_key?(index)
          cached = node_cache[:a][index]
          if cached
            node_cache[:a][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?('a', false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('\'a\'')
          r2 = nil
        end
        s1 << r2
        if r2
          i3 = index
          r4 = _nt_alphanumeric
          if r4
            @index = i3
            r3 = nil
          else
            @index = i3
            r3 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(A0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i5, s5 = index, []
          if (match_len = has_terminal?('an', false, index))
            r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'an\'')
            r6 = nil
          end
          s5 << r6
          if r6
            i7 = index
            r8 = _nt_alphanumeric
            if r8
              @index = i7
              r7 = nil
            else
              @index = i7
              r7 = instantiate_node(SyntaxNode,input, index...index)
            end
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(A1)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r0 = r5
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:a][start_index] = r0

        r0
      end

      module All0
      end

      def _nt_all
        start_index = index
        if node_cache[:all].has_key?(index)
          cached = node_cache[:all][index]
          if cached
            node_cache[:all][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('all', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'all\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(All0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:all][start_index] = r0

        r0
      end

      module Ascending0
      end

      def _nt_ascending
        start_index = index
        if node_cache[:ascending].has_key?(index)
          cached = node_cache[:ascending][index]
          if cached
            node_cache[:ascending][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ascending', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ascending\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Ascending0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ascending][start_index] = r0

        r0
      end

      module At0
      end

      def _nt_at
        start_index = index
        if node_cache[:at].has_key?(index)
          cached = node_cache[:at][index]
          if cached
            node_cache[:at][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('at', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'at\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(At0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:at][start_index] = r0

        r0
      end

      module Both0
      end

      def _nt_both
        start_index = index
        if node_cache[:both].has_key?(index)
          cached = node_cache[:both][index]
          if cached
            node_cache[:both][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('both', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'both\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Both0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:both][start_index] = r0

        r0
      end

      module Converts0
      end

      def _nt_converts
        start_index = index
        if node_cache[:converts].has_key?(index)
          cached = node_cache[:converts][index]
          if cached
            node_cache[:converts][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('converts', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'converts\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Converts0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:converts][start_index] = r0

        r0
      end

      module Descending0
      end

      def _nt_descending
        start_index = index
        if node_cache[:descending].has_key?(index)
          cached = node_cache[:descending][index]
          if cached
            node_cache[:descending][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('descending', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'descending\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Descending0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:descending][start_index] = r0

        r0
      end

      module Each0
      end

      def _nt_each
        start_index = index
        if node_cache[:each].has_key?(index)
          cached = node_cache[:each][index]
          if cached
            node_cache[:each][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('each', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'each\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Each0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:each][start_index] = r0

        r0
      end

      module Either0
      end

      def _nt_either
        start_index = index
        if node_cache[:either].has_key?(index)
          cached = node_cache[:either][index]
          if cached
            node_cache[:either][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('either', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'either\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Either0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:either][start_index] = r0

        r0
      end

      module Entity0
      end

      def _nt_entity
        start_index = index
        if node_cache[:entity].has_key?(index)
          cached = node_cache[:entity][index]
          if cached
            node_cache[:entity][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('entity', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'entity\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Entity0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:entity][start_index] = r0

        r0
      end

      module Exactly0
      end

      def _nt_exactly
        start_index = index
        if node_cache[:exactly].has_key?(index)
          cached = node_cache[:exactly][index]
          if cached
            node_cache[:exactly][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('exactly', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'exactly\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Exactly0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:exactly][start_index] = r0

        r0
      end

      module From0
      end

      def _nt_from
        start_index = index
        if node_cache[:from].has_key?(index)
          cached = node_cache[:from][index]
          if cached
            node_cache[:from][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('from', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'from\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(From0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:from][start_index] = r0

        r0
      end

      module Includes0
      end

      def _nt_includes
        start_index = index
        if node_cache[:includes].has_key?(index)
          cached = node_cache[:includes][index]
          if cached
            node_cache[:includes][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('includes', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'includes\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Includes0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:includes][start_index] = r0

        r0
      end

      module Least0
      end

      def _nt_least
        start_index = index
        if node_cache[:least].has_key?(index)
          cached = node_cache[:least][index]
          if cached
            node_cache[:least][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('least', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'least\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Least0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:least][start_index] = r0

        r0
      end

      module Matches0
      end

      def _nt_matches
        start_index = index
        if node_cache[:matches].has_key?(index)
          cached = node_cache[:matches][index]
          if cached
            node_cache[:matches][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('matches', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'matches\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Matches0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:matches][start_index] = r0

        r0
      end

      module Most0
      end

      def _nt_most
        start_index = index
        if node_cache[:most].has_key?(index)
          cached = node_cache[:most][index]
          if cached
            node_cache[:most][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('most', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'most\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Most0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:most][start_index] = r0

        r0
      end

      module No0
      end

      def _nt_no
        start_index = index
        if node_cache[:no].has_key?(index)
          cached = node_cache[:no][index]
          if cached
            node_cache[:no][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('no', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'no\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(No0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:no][start_index] = r0

        r0
      end

      module None0
      end

      def _nt_none
        start_index = index
        if node_cache[:none].has_key?(index)
          cached = node_cache[:none][index]
          if cached
            node_cache[:none][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('none', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'none\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(None0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:none][start_index] = r0

        r0
      end

      module Not0
      end

      def _nt_not
        start_index = index
        if node_cache[:not].has_key?(index)
          cached = node_cache[:not][index]
          if cached
            node_cache[:not][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('not', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'not\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Not0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:not][start_index] = r0

        r0
      end

      module Occurs0
      end

      def _nt_occurs
        start_index = index
        if node_cache[:occurs].has_key?(index)
          cached = node_cache[:occurs][index]
          if cached
            node_cache[:occurs][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('occurs', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'occurs\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Occurs0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:occurs][start_index] = r0

        r0
      end

      module One0
      end

      def _nt_one
        start_index = index
        if node_cache[:one].has_key?(index)
          cached = node_cache[:one][index]
          if cached
            node_cache[:one][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('one', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'one\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(One0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:one][start_index] = r0

        r0
      end

      module Some0
      end

      def _nt_some
        start_index = index
        if node_cache[:some].has_key?(index)
          cached = node_cache[:some][index]
          if cached
            node_cache[:some][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('some', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'some\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Some0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:some][start_index] = r0

        r0
      end

      module AccordingTo0
        def S
          elements[1]
        end

        def to
          elements[2]
        end
      end

      def _nt_according_to
        start_index = index
        if node_cache[:according_to].has_key?(index)
          cached = node_cache[:according_to][index]
          if cached
            node_cache[:according_to][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('according', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'according\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_to
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AccordingTo0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:according_to][start_index] = r0

        r0
      end

      module Acyclic0
      end

      def _nt_acyclic
        start_index = index
        if node_cache[:acyclic].has_key?(index)
          cached = node_cache[:acyclic][index]
          if cached
            node_cache[:acyclic][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('acyclic', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'acyclic\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Acyclic0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:acyclic][start_index] = r0

        r0
      end

      module Alias0
      end

      def _nt_alias
        start_index = index
        if node_cache[:alias].has_key?(index)
          cached = node_cache[:alias][index]
          if cached
            node_cache[:alias][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('alias', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'alias\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Alias0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:alias][start_index] = r0

        r0
      end

      module And0
      end

      def _nt_and
        start_index = index
        if node_cache[:and].has_key?(index)
          cached = node_cache[:and][index]
          if cached
            node_cache[:and][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('and', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'and\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(And0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:and][start_index] = r0

        r0
      end

      module Antisymmetric0
      end

      def _nt_antisymmetric
        start_index = index
        if node_cache[:antisymmetric].has_key?(index)
          cached = node_cache[:antisymmetric][index]
          if cached
            node_cache[:antisymmetric][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('antisymmetric', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'antisymmetric\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Antisymmetric0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:antisymmetric][start_index] = r0

        r0
      end

      module Approximately0
      end

      def _nt_approximately
        start_index = index
        if node_cache[:approximately].has_key?(index)
          cached = node_cache[:approximately][index]
          if cached
            node_cache[:approximately][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('approximately', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'approximately\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Approximately0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:approximately][start_index] = r0

        r0
      end

      module As0
      end

      def _nt_as
        start_index = index
        if node_cache[:as].has_key?(index)
          cached = node_cache[:as][index]
          if cached
            node_cache[:as][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('as', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'as\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(As0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:as][start_index] = r0

        r0
      end

      module AsOpposedTo0
        def as
          elements[0]
        end

        def s
          elements[1]
        end

        def S
          elements[3]
        end

        def to
          elements[4]
        end
      end

      def _nt_as_opposed_to
        start_index = index
        if node_cache[:as_opposed_to].has_key?(index)
          cached = node_cache[:as_opposed_to][index]
          if cached
            node_cache[:as_opposed_to][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_as
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?('opposed', false, index))
              r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'opposed\'')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                r5 = _nt_to
                s0 << r5
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AsOpposedTo0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:as_opposed_to][start_index] = r0

        r0
      end

      module Asymmetric0
      end

      def _nt_asymmetric
        start_index = index
        if node_cache[:asymmetric].has_key?(index)
          cached = node_cache[:asymmetric][index]
          if cached
            node_cache[:asymmetric][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('asymmetric', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'asymmetric\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Asymmetric0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:asymmetric][start_index] = r0

        r0
      end

      module Because0
      end

      def _nt_because
        start_index = index
        if node_cache[:because].has_key?(index)
          cached = node_cache[:because][index]
          if cached
            node_cache[:because][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('because', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'because\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Because0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:because][start_index] = r0

        r0
      end

      module But0
      end

      def _nt_but
        start_index = index
        if node_cache[:but].has_key?(index)
          cached = node_cache[:but][index]
          if cached
            node_cache[:but][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('but', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'but\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(But0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:but][start_index] = r0

        r0
      end

      module By0
      end

      def _nt_by
        start_index = index
        if node_cache[:by].has_key?(index)
          cached = node_cache[:by][index]
          if cached
            node_cache[:by][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('by', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'by\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(By0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:by][start_index] = r0

        r0
      end

      module Case0
      end

      def _nt_case
        start_index = index
        if node_cache[:case].has_key?(index)
          cached = node_cache[:case][index]
          if cached
            node_cache[:case][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('case', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'case\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Case0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:case][start_index] = r0

        r0
      end

      module Definitely0
      end

      def _nt_definitely
        start_index = index
        if node_cache[:definitely].has_key?(index)
          cached = node_cache[:definitely][index]
          if cached
            node_cache[:definitely][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('definitely', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'definitely\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Definitely0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:definitely][start_index] = r0

        r0
      end

      module Ephemera0
      end

      def _nt_ephemera
        start_index = index
        if node_cache[:ephemera].has_key?(index)
          cached = node_cache[:ephemera][index]
          if cached
            node_cache[:ephemera][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('ephemera', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'ephemera\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Ephemera0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ephemera][start_index] = r0

        r0
      end

      module False0
      end

      def _nt_false
        start_index = index
        if node_cache[:false].has_key?(index)
          cached = node_cache[:false][index]
          if cached
            node_cache[:false][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('false', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'false\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(False0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:false][start_index] = r0

        r0
      end

      module Feminine0
      end

      def _nt_feminine
        start_index = index
        if node_cache[:feminine].has_key?(index)
          cached = node_cache[:feminine][index]
          if cached
            node_cache[:feminine][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('feminine', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'feminine\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Feminine0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:feminine][start_index] = r0

        r0
      end

      module Identified0
      end

      def _nt_identified
        start_index = index
        if node_cache[:identified].has_key?(index)
          cached = node_cache[:identified][index]
          if cached
            node_cache[:identified][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        if (match_len = has_terminal?('known', false, index))
          r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'known\'')
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          if (match_len = has_terminal?('identified', false, index))
            r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'identified\'')
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          i4 = index
          r5 = _nt_alphanumeric
          if r5
            @index = i4
            r4 = nil
          else
            @index = i4
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Identified0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:identified][start_index] = r0

        r0
      end

      module If0
      end

      def _nt_if
        start_index = index
        if node_cache[:if].has_key?(index)
          cached = node_cache[:if][index]
          if cached
            node_cache[:if][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('if', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'if\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(If0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:if][start_index] = r0

        r0
      end

      module In0
      end

      def _nt_in
        start_index = index
        if node_cache[:in].has_key?(index)
          cached = node_cache[:in][index]
          if cached
            node_cache[:in][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('in', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'in\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(In0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:in][start_index] = r0

        r0
      end

      module Import0
      end

      def _nt_import
        start_index = index
        if node_cache[:import].has_key?(index)
          cached = node_cache[:import][index]
          if cached
            node_cache[:import][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('import', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'import\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Import0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:import][start_index] = r0

        r0
      end

      module Independent0
      end

      def _nt_independent
        start_index = index
        if node_cache[:independent].has_key?(index)
          cached = node_cache[:independent][index]
          if cached
            node_cache[:independent][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('independent', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'independent\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Independent0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:independent][start_index] = r0

        r0
      end

      module Stronglyintransitive0
        def s
          elements[1]
        end

      end

      def _nt_stronglyintransitive
        start_index = index
        if node_cache[:stronglyintransitive].has_key?(index)
          cached = node_cache[:stronglyintransitive][index]
          if cached
            node_cache[:stronglyintransitive][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('strongly', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'strongly\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?('intransitive', false, index))
              r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'intransitive\'')
              r3 = nil
            end
            s0 << r3
            if r3
              i4 = index
              r5 = _nt_alphanumeric
              if r5
                @index = i4
                r4 = nil
              else
                @index = i4
                r4 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Stronglyintransitive0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:stronglyintransitive][start_index] = r0

        r0
      end

      module Informally0
      end

      def _nt_informally
        start_index = index
        if node_cache[:informally].has_key?(index)
          cached = node_cache[:informally][index]
          if cached
            node_cache[:informally][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ii]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ii]')
          r1 = nil
        end
        s0 << r1
        if r1
          if (match_len = has_terminal?('nformally', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'nformally\'')
            r2 = nil
          end
          s0 << r2
          if r2
            i3 = index
            r4 = _nt_alphanumeric
            if r4
              @index = i3
              r3 = nil
            else
              @index = i3
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Informally0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:informally][start_index] = r0

        r0
      end

      module Intransitive0
      end

      def _nt_intransitive
        start_index = index
        if node_cache[:intransitive].has_key?(index)
          cached = node_cache[:intransitive][index]
          if cached
            node_cache[:intransitive][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('intransitive', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'intransitive\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Intransitive0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:intransitive][start_index] = r0

        r0
      end

      module Irreflexive0
      end

      def _nt_irreflexive
        start_index = index
        if node_cache[:irreflexive].has_key?(index)
          cached = node_cache[:irreflexive][index]
          if cached
            node_cache[:irreflexive][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('irreflexive', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'irreflexive\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Irreflexive0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:irreflexive][start_index] = r0

        r0
      end

      module Is0
      end

      def _nt_is
        start_index = index
        if node_cache[:is].has_key?(index)
          cached = node_cache[:is][index]
          if cached
            node_cache[:is][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('is', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'is\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Is0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:is][start_index] = r0

        r0
      end

      module It0
      end

      def _nt_it
        start_index = index
        if node_cache[:it].has_key?(index)
          cached = node_cache[:it][index]
          if cached
            node_cache[:it][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('it', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'it\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(It0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:it][start_index] = r0

        r0
      end

      module Its0
      end

      def _nt_its
        start_index = index
        if node_cache[:its].has_key?(index)
          cached = node_cache[:its][index]
          if cached
            node_cache[:its][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('its', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'its\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Its0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:its][start_index] = r0

        r0
      end

      module Masculine0
      end

      def _nt_masculine
        start_index = index
        if node_cache[:masculine].has_key?(index)
          cached = node_cache[:masculine][index]
          if cached
            node_cache[:masculine][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('masculine', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'masculine\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Masculine0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:masculine][start_index] = r0

        r0
      end

      module Maybe0
      end

      def _nt_maybe
        start_index = index
        if node_cache[:maybe].has_key?(index)
          cached = node_cache[:maybe][index]
          if cached
            node_cache[:maybe][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('maybe', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'maybe\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Maybe0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:maybe][start_index] = r0

        r0
      end

      module Only0
      end

      def _nt_only
        start_index = index
        if node_cache[:only].has_key?(index)
          cached = node_cache[:only][index]
          if cached
            node_cache[:only][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('only', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'only\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Only0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:only][start_index] = r0

        r0
      end

      module Or0
      end

      def _nt_or
        start_index = index
        if node_cache[:or].has_key?(index)
          cached = node_cache[:or][index]
          if cached
            node_cache[:or][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('or', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'or\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Or0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:or][start_index] = r0

        r0
      end

      module Of0
      end

      def _nt_of
        start_index = index
        if node_cache[:of].has_key?(index)
          cached = node_cache[:of][index]
          if cached
            node_cache[:of][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('of', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'of\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Of0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:of][start_index] = r0

        r0
      end

      module OrderingPrefix0
        def by
          elements[0]
        end

        def s1
          elements[1]
        end

        def s2
          elements[3]
        end
      end

      def _nt_ordering_prefix
        start_index = index
        if node_cache[:ordering_prefix].has_key?(index)
          cached = node_cache[:ordering_prefix][index]
          if cached
            node_cache[:ordering_prefix][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_by
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            i4 = index
            r5 = _nt_ascending
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r4 = r5
            else
              r6 = _nt_descending
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r4 = r6
              else
                @index = i4
                r4 = nil
              end
            end
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
            if r3
              r7 = _nt_s
              s0 << r7
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(OrderingPrefix0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ordering_prefix][start_index] = r0

        r0
      end

      module Otherwise0
      end

      def _nt_otherwise
        start_index = index
        if node_cache[:otherwise].has_key?(index)
          cached = node_cache[:otherwise][index]
          if cached
            node_cache[:otherwise][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('otherwise', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'otherwise\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Otherwise0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:otherwise][start_index] = r0

        r0
      end

      module Partitioned0
      end

      def _nt_partitioned
        start_index = index
        if node_cache[:partitioned].has_key?(index)
          cached = node_cache[:partitioned][index]
          if cached
            node_cache[:partitioned][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('partitioned', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'partitioned\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Partitioned0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:partitioned][start_index] = r0

        r0
      end

      module Personal0
      end

      def _nt_personal
        start_index = index
        if node_cache[:personal].has_key?(index)
          cached = node_cache[:personal][index]
          if cached
            node_cache[:personal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('personal', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'personal\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Personal0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:personal][start_index] = r0

        r0
      end

      def _nt_radix_point
        start_index = index
        if node_cache[:radix_point].has_key?(index)
          cached = node_cache[:radix_point][index]
          if cached
            node_cache[:radix_point][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('.', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'.\'')
          r0 = nil
        end

        node_cache[:radix_point][start_index] = r0

        r0
      end

      module Reflexive0
      end

      def _nt_reflexive
        start_index = index
        if node_cache[:reflexive].has_key?(index)
          cached = node_cache[:reflexive][index]
          if cached
            node_cache[:reflexive][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('reflexive', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'reflexive\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Reflexive0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:reflexive][start_index] = r0

        r0
      end

      module Returning0
      end

      def _nt_returning
        start_index = index
        if node_cache[:returning].has_key?(index)
          cached = node_cache[:returning][index]
          if cached
            node_cache[:returning][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('returning', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'returning\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Returning0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:returning][start_index] = r0

        r0
      end

      module Schema0
      end

      def _nt_schema
        start_index = index
        if node_cache[:schema].has_key?(index)
          cached = node_cache[:schema][index]
          if cached
            node_cache[:schema][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('schema', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'schema\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Schema0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:schema][start_index] = r0

        r0
      end

      module Separate0
      end

      def _nt_separate
        start_index = index
        if node_cache[:separate].has_key?(index)
          cached = node_cache[:separate][index]
          if cached
            node_cache[:separate][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('separate', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'separate\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Separate0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:separate][start_index] = r0

        r0
      end

      module SoThat0
        def S
          elements[1]
        end

        def that
          elements[2]
        end
      end

      def _nt_so_that
        start_index = index
        if node_cache[:so_that].has_key?(index)
          cached = node_cache[:so_that][index]
          if cached
            node_cache[:so_that][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('so', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'so\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_that
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SoThat0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:so_that][start_index] = r0

        r0
      end

      module Static0
      end

      def _nt_static
        start_index = index
        if node_cache[:static].has_key?(index)
          cached = node_cache[:static][index]
          if cached
            node_cache[:static][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('static', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'static\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Static0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:static][start_index] = r0

        r0
      end

      module Symmetric0
      end

      def _nt_symmetric
        start_index = index
        if node_cache[:symmetric].has_key?(index)
          cached = node_cache[:symmetric][index]
          if cached
            node_cache[:symmetric][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('symmetric', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'symmetric\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Symmetric0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:symmetric][start_index] = r0

        r0
      end

      module That0
      end

      def _nt_that
        start_index = index
        if node_cache[:that].has_key?(index)
          cached = node_cache[:that][index]
          if cached
            node_cache[:that][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('that', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'that\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(That0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:that][start_index] = r0

        r0
      end

      module The0
      end

      def _nt_the
        start_index = index
        if node_cache[:the].has_key?(index)
          cached = node_cache[:the][index]
          if cached
            node_cache[:the][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('the', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'the\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(The0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:the][start_index] = r0

        r0
      end

      module Then0
      end

      def _nt_then
        start_index = index
        if node_cache[:then].has_key?(index)
          cached = node_cache[:then][index]
          if cached
            node_cache[:then][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('then', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'then\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Then0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:then][start_index] = r0

        r0
      end

      module To0
      end

      def _nt_to
        start_index = index
        if node_cache[:to].has_key?(index)
          cached = node_cache[:to][index]
          if cached
            node_cache[:to][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('to', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'to\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(To0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:to][start_index] = r0

        r0
      end

      module ToAvoid0
        def to
          elements[0]
        end

        def s
          elements[1]
        end

      end

      def _nt_to_avoid
        start_index = index
        if node_cache[:to_avoid].has_key?(index)
          cached = node_cache[:to_avoid][index]
          if cached
            node_cache[:to_avoid][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_to
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?('avoid', false, index))
              r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'avoid\'')
              r3 = nil
            end
            s0 << r3
            if r3
              i4 = index
              r5 = _nt_alphanumeric
              if r5
                @index = i4
                r4 = nil
              else
                @index = i4
                r4 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ToAvoid0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:to_avoid][start_index] = r0

        r0
      end

      module Topic0
      end

      def _nt_topic
        start_index = index
        if node_cache[:topic].has_key?(index)
          cached = node_cache[:topic][index]
          if cached
            node_cache[:topic][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('topic', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'topic\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Topic0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:topic][start_index] = r0

        r0
      end

      module Transform0
      end

      def _nt_transform
        start_index = index
        if node_cache[:transform].has_key?(index)
          cached = node_cache[:transform][index]
          if cached
            node_cache[:transform][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('transform', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'transform\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Transform0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:transform][start_index] = r0

        r0
      end

      module Transient0
      end

      def _nt_transient
        start_index = index
        if node_cache[:transient].has_key?(index)
          cached = node_cache[:transient][index]
          if cached
            node_cache[:transient][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('transient', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'transient\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Transient0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:transient][start_index] = r0

        r0
      end

      module Transitive0
      end

      def _nt_transitive
        start_index = index
        if node_cache[:transitive].has_key?(index)
          cached = node_cache[:transitive][index]
          if cached
            node_cache[:transitive][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('transitive', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'transitive\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Transitive0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:transitive][start_index] = r0

        r0
      end

      module True0
      end

      def _nt_true
        start_index = index
        if node_cache[:true].has_key?(index)
          cached = node_cache[:true][index]
          if cached
            node_cache[:true][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('true', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'true\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(True0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:true][start_index] = r0

        r0
      end

      module Version0
      end

      def _nt_version
        start_index = index
        if node_cache[:version].has_key?(index)
          cached = node_cache[:version][index]
          if cached
            node_cache[:version][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('version', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'version\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Version0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:version][start_index] = r0

        r0
      end

      module Vocabulary0
      end

      def _nt_vocabulary
        start_index = index
        if node_cache[:vocabulary].has_key?(index)
          cached = node_cache[:vocabulary][index]
          if cached
            node_cache[:vocabulary][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('vocabulary', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'vocabulary\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Vocabulary0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:vocabulary][start_index] = r0

        r0
      end

      module When0
      end

      def _nt_when
        start_index = index
        if node_cache[:when].has_key?(index)
          cached = node_cache[:when][index]
          if cached
            node_cache[:when][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('when', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'when\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(When0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:when][start_index] = r0

        r0
      end

      module Where0
      end

      def _nt_where
        start_index = index
        if node_cache[:where].has_key?(index)
          cached = node_cache[:where][index]
          if cached
            node_cache[:where][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('where', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'where\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Where0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:where][start_index] = r0

        r0
      end

      module Which0
      end

      def _nt_which
        start_index = index
        if node_cache[:which].has_key?(index)
          cached = node_cache[:which][index]
          if cached
            node_cache[:which][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('which', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'which\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Which0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:which][start_index] = r0

        r0
      end

      module Was0
      end

      def _nt_was
        start_index = index
        if node_cache[:was].has_key?(index)
          cached = node_cache[:was][index]
          if cached
            node_cache[:was][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('was', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'was\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Was0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:was][start_index] = r0

        r0
      end

      module Who0
      end

      def _nt_who
        start_index = index
        if node_cache[:who].has_key?(index)
          cached = node_cache[:who][index]
          if cached
            node_cache[:who][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('who', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'who\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_alphanumeric
          if r3
            @index = i2
            r2 = nil
          else
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Who0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:who][start_index] = r0

        r0
      end

    end

    class EnglishParser < Treetop::Runtime::CompiledParser
      include English
    end

  end
end
