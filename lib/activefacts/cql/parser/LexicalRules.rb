#
# Autogenerated from a Treetop grammar. Edits may be lost.


#       ActiveFacts CQL Parser.
#       Various lexical rules for CQL.
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
module ActiveFacts
  module CQL
    module LexicalRules
      include Treetop::Runtime

      def root
        @root ||= :range
      end

      module Range0
        def node_type; :literal; end
      end

      def _nt_range
        start_index = index
        if node_cache[:range].has_key?(index)
          cached = node_cache[:range][index]
          if cached
            node_cache[:range][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_numeric_range
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(Range0)
          r0.extend(Range0)
        else
          r2 = _nt_string_range
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
            r0.extend(Range0)
            r0.extend(Range0)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:range][start_index] = r0

        r0
      end

      module NumericRange0
        def s1
          elements[1]
        end

        def end
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module NumericRange1
        def number
          elements[0]
        end

        def s
          elements[1]
        end

        def tail
          elements[2]
        end
      end

      module NumericRange2
        def value
          if !tail.empty?
            last = tail.end.value unless tail.end.empty?
            [ number.value, last ]
          else
            number.value
          end
        end
      end

      module NumericRange3
        def s1
          elements[1]
        end

        def number
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module NumericRange4
        def value
          [ nil, number.value ]
        end
      end

      def _nt_numeric_range
        start_index = index
        if node_cache[:numeric_range].has_key?(index)
          cached = node_cache[:numeric_range][index]
          if cached
            node_cache[:numeric_range][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_number
        s1 << r2
        if r2
          r3 = _nt_s
          s1 << r3
          if r3
            i5, s5 = index, []
            if (match_len = has_terminal?('..', false, index))
              r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'..\'')
              r6 = nil
            end
            s5 << r6
            if r6
              r7 = _nt_s
              s5 << r7
              if r7
                r9 = _nt_number
                if r9
                  r8 = r9
                else
                  r8 = instantiate_node(SyntaxNode,input, index...index)
                end
                s5 << r8
                if r8
                  r10 = _nt_s
                  s5 << r10
                end
              end
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(NumericRange0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              r4 = r5
            else
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(NumericRange1)
          r1.extend(NumericRange2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i11, s11 = index, []
          if (match_len = has_terminal?('..', false, index))
            r12 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'..\'')
            r12 = nil
          end
          s11 << r12
          if r12
            r13 = _nt_s
            s11 << r13
            if r13
              r14 = _nt_number
              s11 << r14
              if r14
                r15 = _nt_s
                s11 << r15
              end
            end
          end
          if s11.last
            r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
            r11.extend(NumericRange3)
            r11.extend(NumericRange4)
          else
            @index = i11
            r11 = nil
          end
          if r11
            r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
            r0 = r11
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:numeric_range][start_index] = r0

        r0
      end

      module StringRange0
        def s1
          elements[1]
        end

        def end
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module StringRange1
        def string
          elements[0]
        end

        def s
          elements[1]
        end

        def tail
          elements[2]
        end
      end

      module StringRange2
        # Ranges require the original text of the string, not the content:
        def value
          first = string.text_value
          if !tail.empty?
            last = tail.end.text_value unless tail.end.empty?
            [ first, last ]
          else
            first
          end
        end
      end

      module StringRange3
        def s1
          elements[1]
        end

        def string
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module StringRange4
        def value
          [ nil, string.value ]
        end
      end

      def _nt_string_range
        start_index = index
        if node_cache[:string_range].has_key?(index)
          cached = node_cache[:string_range][index]
          if cached
            node_cache[:string_range][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_string
        s1 << r2
        if r2
          r3 = _nt_s
          s1 << r3
          if r3
            i5, s5 = index, []
            if (match_len = has_terminal?('..', false, index))
              r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'..\'')
              r6 = nil
            end
            s5 << r6
            if r6
              r7 = _nt_s
              s5 << r7
              if r7
                r9 = _nt_string
                if r9
                  r8 = r9
                else
                  r8 = instantiate_node(SyntaxNode,input, index...index)
                end
                s5 << r8
                if r8
                  r10 = _nt_s
                  s5 << r10
                end
              end
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(StringRange0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              r4 = r5
            else
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(StringRange1)
          r1.extend(StringRange2)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i11, s11 = index, []
          if (match_len = has_terminal?('..', false, index))
            r12 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'..\'')
            r12 = nil
          end
          s11 << r12
          if r12
            r13 = _nt_s
            s11 << r13
            if r13
              r14 = _nt_string
              s11 << r14
              if r14
                r15 = _nt_s
                s11 << r15
              end
            end
          end
          if s11.last
            r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
            r11.extend(StringRange3)
            r11.extend(StringRange4)
          else
            @index = i11
            r11 = nil
          end
          if r11
            r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
            r0 = r11
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:string_range][start_index] = r0

        r0
      end

      module Url0
      end

      module Url1
        def node_type; :literal; end
      end

      def _nt_url
        start_index = index
        if node_cache[:url].has_key?(index)
          cached = node_cache[:url][index]
          if cached
            node_cache[:url][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1, s1 = index, []
          i2 = index
          i3 = index
          r4 = _nt_white
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r3 = r4
          else
            if (match_len = has_terminal?(';', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure('\';\'')
              r5 = nil
            end
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r3 = r5
            else
              @index = i3
              r3 = nil
            end
          end
          if r3
            @index = i2
            r2 = nil
            terminal_parse_failure("(any alternative)", true)
          else
            @terminal_failures.pop
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r2
          if r2
            if index < input_length
              r6 = true
              @index += 1
            else
              terminal_parse_failure("any character")
              r6 = nil
            end
            s1 << r6
          end
          if s1.last
            r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
            r1.extend(Url0)
          else
            @index = i1
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Url1)
          r0.extend(Url1)
        end

        node_cache[:url][start_index] = r0

        r0
      end

      module Literal0
        def s
          elements[1]
        end
      end

      module Literal1
        def value
          elements[0].value
        end
        def node_type; :literal; end
      end

      def _nt_literal
        start_index = index
        if node_cache[:literal].has_key?(index)
          cached = node_cache[:literal][index]
          if cached
            node_cache[:literal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_boolean_literal
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_string
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            r4 = _nt_number
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r1 = r4
            else
              @index = i1
              r1 = nil
            end
          end
        end
        s0 << r1
        if r1
          r5 = _nt_s
          s0 << r5
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Literal0)
          r0.extend(Literal1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:literal][start_index] = r0

        r0
      end

      module BooleanLiteral0
        def value; true; end
      end

      module BooleanLiteral1
        def value; false; end
      end

      module BooleanLiteral2
      end

      module BooleanLiteral3
        def value; elements[0].value end
      end

      def _nt_boolean_literal
        start_index = index
        if node_cache[:boolean_literal].has_key?(index)
          cached = node_cache[:boolean_literal][index]
          if cached
            node_cache[:boolean_literal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_true
        r2.extend(BooleanLiteral0)
        r2.extend(BooleanLiteral0)
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_false
          r3.extend(BooleanLiteral1)
          r3.extend(BooleanLiteral1)
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          i4 = index
          r5 = _nt_alphanumeric
          if r5
            @index = i4
            r4 = nil
          else
            @index = i4
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r4
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(BooleanLiteral2)
          r0.extend(BooleanLiteral3)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:boolean_literal][start_index] = r0

        r0
      end

      module String0
      end

      module String1
        def value
          text_value
          eval(text_value.sub(/\A'(.*)'\Z/,'"\1"'))
        end
      end

      def _nt_string
        start_index = index
        if node_cache[:string].has_key?(index)
          cached = node_cache[:string][index]
          if cached
            node_cache[:string][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?("'", false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('"\'"')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_string_char
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            if (match_len = has_terminal?("'", false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('"\'"')
              r4 = nil
            end
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(String0)
          r0.extend(String1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:string][start_index] = r0

        r0
      end

      module Number0
      end

      module Number1
        def value
          eval(text_value)
        end
        def node_type; :literal; end
      end

      def _nt_number
        start_index = index
        if node_cache[:number].has_key?(index)
          cached = node_cache[:number][index]
          if cached
            node_cache[:number][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_real
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r3 = _nt_fractional_real
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r1 = r3
          else
            r4 = _nt_hexnumber
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r1 = r4
            else
              r5 = _nt_octalnumber
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r1 = r5
              else
                @index = i1
                r1 = nil
              end
            end
          end
        end
        s0 << r1
        if r1
          i6 = index
          r7 = _nt_alphanumeric
          if r7
            @index = i6
            r6 = nil
          else
            @index = i6
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r6
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Number0)
          r0.extend(Number1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:number][start_index] = r0

        r0
      end

      module StringChar0
      end

      module StringChar1
      end

      module StringChar2
      end

      module StringChar3
      end

      module StringChar4
      end

      module StringChar5
      end

      def _nt_string_char
        start_index = index
        if node_cache[:string_char].has_key?(index)
          cached = node_cache[:string_char][index]
          if cached
            node_cache[:string_char][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?('\\', false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('\'\\\\\'')
          r2 = nil
        end
        s1 << r2
        if r2
          if has_terminal?(@regexps[gr = '\A[befntr\\\\\']'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[befntr\\\\\']')
            r3 = nil
          end
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(StringChar0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i4, s4 = index, []
          if (match_len = has_terminal?('\\', false, index))
            r5 = true
            @index += match_len
          else
            terminal_parse_failure('\'\\\\\'')
            r5 = nil
          end
          s4 << r5
          if r5
            if has_terminal?(@regexps[gr = '\A[0-7]'] ||= Regexp.new(gr), :regexp, index)
              r6 = true
              @index += 1
            else
              terminal_parse_failure('[0-7]')
              r6 = nil
            end
            s4 << r6
            if r6
              if has_terminal?(@regexps[gr = '\A[0-7]'] ||= Regexp.new(gr), :regexp, index)
                r7 = true
                @index += 1
              else
                terminal_parse_failure('[0-7]')
                r7 = nil
              end
              s4 << r7
              if r7
                if has_terminal?(@regexps[gr = '\A[0-7]'] ||= Regexp.new(gr), :regexp, index)
                  r8 = true
                  @index += 1
                else
                  terminal_parse_failure('[0-7]')
                  r8 = nil
                end
                s4 << r8
              end
            end
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(StringChar1)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            i9, s9 = index, []
            if (match_len = has_terminal?('\\', false, index))
              r10 = true
              @index += match_len
            else
              terminal_parse_failure('\'\\\\\'')
              r10 = nil
            end
            s9 << r10
            if r10
              s11, i11 = [], index
              loop do
                if has_terminal?(@regexps[gr = '\A[\\r]'] ||= Regexp.new(gr), :regexp, index)
                  r12 = true
                  @index += 1
                else
                  terminal_parse_failure('[\\r]')
                  r12 = nil
                end
                if r12
                  s11 << r12
                else
                  break
                end
              end
              r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
              s9 << r11
              if r11
                if has_terminal?(@regexps[gr = '\A[\\n]'] ||= Regexp.new(gr), :regexp, index)
                  r13 = true
                  @index += 1
                else
                  terminal_parse_failure('[\\n]')
                  r13 = nil
                end
                s9 << r13
                if r13
                  s14, i14 = [], index
                  loop do
                    if has_terminal?(@regexps[gr = '\A[\\r]'] ||= Regexp.new(gr), :regexp, index)
                      r15 = true
                      @index += 1
                    else
                      terminal_parse_failure('[\\r]')
                      r15 = nil
                    end
                    if r15
                      s14 << r15
                    else
                      break
                    end
                  end
                  r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
                  s9 << r14
                end
              end
            end
            if s9.last
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              r9.extend(StringChar2)
            else
              @index = i9
              r9 = nil
            end
            if r9
              r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
              r0 = r9
            else
              if (match_len = has_terminal?('\\0', false, index))
                r16 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'\\\\0\'')
                r16 = nil
              end
              if r16
                r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
                r0 = r16
              else
                i17, s17 = index, []
                if (match_len = has_terminal?('\\x', false, index))
                  r18 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'\\\\x\'')
                  r18 = nil
                end
                s17 << r18
                if r18
                  if has_terminal?(@regexps[gr = '\A[0-9A-Fa-f]'] ||= Regexp.new(gr), :regexp, index)
                    r19 = true
                    @index += 1
                  else
                    terminal_parse_failure('[0-9A-Fa-f]')
                    r19 = nil
                  end
                  s17 << r19
                  if r19
                    if has_terminal?(@regexps[gr = '\A[0-9A-Fa-f]'] ||= Regexp.new(gr), :regexp, index)
                      r20 = true
                      @index += 1
                    else
                      terminal_parse_failure('[0-9A-Fa-f]')
                      r20 = nil
                    end
                    s17 << r20
                  end
                end
                if s17.last
                  r17 = instantiate_node(SyntaxNode,input, i17...index, s17)
                  r17.extend(StringChar3)
                else
                  @index = i17
                  r17 = nil
                end
                if r17
                  r17 = SyntaxNode.new(input, (index-1)...index) if r17 == true
                  r0 = r17
                else
                  i21, s21 = index, []
                  if (match_len = has_terminal?('\\u', false, index))
                    r22 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                    @index += match_len
                  else
                    terminal_parse_failure('\'\\\\u\'')
                    r22 = nil
                  end
                  s21 << r22
                  if r22
                    if has_terminal?(@regexps[gr = '\A[0-9A-Fa-f]'] ||= Regexp.new(gr), :regexp, index)
                      r23 = true
                      @index += 1
                    else
                      terminal_parse_failure('[0-9A-Fa-f]')
                      r23 = nil
                    end
                    s21 << r23
                    if r23
                      if has_terminal?(@regexps[gr = '\A[0-9A-Fa-f]'] ||= Regexp.new(gr), :regexp, index)
                        r24 = true
                        @index += 1
                      else
                        terminal_parse_failure('[0-9A-Fa-f]')
                        r24 = nil
                      end
                      s21 << r24
                      if r24
                        if has_terminal?(@regexps[gr = '\A[0-9A-Fa-f]'] ||= Regexp.new(gr), :regexp, index)
                          r25 = true
                          @index += 1
                        else
                          terminal_parse_failure('[0-9A-Fa-f]')
                          r25 = nil
                        end
                        s21 << r25
                        if r25
                          if has_terminal?(@regexps[gr = '\A[0-9A-Fa-f]'] ||= Regexp.new(gr), :regexp, index)
                            r26 = true
                            @index += 1
                          else
                            terminal_parse_failure('[0-9A-Fa-f]')
                            r26 = nil
                          end
                          s21 << r26
                        end
                      end
                    end
                  end
                  if s21.last
                    r21 = instantiate_node(SyntaxNode,input, i21...index, s21)
                    r21.extend(StringChar4)
                  else
                    @index = i21
                    r21 = nil
                  end
                  if r21
                    r21 = SyntaxNode.new(input, (index-1)...index) if r21 == true
                    r0 = r21
                  else
                    i27, s27 = index, []
                    i28 = index
                    if has_terminal?(@regexps[gr = '\A[\\\'\\\\\\0-\\x07\\x0A-\\x1F]'] ||= Regexp.new(gr), :regexp, index)
                      r29 = true
                      @index += 1
                    else
                      terminal_parse_failure('[\\\'\\\\\\0-\\x07\\x0A-\\x1F]')
                      r29 = nil
                    end
                    if r29
                      @index = i28
                      r28 = nil
                      terminal_parse_failure('[\\\'\\\\\\0-\\x07\\x0A-\\x1F]', true)
                    else
                      @terminal_failures.pop
                      @index = i28
                      r28 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s27 << r28
                    if r28
                      if index < input_length
                        r30 = true
                        @index += 1
                      else
                        terminal_parse_failure("any character")
                        r30 = nil
                      end
                      s27 << r30
                    end
                    if s27.last
                      r27 = instantiate_node(SyntaxNode,input, i27...index, s27)
                      r27.extend(StringChar5)
                    else
                      @index = i27
                      r27 = nil
                    end
                    if r27
                      r27 = SyntaxNode.new(input, (index-1)...index) if r27 == true
                      r0 = r27
                    else
                      @index = i0
                      r0 = nil
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:string_char][start_index] = r0

        r0
      end

      module Real0
      end

      def _nt_real
        start_index = index
        if node_cache[:real].has_key?(index)
          cached = node_cache[:real][index]
          if cached
            node_cache[:real][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[-+]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[-+]')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[1-9]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[1-9]')
            r3 = nil
          end
          s0 << r3
          if r3
            s4, i4 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            s0 << r4
            if r4
              r7 = _nt_fraction
              if r7
                r6 = r7
              else
                r6 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r6
              if r6
                r9 = _nt_exponent
                if r9
                  r8 = r9
                else
                  r8 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r8
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Real0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:real][start_index] = r0

        r0
      end

      module FractionalReal0
        def fraction
          elements[2]
        end

      end

      def _nt_fractional_real
        start_index = index
        if node_cache[:fractional_real].has_key?(index)
          cached = node_cache[:fractional_real][index]
          if cached
            node_cache[:fractional_real][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[-+]'] ||= Regexp.new(gr), :regexp, index)
          r2 = true
          @index += 1
        else
          terminal_parse_failure('[-+]')
          r2 = nil
        end
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          if (match_len = has_terminal?('0', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('\'0\'')
            r3 = nil
          end
          s0 << r3
          if r3
            r4 = _nt_fraction
            s0 << r4
            if r4
              r6 = _nt_exponent
              if r6
                r5 = r6
              else
                r5 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r5
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(FractionalReal0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:fractional_real][start_index] = r0

        r0
      end

      module Fraction0
        def radix_point
          elements[0]
        end

      end

      def _nt_fraction
        start_index = index
        if node_cache[:fraction].has_key?(index)
          cached = node_cache[:fraction][index]
          if cached
            node_cache[:fraction][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_radix_point
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[0-9]')
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Fraction0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:fraction][start_index] = r0

        r0
      end

      module Exponent0
      end

      def _nt_exponent
        start_index = index
        if node_cache[:exponent].has_key?(index)
          cached = node_cache[:exponent][index]
          if cached
            node_cache[:exponent][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[Ee]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[-+]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[-+]')
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            s4, i4 = [], index
            loop do
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r5 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            if s4.empty?
              @index = i4
              r4 = nil
            else
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            end
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Exponent0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:exponent][start_index] = r0

        r0
      end

      module Hexnumber0
      end

      def _nt_hexnumber
        start_index = index
        if node_cache[:hexnumber].has_key?(index)
          cached = node_cache[:hexnumber][index]
          if cached
            node_cache[:hexnumber][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('0x', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'0x\'')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[0-9A-Fa-f]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[0-9A-Fa-f]')
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Hexnumber0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:hexnumber][start_index] = r0

        r0
      end

      module Octalnumber0
      end

      def _nt_octalnumber
        start_index = index
        if node_cache[:octalnumber].has_key?(index)
          cached = node_cache[:octalnumber][index]
          if cached
            node_cache[:octalnumber][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('0', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'0\'')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            if has_terminal?(@regexps[gr = '\A[0-7]'] ||= Regexp.new(gr), :regexp, index)
              r3 = true
              @index += 1
            else
              terminal_parse_failure('[0-7]')
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Octalnumber0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:octalnumber][start_index] = r0

        r0
      end

      def _nt_mul_op
        start_index = index
        if node_cache[:mul_op].has_key?(index)
          cached = node_cache[:mul_op][index]
          if cached
            node_cache[:mul_op][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if (match_len = has_terminal?('/', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'/\'')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('%', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('\'%\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            if (match_len = has_terminal?('*', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\'*\'')
              r3 = nil
            end
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:mul_op][start_index] = r0

        r0
      end

      module Id0
        def alpha
          elements[0]
        end

      end

      module Id1
        def value; text_value; end
      end

      def _nt_id
        start_index = index
        if node_cache[:id].has_key?(index)
          cached = node_cache[:id][index]
          if cached
            node_cache[:id][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_alpha
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_alphanumeric
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Id0)
          r0.extend(Id1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:id][start_index] = r0

        r0
      end

      def _nt_alpha
        start_index = index
        if node_cache[:alpha].has_key?(index)
          cached = node_cache[:alpha][index]
          if cached
            node_cache[:alpha][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?(@regexps[gr = '\A[[:alpha:]_]'] ||= Regexp.new(gr), :regexp, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('[[:alpha:]_]')
          r0 = nil
        end

        node_cache[:alpha][start_index] = r0

        r0
      end

      def _nt_alphanumeric
        start_index = index
        if node_cache[:alphanumeric].has_key?(index)
          cached = node_cache[:alphanumeric][index]
          if cached
            node_cache[:alphanumeric][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_alpha
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
            r2 = true
            @index += 1
          else
            terminal_parse_failure('[0-9]')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:alphanumeric][start_index] = r0

        r0
      end

      def _nt_s
        start_index = index
        if node_cache[:s].has_key?(index)
          cached = node_cache[:s][index]
          if cached
            node_cache[:s][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r1 = _nt_S
        if r1
          r0 = r1
        else
          r0 = instantiate_node(SyntaxNode,input, index...index)
        end

        node_cache[:s][start_index] = r0

        r0
      end

      def _nt_S
        start_index = index
        if node_cache[:S].has_key?(index)
          cached = node_cache[:S][index]
          if cached
            node_cache[:S][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1 = index
          r2 = _nt_white
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r1 = r2
          else
            r3 = _nt_comment_to_eol
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r1 = r3
            else
              r4 = _nt_comment_c_style
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r1 = r4
              else
                @index = i1
                r1 = nil
              end
            end
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        end

        node_cache[:S][start_index] = r0

        r0
      end

      def _nt_white
        start_index = index
        if node_cache[:white].has_key?(index)
          cached = node_cache[:white][index]
          if cached
            node_cache[:white][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[ \\t\\n\\r]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[ \\t\\n\\r]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        end

        node_cache[:white][start_index] = r0

        r0
      end

      module CommentToEol0
      end

      module CommentToEol1
      end

      module CommentToEol2
        def node_type; :comment; end
      end

      def _nt_comment_to_eol
        start_index = index
        if node_cache[:comment_to_eol].has_key?(index)
          cached = node_cache[:comment_to_eol][index]
          if cached
            node_cache[:comment_to_eol][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('//', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'//\'')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            i4 = index
            if (match_len = has_terminal?("\n", false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure('"\\n"')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('"\\n"', true)
            else
              @terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s3 << r4
            if r4
              if index < input_length
                r6 = true
                @index += 1
              else
                terminal_parse_failure("any character")
                r6 = nil
              end
              s3 << r6
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(CommentToEol0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CommentToEol1)
          r0.extend(CommentToEol2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:comment_to_eol][start_index] = r0

        r0
      end

      module CommentCStyle0
      end

      module CommentCStyle1
      end

      module CommentCStyle2
        def node_type; :comment; end
      end

      def _nt_comment_c_style
        start_index = index
        if node_cache[:comment_c_style].has_key?(index)
          cached = node_cache[:comment_c_style][index]
          if cached
            node_cache[:comment_c_style][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('/*', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'/*\'')
          r1 = nil
        end
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            i4 = index
            if (match_len = has_terminal?('*/', false, index))
              r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'*/\'')
              r5 = nil
            end
            if r5
              @index = i4
              r4 = nil
              terminal_parse_failure('\'*/\'', true)
            else
              @terminal_failures.pop
              @index = i4
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s3 << r4
            if r4
              if index < input_length
                r6 = true
                @index += 1
              else
                terminal_parse_failure("any character")
                r6 = nil
              end
              s3 << r6
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(CommentCStyle0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            if (match_len = has_terminal?('*/', false, index))
              r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'*/\'')
              r7 = nil
            end
            s0 << r7
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CommentCStyle1)
          r0.extend(CommentCStyle2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:comment_c_style][start_index] = r0

        r0
      end

      module RegularExpression0
        def regular_expression_contents
          elements[2]
        end

      end

      module RegularExpression1
        def contents
          regular_expression_contents.text_value
        end
      end

      def _nt_regular_expression
        start_index = index
        if node_cache[:regular_expression].has_key?(index)
          cached = node_cache[:regular_expression][index]
          if cached
            node_cache[:regular_expression][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('/', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'/\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2 = index
          if (match_len = has_terminal?('/', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('\'/\'')
            r3 = nil
          end
          if r3
            @index = i2
            r2 = nil
            terminal_parse_failure('\'/\'', true)
          else
            @terminal_failures.pop
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r4 = _nt_regular_expression_contents
            s0 << r4
            if r4
              if (match_len = has_terminal?('/', false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('\'/\'')
                r5 = nil
              end
              s0 << r5
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RegularExpression0)
          r0.extend(RegularExpression1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:regular_expression][start_index] = r0

        r0
      end

      module RegularExpressionContents0
        def regular_expression_alternate
          elements[1]
        end
      end

      module RegularExpressionContents1
        def regular_expression_alternate
          elements[0]
        end

      end

      def _nt_regular_expression_contents
        start_index = index
        if node_cache[:regular_expression_contents].has_key?(index)
          cached = node_cache[:regular_expression_contents][index]
          if cached
            node_cache[:regular_expression_contents][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_regular_expression_alternate
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            if (match_len = has_terminal?('|', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\'|\'')
              r4 = nil
            end
            s3 << r4
            if r4
              r5 = _nt_regular_expression_alternate
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(RegularExpressionContents0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RegularExpressionContents1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:regular_expression_contents][start_index] = r0

        r0
      end

      def _nt_regular_expression_alternate
        start_index = index
        if node_cache[:regular_expression_alternate].has_key?(index)
          cached = node_cache[:regular_expression_alternate][index]
          if cached
            node_cache[:regular_expression_alternate][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_regular_expression_sequence

        node_cache[:regular_expression_alternate][start_index] = r0

        r0
      end

      def _nt_regular_expression_sequence
        start_index = index
        if node_cache[:regular_expression_sequence].has_key?(index)
          cached = node_cache[:regular_expression_sequence][index]
          if cached
            node_cache[:regular_expression_sequence][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          r1 = _nt_regular_expression_atom
          if r1
            s0 << r1
          else
            break
          end
        end
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

        node_cache[:regular_expression_sequence][start_index] = r0

        r0
      end

      module RegularExpressionAtom0
        def character_classes
          elements[1]
        end

      end

      module RegularExpressionAtom1
        def string_char
          elements[1]
        end
      end

      module RegularExpressionAtom2
      end

      def _nt_regular_expression_atom
        start_index = index
        if node_cache[:regular_expression_atom].has_key?(index)
          cached = node_cache[:regular_expression_atom][index]
          if cached
            node_cache[:regular_expression_atom][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        i2, s2 = index, []
        if (match_len = has_terminal?('[', false, index))
          r3 = true
          @index += match_len
        else
          terminal_parse_failure('\'[\'')
          r3 = nil
        end
        s2 << r3
        if r3
          r4 = _nt_character_classes
          s2 << r4
          if r4
            if (match_len = has_terminal?(']', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure('\']\'')
              r5 = nil
            end
            s2 << r5
          end
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(RegularExpressionAtom0)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          r6 = _nt_regular_expression_group
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r1 = r6
          else
            i7, s7 = index, []
            i8 = index
            if has_terminal?(@regexps[gr = '\A[*+?()|/]'] ||= Regexp.new(gr), :regexp, index)
              r9 = true
              @index += 1
            else
              terminal_parse_failure('[*+?()|/]')
              r9 = nil
            end
            if r9
              @index = i8
              r8 = nil
              terminal_parse_failure('[*+?()|/]', true)
            else
              @terminal_failures.pop
              @index = i8
              r8 = instantiate_node(SyntaxNode,input, index...index)
            end
            s7 << r8
            if r8
              r10 = _nt_string_char
              s7 << r10
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(RegularExpressionAtom1)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
              r1 = r7
            else
              @index = i1
              r1 = nil
            end
          end
        end
        s0 << r1
        if r1
          r12 = _nt_regular_expression_multiplicity
          if r12
            r11 = r12
          else
            r11 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r11
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RegularExpressionAtom2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:regular_expression_atom][start_index] = r0

        r0
      end

      def _nt_character_classes
        start_index = index
        if node_cache[:character_classes].has_key?(index)
          cached = node_cache[:character_classes][index]
          if cached
            node_cache[:character_classes][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          r1 = _nt_character_class
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        end

        node_cache[:character_classes][start_index] = r0

        r0
      end

      module CharacterClass0
        def string_char1
          elements[1]
        end

        def string_char2
          elements[4]
        end
      end

      module CharacterClass1
        def string_char
          elements[1]
        end
      end

      def _nt_character_class
        start_index = index
        if node_cache[:character_class].has_key?(index)
          cached = node_cache[:character_class][index]
          if cached
            node_cache[:character_class][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        i2 = index
        if (match_len = has_terminal?(']', false, index))
          r3 = true
          @index += match_len
        else
          terminal_parse_failure('\']\'')
          r3 = nil
        end
        if r3
          @index = i2
          r2 = nil
          terminal_parse_failure('\']\'', true)
        else
          @terminal_failures.pop
          @index = i2
          r2 = instantiate_node(SyntaxNode,input, index...index)
        end
        s1 << r2
        if r2
          r4 = _nt_string_char
          s1 << r4
          if r4
            if (match_len = has_terminal?('-', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure('\'-\'')
              r5 = nil
            end
            s1 << r5
            if r5
              i6 = index
              if (match_len = has_terminal?(']', false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('\']\'')
                r7 = nil
              end
              if r7
                @index = i6
                r6 = nil
                terminal_parse_failure('\']\'', true)
              else
                @terminal_failures.pop
                @index = i6
                r6 = instantiate_node(SyntaxNode,input, index...index)
              end
              s1 << r6
              if r6
                r8 = _nt_string_char
                s1 << r8
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(CharacterClass0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('-', false, index))
            r9 = true
            @index += match_len
          else
            terminal_parse_failure('\'-\'')
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
          else
            i10, s10 = index, []
            i11 = index
            if (match_len = has_terminal?(']', false, index))
              r12 = true
              @index += match_len
            else
              terminal_parse_failure('\']\'')
              r12 = nil
            end
            if r12
              @index = i11
              r11 = nil
              terminal_parse_failure('\']\'', true)
            else
              @terminal_failures.pop
              @index = i11
              r11 = instantiate_node(SyntaxNode,input, index...index)
            end
            s10 << r11
            if r11
              r13 = _nt_string_char
              s10 << r13
            end
            if s10.last
              r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
              r10.extend(CharacterClass1)
            else
              @index = i10
              r10 = nil
            end
            if r10
              r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
              r0 = r10
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:character_class][start_index] = r0

        r0
      end

      def _nt_regular_expression_multiplicity
        start_index = index
        if node_cache[:regular_expression_multiplicity].has_key?(index)
          cached = node_cache[:regular_expression_multiplicity][index]
          if cached
            node_cache[:regular_expression_multiplicity][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if (match_len = has_terminal?('*', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'*\'')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('+', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('\'+\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            if (match_len = has_terminal?('?', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\'?\'')
              r3 = nil
            end
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:regular_expression_multiplicity][start_index] = r0

        r0
      end

      module RegularExpressionGroup0
        def regular_expression_contents
          elements[2]
        end

      end

      def _nt_regular_expression_group
        start_index = index
        if node_cache[:regular_expression_group].has_key?(index)
          cached = node_cache[:regular_expression_group][index]
          if cached
            node_cache[:regular_expression_group][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('(', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'(\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r3 = _nt_regular_expression_group_extension
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r4 = _nt_regular_expression_contents
            s0 << r4
            if r4
              if (match_len = has_terminal?(')', false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('\')\'')
                r5 = nil
              end
              s0 << r5
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RegularExpressionGroup0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:regular_expression_group][start_index] = r0

        r0
      end

      module RegularExpressionGroupExtension0
      end

      module RegularExpressionGroupExtension1
      end

      module RegularExpressionGroupExtension2
      end

      def _nt_regular_expression_group_extension
        start_index = index
        if node_cache[:regular_expression_group_extension].has_key?(index)
          cached = node_cache[:regular_expression_group_extension][index]
          if cached
            node_cache[:regular_expression_group_extension][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('?', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'?\'')
          r1 = nil
        end
        s0 << r1
        if r1
          i2, s2 = index, []
          if (match_len = has_terminal?('<', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('\'<\'')
            r3 = nil
          end
          s2 << r3
          if r3
            s4, i4 = [], index
            loop do
              i5, s5 = index, []
              i6 = index
              if (match_len = has_terminal?('>', false, index))
                r7 = true
                @index += match_len
              else
                terminal_parse_failure('\'>\'')
                r7 = nil
              end
              if r7
                @index = i6
                r6 = nil
                terminal_parse_failure('\'>\'', true)
              else
                @terminal_failures.pop
                @index = i6
                r6 = instantiate_node(SyntaxNode,input, index...index)
              end
              s5 << r6
              if r6
                if index < input_length
                  r8 = true
                  @index += 1
                else
                  terminal_parse_failure("any character")
                  r8 = nil
                end
                s5 << r8
              end
              if s5.last
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                r5.extend(RegularExpressionGroupExtension0)
              else
                @index = i5
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            if s4.empty?
              @index = i4
              r4 = nil
            else
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            end
            s2 << r4
            if r4
              if (match_len = has_terminal?('>', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('\'>\'')
                r9 = nil
              end
              s2 << r9
            end
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(RegularExpressionGroupExtension1)
          else
            @index = i2
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RegularExpressionGroupExtension2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:regular_expression_group_extension][start_index] = r0

        r0
      end

    end

    class LexicalRulesParser < Treetop::Runtime::CompiledParser
      include LexicalRules
    end

  end
end
