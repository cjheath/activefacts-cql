#
# Autogenerated from a Treetop grammar. Edits may be lost.


#       ActiveFacts CQL Parser.
#       Parse rules relating to ValueType definitions.
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
module ActiveFacts
  module CQL
    module ValueTypes
      include Treetop::Runtime

      def root
        @root ||= :value_type
      end

      module ValueType0
        def value_constraint
          elements[0]
        end

        def enforcement
          elements[1]
        end
      end

      module ValueType1
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def term_definition_name
          elements[3]
        end

        def m1
          elements[4]
        end

        def written_as
          elements[5]
        end

        def s3
          elements[7]
        end

        def base
          elements[8]
        end

        def s4
          elements[9]
        end

        def value_type_parameters
          elements[10]
        end

        def u
          elements[11]
        end

        def a
          elements[12]
        end

        def c
          elements[13]
        end

        def r
          elements[14]
        end

        def m2
          elements[15]
        end

        def c2
          elements[16]
        end

        def s5
          elements[17]
        end

        def s6
          elements[19]
        end
      end

      module ValueType2
        def ast
          name = term_definition_name.value
          params = value_type_parameters.values
          value_constraint = nil
          unless r.empty? 
            value_constraint = Compiler::ValueConstraint.new(r.value_constraint.ast, r.enforcement.ast)
          end
          units = u.empty? ? [] : u.units.value
          auto_assigned_at = a.empty? ? nil : a.auto_assigned_at
          pragmas = m1.value+m2.value
          context_note = !c.empty? ? c.ast : (!c2.empty? ? c2.ast : nil)
          Compiler::ValueType.new name, base.value, params, units, value_constraint, pragmas, context_note, auto_assigned_at
        end
      end

      def _nt_value_type
        start_index = index
        if node_cache[:value_type].has_key?(index)
          cached = node_cache[:value_type][index]
          if cached
            node_cache[:value_type][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r3 = _nt_each
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r4 = _nt_s
            s0 << r4
            if r4
              r5 = _nt_term_definition_name
              s0 << r5
              if r5
                r6 = _nt_mapping_pragmas
                s0 << r6
                if r6
                  r7 = _nt_written_as
                  s0 << r7
                  if r7
                    r9 = _nt_any
                    if r9
                      r8 = r9
                    else
                      r8 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s0 << r8
                    if r8
                      r10 = _nt_s
                      s0 << r10
                      if r10
                        i11 = index
                        r12 = _nt_term
                        if r12
                          r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                          r11 = r12
                        else
                          r13 = _nt_implicit_value_type_name
                          if r13
                            r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                            r11 = r13
                          else
                            @index = i11
                            r11 = nil
                          end
                        end
                        s0 << r11
                        if r11
                          r14 = _nt_s
                          s0 << r14
                          if r14
                            r15 = _nt_value_type_parameters
                            s0 << r15
                            if r15
                              r17 = _nt_in_units
                              if r17
                                r16 = r17
                              else
                                r16 = instantiate_node(SyntaxNode,input, index...index)
                              end
                              s0 << r16
                              if r16
                                r19 = _nt_auto_assignment
                                if r19
                                  r18 = r19
                                else
                                  r18 = instantiate_node(SyntaxNode,input, index...index)
                                end
                                s0 << r18
                                if r18
                                  r21 = _nt_context_note
                                  if r21
                                    r20 = r21
                                  else
                                    r20 = instantiate_node(SyntaxNode,input, index...index)
                                  end
                                  s0 << r20
                                  if r20
                                    i23, s23 = index, []
                                    r24 = _nt_value_constraint
                                    s23 << r24
                                    if r24
                                      r25 = _nt_enforcement
                                      s23 << r25
                                    end
                                    if s23.last
                                      r23 = instantiate_node(SyntaxNode,input, i23...index, s23)
                                      r23.extend(ValueType0)
                                    else
                                      @index = i23
                                      r23 = nil
                                    end
                                    if r23
                                      r22 = r23
                                    else
                                      r22 = instantiate_node(SyntaxNode,input, index...index)
                                    end
                                    s0 << r22
                                    if r22
                                      r26 = _nt_mapping_pragmas
                                      s0 << r26
                                      if r26
                                        r28 = _nt_context_note
                                        if r28
                                          r27 = r28
                                        else
                                          r27 = instantiate_node(SyntaxNode,input, index...index)
                                        end
                                        s0 << r27
                                        if r27
                                          r29 = _nt_s
                                          s0 << r29
                                          if r29
                                            if (match_len = has_terminal?(';', false, index))
                                              r30 = true
                                              @index += match_len
                                            else
                                              terminal_parse_failure('\';\'')
                                              r30 = nil
                                            end
                                            s0 << r30
                                            if r30
                                              r31 = _nt_s
                                              s0 << r31
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ValueType1)
          r0.extend(ValueType2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:value_type][start_index] = r0

        r0
      end

      module InUnits0
        def in
          elements[0]
        end

        def S
          elements[1]
        end

        def units
          elements[2]
        end
      end

      def _nt_in_units
        start_index = index
        if node_cache[:in_units].has_key?(index)
          cached = node_cache[:in_units][index]
          if cached
            node_cache[:in_units][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_in
        s0 << r1
        if r1
          r2 = _nt_S
          s0 << r2
          if r2
            r3 = _nt_units
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(InUnits0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:in_units][start_index] = r0

        r0
      end

      module ImplicitValueTypeName0
        def node_type; :term; end
      end

      def _nt_implicit_value_type_name
        start_index = index
        if node_cache[:implicit_value_type_name].has_key?(index)
          cached = node_cache[:implicit_value_type_name][index]
          if cached
            node_cache[:implicit_value_type_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_id
        r0.extend(ImplicitValueTypeName0)
        r0.extend(ImplicitValueTypeName0)

        node_cache[:implicit_value_type_name][start_index] = r0

        r0
      end

      module ValueTypeParameters0
        def s1
          elements[1]
        end

        def tpl
          elements[2]
        end

        def s2
          elements[4]
        end
      end

      module ValueTypeParameters1
        def values; tpl.empty? ? [] : tpl.values; end
      end

      module ValueTypeParameters2
        def values; []; end
      end

      def _nt_value_type_parameters
        start_index = index
        if node_cache[:value_type_parameters].has_key?(index)
          cached = node_cache[:value_type_parameters][index]
          if cached
            node_cache[:value_type_parameters][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        if (match_len = has_terminal?('(', false, index))
          r2 = true
          @index += match_len
        else
          terminal_parse_failure('\'(\'')
          r2 = nil
        end
        s1 << r2
        if r2
          r3 = _nt_s
          s1 << r3
          if r3
            r5 = _nt_type_parameter_list
            if r5
              r4 = r5
            else
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s1 << r4
            if r4
              if (match_len = has_terminal?(')', false, index))
                r6 = true
                @index += match_len
              else
                terminal_parse_failure('\')\'')
                r6 = nil
              end
              s1 << r6
              if r6
                r7 = _nt_s
                s1 << r7
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(ValueTypeParameters0)
          r1.extend(ValueTypeParameters1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r8 = _nt_s
          r8.extend(ValueTypeParameters2)
          r8.extend(ValueTypeParameters2)
          if r8
            r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
            r0 = r8
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:value_type_parameters][start_index] = r0

        r0
      end

      module TypeParameterList0
        def s1
          elements[1]
        end

        def number
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module TypeParameterList1
        def head
          elements[0]
        end

        def s
          elements[1]
        end

        def tail
          elements[2]
        end
      end

      module TypeParameterList2
        def values
          [head.value, *tail.elements.map{|i| i.number.value}]
        end
      end

      def _nt_type_parameter_list
        start_index = index
        if node_cache[:type_parameter_list].has_key?(index)
          cached = node_cache[:type_parameter_list][index]
          if cached
            node_cache[:type_parameter_list][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_number
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4, s4 = index, []
              if (match_len = has_terminal?(',', false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('\',\'')
                r5 = nil
              end
              s4 << r5
              if r5
                r6 = _nt_s
                s4 << r6
                if r6
                  r7 = _nt_number
                  s4 << r7
                  if r7
                    r8 = _nt_s
                    s4 << r8
                  end
                end
              end
              if s4.last
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
                r4.extend(TypeParameterList0)
              else
                @index = i4
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TypeParameterList1)
          r0.extend(TypeParameterList2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:type_parameter_list][start_index] = r0

        r0
      end

      module UnitDefinition0
        def s1
          elements[1]
        end

        def p
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module UnitDefinition1
        def s1
          elements[0]
        end

        def coeff
          elements[1]
        end

        def base
          elements[2]
        end

        def s2
          elements[3]
        end

        def o
          elements[4]
        end

        def conversion
          elements[5]
        end

        def singular
          elements[6]
        end

        def s3
          elements[7]
        end

        def plural
          elements[8]
        end
      end

      module UnitDefinition2
        def s1
          elements[1]
        end

        def p
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module UnitDefinition3
        def s1
          elements[0]
        end

        def singular
          elements[1]
        end

        def s2
          elements[2]
        end

        def plural
          elements[3]
        end

        def conversion
          elements[4]
        end

        def coeff
          elements[5]
        end

        def base
          elements[6]
        end

        def s3
          elements[7]
        end

        def o
          elements[8]
        end
      end

      module UnitDefinition4
        def approximately
          elements[0]
        end

      end

      module UnitDefinition5
        def ephemera
          elements[0]
        end

        def s
          elements[1]
        end

        def url
          elements[2]
        end
      end

      module UnitDefinition6
        def u
          elements[0]
        end

        def q
          elements[1]
        end

        def s
          elements[2]
        end

      end

      module UnitDefinition7
        def ast
          singular = u.singular.text_value
          plural = u.plural.text_value.empty? ? nil : u.plural.p.text_value 
          if u.coeff.empty?
            raise "Unit definition requires either a coefficient or an ephemera URL" unless q.respond_to?(:ephemera)
            numerator,denominator = 1, 1
          else
            numerator, denominator = *u.coeff.ast
          end
          offset = u.o.text_value.empty? ? 0 : u.o.value
          bases = u.base.empty? ? [] : u.base.value
          approximately = q.respond_to?(:approximately) || u.conversion.approximate?
          ephemera = q.respond_to?(:ephemera) ? q.url.text_value : nil
          Compiler::Unit.new singular, plural, numerator, denominator, offset, bases, approximately, ephemera
        end
      end

      def _nt_unit_definition
        start_index = index
        if node_cache[:unit_definition].has_key?(index)
          cached = node_cache[:unit_definition][index]
          if cached
            node_cache[:unit_definition][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        i2, s2 = index, []
        r3 = _nt_s
        s2 << r3
        if r3
          r5 = _nt_unit_coefficient
          if r5
            r4 = r5
          else
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s2 << r4
          if r4
            r7 = _nt_units
            if r7
              r6 = r7
            else
              r6 = instantiate_node(SyntaxNode,input, index...index)
            end
            s2 << r6
            if r6
              r8 = _nt_s
              s2 << r8
              if r8
                r10 = _nt_unit_offset
                if r10
                  r9 = r10
                else
                  r9 = instantiate_node(SyntaxNode,input, index...index)
                end
                s2 << r9
                if r9
                  r11 = _nt_conversion
                  s2 << r11
                  if r11
                    r12 = _nt_unit_name
                    s2 << r12
                    if r12
                      r13 = _nt_s
                      s2 << r13
                      if r13
                        i15, s15 = index, []
                        if (match_len = has_terminal?('/', false, index))
                          r16 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'/\'')
                          r16 = nil
                        end
                        s15 << r16
                        if r16
                          r17 = _nt_s
                          s15 << r17
                          if r17
                            r18 = _nt_unit_name
                            s15 << r18
                            if r18
                              r19 = _nt_s
                              s15 << r19
                            end
                          end
                        end
                        if s15.last
                          r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
                          r15.extend(UnitDefinition0)
                        else
                          @index = i15
                          r15 = nil
                        end
                        if r15
                          r14 = r15
                        else
                          r14 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s2 << r14
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(UnitDefinition1)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
          r1 = r2
        else
          i20, s20 = index, []
          r21 = _nt_s
          s20 << r21
          if r21
            r22 = _nt_unit_name
            s20 << r22
            if r22
              r23 = _nt_s
              s20 << r23
              if r23
                i25, s25 = index, []
                if (match_len = has_terminal?('/', false, index))
                  r26 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'/\'')
                  r26 = nil
                end
                s25 << r26
                if r26
                  r27 = _nt_s
                  s25 << r27
                  if r27
                    r28 = _nt_unit_name
                    s25 << r28
                    if r28
                      r29 = _nt_s
                      s25 << r29
                    end
                  end
                end
                if s25.last
                  r25 = instantiate_node(SyntaxNode,input, i25...index, s25)
                  r25.extend(UnitDefinition2)
                else
                  @index = i25
                  r25 = nil
                end
                if r25
                  r24 = r25
                else
                  r24 = instantiate_node(SyntaxNode,input, index...index)
                end
                s20 << r24
                if r24
                  r30 = _nt_conversion
                  s20 << r30
                  if r30
                    r32 = _nt_unit_coefficient
                    if r32
                      r31 = r32
                    else
                      r31 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s20 << r31
                    if r31
                      r34 = _nt_units
                      if r34
                        r33 = r34
                      else
                        r33 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s20 << r33
                      if r33
                        r35 = _nt_s
                        s20 << r35
                        if r35
                          r37 = _nt_unit_offset
                          if r37
                            r36 = r37
                          else
                            r36 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s20 << r36
                        end
                      end
                    end
                  end
                end
              end
            end
          end
          if s20.last
            r20 = instantiate_node(SyntaxNode,input, i20...index, s20)
            r20.extend(UnitDefinition3)
          else
            @index = i20
            r20 = nil
          end
          if r20
            r20 = SyntaxNode.new(input, (index-1)...index) if r20 == true
            r1 = r20
          else
            @index = i1
            r1 = nil
          end
        end
        s0 << r1
        if r1
          i39 = index
          i40, s40 = index, []
          r41 = _nt_approximately
          s40 << r41
          if r41
            if (match_len = has_terminal?('', false, index))
              r42 = true
              @index += match_len
            else
              terminal_parse_failure('\'\'')
              r42 = nil
            end
            s40 << r42
          end
          if s40.last
            r40 = instantiate_node(SyntaxNode,input, i40...index, s40)
            r40.extend(UnitDefinition4)
          else
            @index = i40
            r40 = nil
          end
          if r40
            r40 = SyntaxNode.new(input, (index-1)...index) if r40 == true
            r39 = r40
          else
            i43, s43 = index, []
            r44 = _nt_ephemera
            s43 << r44
            if r44
              r45 = _nt_s
              s43 << r45
              if r45
                r46 = _nt_url
                s43 << r46
              end
            end
            if s43.last
              r43 = instantiate_node(SyntaxNode,input, i43...index, s43)
              r43.extend(UnitDefinition5)
            else
              @index = i43
              r43 = nil
            end
            if r43
              r43 = SyntaxNode.new(input, (index-1)...index) if r43 == true
              r39 = r43
            else
              @index = i39
              r39 = nil
            end
          end
          if r39
            r38 = r39
          else
            r38 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r38
          if r38
            r47 = _nt_s
            s0 << r47
            if r47
              if (match_len = has_terminal?(';', false, index))
                r48 = true
                @index += match_len
              else
                terminal_parse_failure('\';\'')
                r48 = nil
              end
              s0 << r48
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UnitDefinition6)
          r0.extend(UnitDefinition7)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:unit_definition][start_index] = r0

        r0
      end

      module UnitName0
        def node_type; :unit; end
      end

      def _nt_unit_name
        start_index = index
        if node_cache[:unit_name].has_key?(index)
          cached = node_cache[:unit_name][index]
          if cached
            node_cache[:unit_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_id
        r0.extend(UnitName0)
        r0.extend(UnitName0)

        node_cache[:unit_name][start_index] = r0

        r0
      end

      module UnitCoefficient0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def number
          elements[3]
        end
      end

      module UnitCoefficient1
        def numerator
          elements[0]
        end

        def denominator
          elements[1]
        end

        def s
          elements[2]
        end
      end

      module UnitCoefficient2
        def ast
          [ numerator.text_value,
            (denominator.text_value.empty? ? "1" : denominator.number.text_value)
          ]
        end
      end

      def _nt_unit_coefficient
        start_index = index
        if node_cache[:unit_coefficient].has_key?(index)
          cached = node_cache[:unit_coefficient][index]
          if cached
            node_cache[:unit_coefficient][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_number
        s0 << r1
        if r1
          i3, s3 = index, []
          r4 = _nt_s
          s3 << r4
          if r4
            if (match_len = has_terminal?('/', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure('\'/\'')
              r5 = nil
            end
            s3 << r5
            if r5
              r6 = _nt_s
              s3 << r6
              if r6
                r7 = _nt_number
                s3 << r7
              end
            end
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(UnitCoefficient0)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r8 = _nt_s
            s0 << r8
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UnitCoefficient1)
          r0.extend(UnitCoefficient2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:unit_coefficient][start_index] = r0

        r0
      end

      module UnitOffset0
        def sign
          elements[0]
        end

        def s1
          elements[1]
        end

        def number
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module UnitOffset1
        def value
                   sign.text_value == '-' ? "-"+number.text_value : number.text_value
                 end
      end

      def _nt_unit_offset
        start_index = index
        if node_cache[:unit_offset].has_key?(index)
          cached = node_cache[:unit_offset][index]
          if cached
            node_cache[:unit_offset][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[-+]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[-+]')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_number
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UnitOffset0)
          r0.extend(UnitOffset1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:unit_offset][start_index] = r0

        r0
      end

      module Units0
        def maybe_unit
          elements[1]
        end

        def s
          elements[2]
        end
      end

      module Units1
        def maybe_unit
          elements[1]
        end

        def s
          elements[2]
        end
      end

      module Units2
        def s1
          elements[1]
        end

        def maybe_unit
          elements[2]
        end

        def s2
          elements[3]
        end

        def tail
          elements[4]
        end
      end

      module Units3
        def maybe_unit
          elements[1]
        end

        def s
          elements[2]
        end

        def tail
          elements[3]
        end

        def div
          elements[4]
        end
      end

      module Units4
        def value
                   tail.elements.inject([maybe_unit.value]) { |a, e| a << e.maybe_unit.value } +
                     (div.text_value.empty? ? [] : div.tail.elements.inject([div.maybe_unit.inverse]) { |a, e| a << e.maybe_unit.inverse })
                 end
      end

      def _nt_units
        start_index = index
        if node_cache[:units].has_key?(index)
          cached = node_cache[:units][index]
          if cached
            node_cache[:units][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        i1 = index
        r2 = _nt_non_unit
        if r2
          @index = i1
          r1 = nil
        else
          @index = i1
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r3 = _nt_maybe_unit
          s0 << r3
          if r3
            r4 = _nt_s
            s0 << r4
            if r4
              s5, i5 = [], index
              loop do
                i6, s6 = index, []
                i7 = index
                r8 = _nt_non_unit
                if r8
                  @index = i7
                  r7 = nil
                else
                  @index = i7
                  r7 = instantiate_node(SyntaxNode,input, index...index)
                end
                s6 << r7
                if r7
                  r9 = _nt_maybe_unit
                  s6 << r9
                  if r9
                    r10 = _nt_s
                    s6 << r10
                  end
                end
                if s6.last
                  r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                  r6.extend(Units0)
                else
                  @index = i6
                  r6 = nil
                end
                if r6
                  s5 << r6
                else
                  break
                end
              end
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              s0 << r5
              if r5
                i12, s12 = index, []
                if (match_len = has_terminal?('/', false, index))
                  r13 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'/\'')
                  r13 = nil
                end
                s12 << r13
                if r13
                  r14 = _nt_s
                  s12 << r14
                  if r14
                    r15 = _nt_maybe_unit
                    s12 << r15
                    if r15
                      r16 = _nt_s
                      s12 << r16
                      if r16
                        s17, i17 = [], index
                        loop do
                          i18, s18 = index, []
                          i19 = index
                          r20 = _nt_non_unit
                          if r20
                            @index = i19
                            r19 = nil
                          else
                            @index = i19
                            r19 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s18 << r19
                          if r19
                            r21 = _nt_maybe_unit
                            s18 << r21
                            if r21
                              r22 = _nt_s
                              s18 << r22
                            end
                          end
                          if s18.last
                            r18 = instantiate_node(SyntaxNode,input, i18...index, s18)
                            r18.extend(Units1)
                          else
                            @index = i18
                            r18 = nil
                          end
                          if r18
                            s17 << r18
                          else
                            break
                          end
                        end
                        r17 = instantiate_node(SyntaxNode,input, i17...index, s17)
                        s12 << r17
                      end
                    end
                  end
                end
                if s12.last
                  r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
                  r12.extend(Units2)
                else
                  @index = i12
                  r12 = nil
                end
                if r12
                  r11 = r12
                else
                  r11 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r11
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Units3)
          r0.extend(Units4)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:units][start_index] = r0

        r0
      end

      def _nt_non_unit
        start_index = index
        if node_cache[:non_unit].has_key?(index)
          cached = node_cache[:non_unit][index]
          if cached
            node_cache[:non_unit][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_restricted_to
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_conversion
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_approximately
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_ephemera
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                r5 = _nt_auto_assignment
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end

        node_cache[:non_unit][start_index] = r0

        r0
      end

      module Unit0
        def maybe_unit
          elements[0]
        end

      end

      def _nt_unit
        start_index = index
        if node_cache[:unit].has_key?(index)
          cached = node_cache[:unit][index]
          if cached
            node_cache[:unit][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_maybe_unit
        s0 << r1
        if r1
          i2 = index
          r3 = lambda {|s| input.context.unit?(s[0].unit_name.text_value) }.call(s0)
          if !r3
            terminal_parse_failure("<semantic predicate>")
          end
          if r3
            @index = i2
            r2 = instantiate_node(SyntaxNode,input, index...index)
          else
            @index = i2
            r2 = nil
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Unit0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:unit][start_index] = r0

        r0
      end

      module MaybeUnit0
      end

      module MaybeUnit1
        def unit_name
          elements[0]
        end

        def pow
          elements[1]
        end
      end

      module MaybeUnit2
        def value
                   [unit_name.text_value, pow.text_value.empty? ? 1 : Integer(pow.text_value[1..-1])]
                 end
                 def inverse
                   a = value
                   a[1] = -a[1]
                   a
                 end
      end

      def _nt_maybe_unit
        start_index = index
        if node_cache[:maybe_unit].has_key?(index)
          cached = node_cache[:maybe_unit][index]
          if cached
            node_cache[:maybe_unit][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_unit_name
        s0 << r1
        if r1
          i3, s3 = index, []
          if (match_len = has_terminal?('^', false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('\'^\'')
            r4 = nil
          end
          s3 << r4
          if r4
            if (match_len = has_terminal?('-', false, index))
              r6 = true
              @index += match_len
            else
              terminal_parse_failure('\'-\'')
              r6 = nil
            end
            if r6
              r5 = r6
            else
              r5 = instantiate_node(SyntaxNode,input, index...index)
            end
            s3 << r5
            if r5
              if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                r7 = true
                @index += 1
              else
                terminal_parse_failure('[0-9]')
                r7 = nil
              end
              s3 << r7
            end
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(MaybeUnit0)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MaybeUnit1)
          r0.extend(MaybeUnit2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:maybe_unit][start_index] = r0

        r0
      end

      module ValueConstraint0
        def restricted_to
          elements[0]
        end

        def restricted_values
          elements[1]
        end

        def c
          elements[2]
        end
      end

      module ValueConstraint1
        def ast
          v = restricted_values.values
          c[:context_note] = c.ast unless c.empty?
          v
        end
      end

      def _nt_value_constraint
        start_index = index
        if node_cache[:value_constraint].has_key?(index)
          cached = node_cache[:value_constraint][index]
          if cached
            node_cache[:value_constraint][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_restricted_to
        s0 << r1
        if r1
          r2 = _nt_restricted_values
          s0 << r2
          if r2
            r4 = _nt_context_note
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ValueConstraint0)
          r0.extend(ValueConstraint1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:value_constraint][start_index] = r0

        r0
      end

      module RestrictedValues0
        def range_list
          elements[0]
        end

        def s
          elements[1]
        end

        def u
          elements[2]
        end
      end

      module RestrictedValues1
        def values
          { :ranges => range_list.ranges,
            :units => u.empty? ? nil : u.value
          }
        end
      end

      module RestrictedValues2
        def values
          { :regular_expression => contents }
        end
      end

      def _nt_restricted_values
        start_index = index
        if node_cache[:restricted_values].has_key?(index)
          cached = node_cache[:restricted_values][index]
          if cached
            node_cache[:restricted_values][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_range_list
        s1 << r2
        if r2
          r3 = _nt_s
          s1 << r3
          if r3
            r5 = _nt_units
            if r5
              r4 = r5
            else
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s1 << r4
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(RestrictedValues0)
          r1.extend(RestrictedValues1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r6 = _nt_regular_expression
          r6.extend(RestrictedValues2)
          r6.extend(RestrictedValues2)
          if r6
            r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
            r0 = r6
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:restricted_values][start_index] = r0

        r0
      end

      module RangeList0
        def s
          elements[1]
        end

        def range
          elements[2]
        end
      end

      module RangeList1
        def s1
          elements[1]
        end

        def head
          elements[2]
        end

        def s2
          elements[3]
        end

        def tail
          elements[4]
        end

        def s3
          elements[6]
        end
      end

      module RangeList2
        def ranges
          [head.value, *tail.elements.map{|e| e.range.value }]
        end
      end

      def _nt_range_list
        start_index = index
        if node_cache[:range_list].has_key?(index)
          cached = node_cache[:range_list][index]
          if cached
            node_cache[:range_list][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('{', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'{\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_range
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                s5, i5 = [], index
                loop do
                  i6, s6 = index, []
                  if (match_len = has_terminal?(',', false, index))
                    r7 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\',\'')
                    r7 = nil
                  end
                  s6 << r7
                  if r7
                    r8 = _nt_s
                    s6 << r8
                    if r8
                      r9 = _nt_range
                      s6 << r9
                    end
                  end
                  if s6.last
                    r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                    r6.extend(RangeList0)
                  else
                    @index = i6
                    r6 = nil
                  end
                  if r6
                    s5 << r6
                  else
                    break
                  end
                end
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                s0 << r5
                if r5
                  if (match_len = has_terminal?('}', false, index))
                    r10 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'}\'')
                    r10 = nil
                  end
                  s0 << r10
                  if r10
                    r11 = _nt_s
                    s0 << r11
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RangeList1)
          r0.extend(RangeList2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:range_list][start_index] = r0

        r0
      end

    end

    class ValueTypesParser < Treetop::Runtime::CompiledParser
      include ValueTypes
    end

  end
end
