#
# Autogenerated from a Treetop grammar. Edits may be lost.


#       ActiveFacts CQL Parser.
#       Parse rules relating to FactType definitions.
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
module ActiveFacts
  module CQL
    module FactTypes
      include Treetop::Runtime

      def root
        @root ||= :query
      end

      module Query0
        def s
          elements[0]
        end

        def query_clauses
          elements[1]
        end

        def r
          elements[2]
        end

      end

      module Query1
        def ast
          Compiler::FactType.new nil, [], query_clauses.ast, (r.empty? ? nil : r)
        end
      end

      def _nt_query
        start_index = index
        if node_cache[:query].has_key?(index)
          cached = node_cache[:query][index]
          if cached
            node_cache[:query][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_query_clauses
          s0 << r2
          if r2
            r4 = _nt_returning_clause
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
            if r3
              if (match_len = has_terminal?('?', false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('\'?\'')
                r5 = nil
              end
              s0 << r5
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Query0)
          r0.extend(Query1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:query][start_index] = r0

        r0
      end

      module NamedFactType0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def term_definition_name
          elements[3]
        end

        def mapping_pragmas
          elements[4]
        end

        def is_where
          elements[5]
        end

        def anonymous_fact_type
          elements[6]
        end
      end

      module NamedFactType1
        def ast
          ft = anonymous_fact_type.ast
          ft.name = term_definition_name.value
          pragmas = mapping_pragmas.value
          pragmas << 'independent' if is_where.independent
          ft.pragmas = pragmas
          ft
        end
      end

      def _nt_named_fact_type
        start_index = index
        if node_cache[:named_fact_type].has_key?(index)
          cached = node_cache[:named_fact_type][index]
          if cached
            node_cache[:named_fact_type][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r3 = _nt_each
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r4 = _nt_s
            s0 << r4
            if r4
              r5 = _nt_term_definition_name
              s0 << r5
              if r5
                r6 = _nt_mapping_pragmas
                s0 << r6
                if r6
                  r7 = _nt_is_where
                  s0 << r7
                  if r7
                    r8 = _nt_anonymous_fact_type
                    s0 << r8
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NamedFactType0)
          r0.extend(NamedFactType1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:named_fact_type][start_index] = r0

        r0
      end

      module AnonymousFactType0
        def s1
          elements[1]
        end

        def a
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module AnonymousFactType1
        def query_clauses
          elements[0]
        end

        def ctail
          elements[1]
        end

        def s
          elements[3]
        end

      end

      module AnonymousFactType2
        def ast
          clauses_ast = query_clauses.ast
          conditions = !ctail.empty? ? ctail.a.ast : []
          returning = respond_to?(:returning_clause) ? returning_clause.ast : nil
          value_derivation = clauses_ast.detect{|r| r.is_equality_comparison}
          if !value_derivation and
              conditions.empty? and
              clauses_ast.detect{|r| r.includes_literals}
            raise "Fact instances may not contain conditions" unless conditions.empty? && !returning
            Compiler::Fact.new clauses_ast
          elsif (clauses_ast.size == 1 &&
            clauses_ast[0].phrases.size == 1 &&
            (popname = clauses_ast[0].phrases[0]) &&
            !popname.is_a?(Compiler::Reference) &&
            conditions.detect{|r| r.includes_literals}
          )
            Compiler::Fact.new conditions, popname
          else
            Compiler::FactType.new nil, clauses_ast, conditions, returning
          end
        end
      end

      def _nt_anonymous_fact_type
        start_index = index
        if node_cache[:anonymous_fact_type].has_key?(index)
          cached = node_cache[:anonymous_fact_type][index]
          if cached
            node_cache[:anonymous_fact_type][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_query_clauses
        s0 << r1
        if r1
          i3, s3 = index, []
          i4 = index
          if (match_len = has_terminal?(':', false, index))
            r5 = true
            @index += match_len
          else
            terminal_parse_failure('\':\'')
            r5 = nil
          end
          if r5
            r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
            r4 = r5
          else
            r6 = _nt_where
            if r6
              r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
              r4 = r6
            else
              @index = i4
              r4 = nil
            end
          end
          s3 << r4
          if r4
            r7 = _nt_s
            s3 << r7
            if r7
              r8 = _nt_query_clauses
              s3 << r8
              if r8
                r9 = _nt_s
                s3 << r9
              end
            end
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(AnonymousFactType0)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r11 = _nt_returning_clause
            if r11
              r10 = r11
            else
              r10 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r10
            if r10
              r12 = _nt_s
              s0 << r12
              if r12
                if (match_len = has_terminal?(';', false, index))
                  r13 = true
                  @index += match_len
                else
                  terminal_parse_failure('\';\'')
                  r13 = nil
                end
                s0 << r13
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AnonymousFactType1)
          r0.extend(AnonymousFactType2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:anonymous_fact_type][start_index] = r0

        r0
      end

      module QueryClauses0
        def conjunction
          elements[0]
        end

        def s1
          elements[1]
        end

        def qualified_clauses
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module QueryClauses1
        def qualified_clauses
          elements[0]
        end

        def ftail
          elements[1]
        end
      end

      module QueryClauses2
        def ast
          clauses_ast = qualified_clauses.ast
          ftail.elements.each{|e|
            conjunction = e.conjunction.text_value
            # conjunction = 'and' if conjunction == ','   # ',' means AND, but disallows left-contractions
            clauses_ast += e.qualified_clauses.ast(conjunction)
          }
          clauses_ast
        end
      end

      def _nt_query_clauses
        start_index = index
        if node_cache[:query_clauses].has_key?(index)
          cached = node_cache[:query_clauses][index]
          if cached
            node_cache[:query_clauses][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_qualified_clauses
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            i4 = index
            if (match_len = has_terminal?(',', false, index))
              r5 = true
              @index += match_len
            else
              terminal_parse_failure('\',\'')
              r5 = nil
            end
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r4 = r5
            else
              r6 = _nt_and
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r4 = r6
              else
                r7 = _nt_or
                if r7
                  r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                  r4 = r7
                else
                  @index = i4
                  r4 = nil
                end
              end
            end
            s3 << r4
            if r4
              r8 = _nt_s
              s3 << r8
              if r8
                r9 = _nt_qualified_clauses
                s3 << r9
                if r9
                  r10 = _nt_s
                  s3 << r10
                end
              end
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(QueryClauses0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(QueryClauses1)
          r0.extend(QueryClauses2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:query_clauses][start_index] = r0

        r0
      end

      module ReturningClause0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def return
          elements[3]
        end
      end

      module ReturningClause1
        def returning
          elements[0]
        end

        def s
          elements[1]
        end

        def return
          elements[2]
        end

      end

      def _nt_returning_clause
        start_index = index
        if node_cache[:returning_clause].has_key?(index)
          cached = node_cache[:returning_clause][index]
          if cached
            node_cache[:returning_clause][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_returning
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_return
            s0 << r3
            if r3
              s4, i4 = [], index
              loop do
                i5, s5 = index, []
                r6 = _nt_s
                s5 << r6
                if r6
                  if (match_len = has_terminal?(',', false, index))
                    r7 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\',\'')
                    r7 = nil
                  end
                  s5 << r7
                  if r7
                    r8 = _nt_s
                    s5 << r8
                    if r8
                      r9 = _nt_return
                      s5 << r9
                    end
                  end
                end
                if s5.last
                  r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                  r5.extend(ReturningClause0)
                else
                  @index = i5
                  r5 = nil
                end
                if r5
                  s4 << r5
                else
                  break
                end
              end
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ReturningClause1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:returning_clause][start_index] = r0

        r0
      end

      module Return0
      end

      def _nt_return
        start_index = index
        if node_cache[:return].has_key?(index)
          cached = node_cache[:return][index]
          if cached
            node_cache[:return][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r2 = _nt_ordering_prefix
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          s3, i3 = [], index
          loop do
            r4 = _nt_phrase
            if r4
              s3 << r4
            else
              break
            end
          end
          if s3.empty?
            @index = i3
            r3 = nil
          else
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          end
          s0 << r3
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Return0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:return][start_index] = r0

        r0
      end

      module QualifiedClauses0
        def s1
          elements[0]
        end

        def certainty
          elements[1]
        end

        def s2
          elements[2]
        end

        def contracted_clauses
          elements[3]
        end

        def s3
          elements[4]
        end

        def p
          elements[5]
        end

        def s4
          elements[6]
        end

        def c
          elements[7]
        end
      end

      module QualifiedClauses1
        def ast(conjunction = nil)
          r = contracted_clauses.ast  # An array of clause asts
          r[0].conjunction = conjunction
          # pre-qualifiers apply to the first clause, post_qualifiers and context_note to the last
          # REVISIT: This may be incorrect where the last is a nested clause
          r[0].certainty = certainty.value
          r[-1].qualifiers += p.list unless p.empty?
          r[-1].context_note = c.ast unless c.empty?
          r
        end
      end

      def _nt_qualified_clauses
        start_index = index
        if node_cache[:qualified_clauses].has_key?(index)
          cached = node_cache[:qualified_clauses][index]
          if cached
            node_cache[:qualified_clauses][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_certainty
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              r4 = _nt_contracted_clauses
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  r7 = _nt_post_qualifiers
                  if r7
                    r6 = r7
                  else
                    r6 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r6
                  if r6
                    r8 = _nt_s
                    s0 << r8
                    if r8
                      r10 = _nt_context_note
                      if r10
                        r9 = r10
                      else
                        r9 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s0 << r9
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(QualifiedClauses0)
          r0.extend(QualifiedClauses1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:qualified_clauses][start_index] = r0

        r0
      end

      module Certainty0
        def value; false; end
      end

      module Certainty1
        def value; nil; end
      end

      module Certainty2
        def value; true; end
      end

      module Certainty3
        def value; true; end
      end

      def _nt_certainty
        start_index = index
        if node_cache[:certainty].has_key?(index)
          cached = node_cache[:certainty][index]
          if cached
            node_cache[:certainty][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_negative_prefix
        r1.extend(Certainty0)
        r1.extend(Certainty0)
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_maybe
          r2.extend(Certainty1)
          r2.extend(Certainty1)
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_definitely
            r3.extend(Certainty2)
            r3.extend(Certainty2)
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              if (match_len = has_terminal?('', false, index))
                r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                r4.extend(Certainty3)
                @index += match_len
              else
                terminal_parse_failure('\'\'')
                r4 = nil
              end
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:certainty][start_index] = r0

        r0
      end

      module PostQualifiers0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def q1
          elements[3]
        end
      end

      module PostQualifiers1
        def s1
          elements[1]
        end

        def q0
          elements[2]
        end

        def tail
          elements[3]
        end

        def s2
          elements[4]
        end

        def s3
          elements[6]
        end
      end

      module PostQualifiers2
        def list
          [q0.text_value, *tail.elements.map{|e| e.q1.text_value}]
        end
      end

      def _nt_post_qualifiers
        start_index = index
        if node_cache[:post_qualifiers].has_key?(index)
          cached = node_cache[:post_qualifiers][index]
          if cached
            node_cache[:post_qualifiers][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('[', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'[\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_post_qualifier
            s0 << r3
            if r3
              s4, i4 = [], index
              loop do
                i5, s5 = index, []
                r6 = _nt_s
                s5 << r6
                if r6
                  if (match_len = has_terminal?(',', false, index))
                    r7 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\',\'')
                    r7 = nil
                  end
                  s5 << r7
                  if r7
                    r8 = _nt_s
                    s5 << r8
                    if r8
                      r9 = _nt_post_qualifier
                      s5 << r9
                    end
                  end
                end
                if s5.last
                  r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                  r5.extend(PostQualifiers0)
                else
                  @index = i5
                  r5 = nil
                end
                if r5
                  s4 << r5
                else
                  break
                end
              end
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              s0 << r4
              if r4
                r10 = _nt_s
                s0 << r10
                if r10
                  if (match_len = has_terminal?(']', false, index))
                    r11 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\']\'')
                    r11 = nil
                  end
                  s0 << r11
                  if r11
                    r12 = _nt_s
                    s0 << r12
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(PostQualifiers1)
          r0.extend(PostQualifiers2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:post_qualifiers][start_index] = r0

        r0
      end

      def _nt_post_qualifier
        start_index = index
        if node_cache[:post_qualifier].has_key?(index)
          cached = node_cache[:post_qualifier][index]
          if cached
            node_cache[:post_qualifier][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_static
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_transient
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_intransitive
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_stronglyintransitive
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                r5 = _nt_transitive
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  r6 = _nt_acyclic
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r0 = r6
                  else
                    r7 = _nt_symmetric
                    if r7
                      r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                      r0 = r7
                    else
                      r8 = _nt_asymmetric
                      if r8
                        r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                        r0 = r8
                      else
                        r9 = _nt_antisymmetric
                        if r9
                          r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                          r0 = r9
                        else
                          r10 = _nt_reflexive
                          if r10
                            r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                            r0 = r10
                          else
                            r11 = _nt_irreflexive
                            if r11
                              r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                              r0 = r11
                            else
                              @index = i0
                              r0 = nil
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:post_qualifier][start_index] = r0

        r0
      end

      module ClausesList0
        def s
          elements[1]
        end

        def clauses
          elements[2]
        end
      end

      module ClausesList1
        def clauses
          elements[0]
        end

        def tail
          elements[1]
        end
      end

      module ClausesList2
        def ast
          [clauses.ast, *tail.elements.map{|e| e.clauses.ast }]
        end
      end

      def _nt_clauses_list
        start_index = index
        if node_cache[:clauses_list].has_key?(index)
          cached = node_cache[:clauses_list][index]
          if cached
            node_cache[:clauses_list][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_clauses
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3, s3 = index, []
            if (match_len = has_terminal?(',', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\',\'')
              r4 = nil
            end
            s3 << r4
            if r4
              r5 = _nt_s
              s3 << r5
              if r5
                r6 = _nt_clauses
                s3 << r6
              end
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(ClausesList0)
            else
              @index = i3
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ClausesList1)
          r0.extend(ClausesList2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:clauses_list][start_index] = r0

        r0
      end

      module Clauses0
        def and
          elements[0]
        end

        def s1
          elements[1]
        end

        def contracted_clauses
          elements[2]
        end

        def s2
          elements[3]
        end
      end

      module Clauses1
        def contracted_clauses
          elements[0]
        end

        def s
          elements[1]
        end

        def tail
          elements[2]
        end
      end

      module Clauses2
        def ast
          clauses = contracted_clauses.ast
          tail.elements.map{|e| clauses += e.contracted_clauses.ast }
          clauses
        end
      end

      def _nt_clauses
        start_index = index
        if node_cache[:clauses].has_key?(index)
          cached = node_cache[:clauses][index]
          if cached
            node_cache[:clauses][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_contracted_clauses
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4, s4 = index, []
              r5 = _nt_and
              s4 << r5
              if r5
                r6 = _nt_s
                s4 << r6
                if r6
                  r7 = _nt_contracted_clauses
                  s4 << r7
                  if r7
                    r8 = _nt_s
                    s4 << r8
                  end
                end
              end
              if s4.last
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
                r4.extend(Clauses0)
              else
                @index = i4
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Clauses1)
          r0.extend(Clauses2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:clauses][start_index] = r0

        r0
      end

      module ContractedClauses0
        def ast
          asts = elements.map{ |r| r.ast }
          contracted_clauses = []
          qualifiers = []
          if asts[-1].is_a?(Array)        # A contraction (Array of [role, qualifiers, *clauses])
            contracted_clauses = asts.pop         # Pull off the contracted_clauses
            contracted_role = contracted_clauses.shift
            qualifiers = contracted_clauses.shift
            asts.push(contracted_role)  # And replace it by the role removed from the contracted_clauses
          end
          clause_ast = Compiler::Clause.new(asts, qualifiers)
          [clause_ast] + contracted_clauses
        end
      end

      def _nt_contracted_clauses
        start_index = index
        if node_cache[:contracted_clauses].has_key?(index)
          cached = node_cache[:contracted_clauses][index]
          if cached
            node_cache[:contracted_clauses][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_comparison
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          s2, i2 = [], index
          loop do
            i3 = index
            r4 = _nt_contraction
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              r5 = _nt_phrase
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          if s2.empty?
            @index = i2
            r2 = nil
          else
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(ContractedClauses0)
            r2.extend(ContractedClauses0)
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:contracted_clauses][start_index] = r0

        r0
      end

      def _nt_contraction
        start_index = index
        if node_cache[:contraction].has_key?(index)
          cached = node_cache[:contraction][index]
          if cached
            node_cache[:contraction][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_reading_contraction
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_condition_contraction
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:contraction][start_index] = r0

        r0
      end

      module ReadingContraction0
        def role
          elements[0]
        end

        def p
          elements[1]
        end

        def conjunction
          elements[2]
        end

        def s1
          elements[3]
        end

        def certainty
          elements[4]
        end

        def s2
          elements[5]
        end

        def contracted_clauses
          elements[6]
        end

        def s3
          elements[7]
        end
      end

      module ReadingContraction1
        def ast
          # contracted_clauses.ast will return an array of Clauses, but the first clause is special. We must:
          # * prepend a new role (we get the Role to build *two* ast nodes)
          # * attach the qualifiers
          clauses_ast = contracted_clauses.ast
          clauses_ast[0].conjunction = conjunction.text_value
          clauses_ast[0].phrases.unshift(role.ast)
          clauses_ast[0].certainty = certainty.value

          # A contraction returns an array containing:
          # * a role AST
          # * a qualifiers array
          # * an array of Clauses
          [role.ast, p.empty? ? [] : p.list] + clauses_ast
        end
      end

      def _nt_reading_contraction
        start_index = index
        if node_cache[:reading_contraction].has_key?(index)
          cached = node_cache[:reading_contraction][index]
          if cached
            node_cache[:reading_contraction][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_role
        s0 << r1
        if r1
          r3 = _nt_post_qualifiers
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            i4 = index
            r5 = _nt_that
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r4 = r5
            else
              r6 = _nt_who
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r4 = r6
              else
                @index = i4
                r4 = nil
              end
            end
            s0 << r4
            if r4
              r7 = _nt_s
              s0 << r7
              if r7
                r8 = _nt_certainty
                s0 << r8
                if r8
                  r9 = _nt_s
                  s0 << r9
                  if r9
                    r10 = _nt_contracted_clauses
                    s0 << r10
                    if r10
                      r11 = _nt_s
                      s0 << r11
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ReadingContraction0)
          r0.extend(ReadingContraction1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:reading_contraction][start_index] = r0

        r0
      end

      module ConditionContraction0
        def role
          elements[0]
        end

        def pq
          elements[1]
        end

        def certainty
          elements[2]
        end

        def s1
          elements[3]
        end

        def comparator
          elements[4]
        end

        def s2
          elements[5]
        end

        def e2
          elements[6]
        end

      end

      module ConditionContraction1
        def ast
          c = Compiler::Comparison.new(comparator.text_value, role.ast, e2.ast, certainty.value)
          c.conjunction = comparator.text_value
          [ role.ast, pq.empty? ? [] : pq.list, c ]
        end
      end

      def _nt_condition_contraction
        start_index = index
        if node_cache[:condition_contraction].has_key?(index)
          cached = node_cache[:condition_contraction][index]
          if cached
            node_cache[:condition_contraction][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_role
        s0 << r1
        if r1
          r3 = _nt_post_qualifiers
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r4 = _nt_certainty
            s0 << r4
            if r4
              r5 = _nt_s
              s0 << r5
              if r5
                r6 = _nt_comparator
                s0 << r6
                if r6
                  r7 = _nt_s
                  s0 << r7
                  if r7
                    r8 = _nt_expression
                    s0 << r8
                    if r8
                      i9 = index
                      r10 = _nt_phrase
                      if r10
                        @index = i9
                        r9 = nil
                      else
                        @index = i9
                        r9 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s0 << r9
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ConditionContraction0)
          r0.extend(ConditionContraction1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:condition_contraction][start_index] = r0

        r0
      end

      module Comparison0
        def e1
          elements[0]
        end

        def s1
          elements[1]
        end

        def certainty
          elements[2]
        end

        def s2
          elements[3]
        end

        def comparator
          elements[4]
        end

        def s3
          elements[5]
        end

        def contraction
          elements[6]
        end

        def p
          elements[7]
        end
      end

      module Comparison1
        def ast
          role, qualifiers, *clauses_ast = *contraction.ast
          clauses_ast[0].qualifiers += p.list unless p.empty? # apply post_qualifiers to the contracted clause
          # clauses_ast[0].conjunction = 'and' # AND is implicit for a contraction
          c = Compiler::Comparison.new(comparator.text_value, e1.ast, role, certainty.value)
          [c] + clauses_ast
        end
      end

      module Comparison2
        def certainty
          elements[0]
        end

        def e1
          elements[1]
        end

        def s1
          elements[2]
        end

        def comparator
          elements[3]
        end

        def s2
          elements[4]
        end

        def e2
          elements[5]
        end
      end

      module Comparison3
        def ast
          c = Compiler::Comparison.new(comparator.text_value, e1.ast, e2.ast, certainty.value)
          [c]
        end
      end

      def _nt_comparison
        start_index = index
        if node_cache[:comparison].has_key?(index)
          cached = node_cache[:comparison][index]
          if cached
            node_cache[:comparison][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_expression
        s1 << r2
        if r2
          r3 = _nt_s
          s1 << r3
          if r3
            r4 = _nt_certainty
            s1 << r4
            if r4
              r5 = _nt_s
              s1 << r5
              if r5
                r6 = _nt_comparator
                s1 << r6
                if r6
                  r7 = _nt_s
                  s1 << r7
                  if r7
                    r8 = _nt_contraction
                    s1 << r8
                    if r8
                      r10 = _nt_post_qualifiers
                      if r10
                        r9 = r10
                      else
                        r9 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s1 << r9
                    end
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Comparison0)
          r1.extend(Comparison1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i11, s11 = index, []
          r12 = _nt_certainty
          s11 << r12
          if r12
            r13 = _nt_expression
            s11 << r13
            if r13
              r14 = _nt_s
              s11 << r14
              if r14
                r15 = _nt_comparator
                s11 << r15
                if r15
                  r16 = _nt_s
                  s11 << r16
                  if r16
                    r17 = _nt_expression
                    s11 << r17
                  end
                end
              end
            end
          end
          if s11.last
            r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
            r11.extend(Comparison2)
            r11.extend(Comparison3)
          else
            @index = i11
            r11 = nil
          end
          if r11
            r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
            r0 = r11
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:comparison][start_index] = r0

        r0
      end

      def _nt_comparator
        start_index = index
        if node_cache[:comparator].has_key?(index)
          cached = node_cache[:comparator][index]
          if cached
            node_cache[:comparator][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if (match_len = has_terminal?('<=', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'<=\'')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('<>', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'<>\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            if (match_len = has_terminal?('<', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\'<\'')
              r3 = nil
            end
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              if (match_len = has_terminal?('=', false, index))
                r4 = true
                @index += match_len
              else
                terminal_parse_failure('\'=\'')
                r4 = nil
              end
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                if (match_len = has_terminal?('>=', false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'>=\'')
                  r5 = nil
                end
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  if (match_len = has_terminal?('>', false, index))
                    r6 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\'>\'')
                    r6 = nil
                  end
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r0 = r6
                  else
                    if (match_len = has_terminal?('!=', false, index))
                      r7 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                      @index += match_len
                    else
                      terminal_parse_failure('\'!=\'')
                      r7 = nil
                    end
                    if r7
                      r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                      r0 = r7
                    else
                      @index = i0
                      r0 = nil
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:comparator][start_index] = r0

        r0
      end

      module Phrase0
        def id
          elements[2]
        end
      end

      module Phrase1
        def id
          elements[0]
        end

        def tail
          elements[1]
        end

        def s
          elements[2]
        end
      end

      module Phrase2
        def ast
          [id.value, *tail.elements.map{|e| e.id.value}]*"-"
        end
        def node_type; :linking; end
      end

      module Phrase3
        def id
          elements[1]
        end

        def s
          elements[2]
        end
      end

      module Phrase4
        def ast
          id.value
        end
        def node_type; :linking; end
      end

      def _nt_phrase
        start_index = index
        if node_cache[:phrase].has_key?(index)
          cached = node_cache[:phrase][index]
          if cached
            node_cache[:phrase][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_role
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i2, s2 = index, []
          r3 = _nt_id
          s2 << r3
          if r3
            s4, i4 = [], index
            loop do
              i5, s5 = index, []
              if (match_len = has_terminal?('-', false, index))
                r6 = true
                @index += match_len
              else
                terminal_parse_failure('\'-\'')
                r6 = nil
              end
              s5 << r6
              if r6
                i7 = index
                r8 = _nt_term
                if r8
                  @index = i7
                  r7 = nil
                else
                  @index = i7
                  r7 = instantiate_node(SyntaxNode,input, index...index)
                end
                s5 << r7
                if r7
                  r9 = _nt_id
                  s5 << r9
                end
              end
              if s5.last
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                r5.extend(Phrase0)
              else
                @index = i5
                r5 = nil
              end
              if r5
                s4 << r5
              else
                break
              end
            end
            if s4.empty?
              @index = i4
              r4 = nil
            else
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            end
            s2 << r4
            if r4
              r10 = _nt_s
              s2 << r10
            end
          end
          if s2.last
            r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
            r2.extend(Phrase1)
            r2.extend(Phrase2)
          else
            @index = i2
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            i11, s11 = index, []
            i12 = index
            r13 = _nt_non_phrase
            if r13
              @index = i12
              r12 = nil
            else
              @index = i12
              r12 = instantiate_node(SyntaxNode,input, index...index)
            end
            s11 << r12
            if r12
              r14 = _nt_id
              s11 << r14
              if r14
                r15 = _nt_s
                s11 << r15
              end
            end
            if s11.last
              r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
              r11.extend(Phrase3)
              r11.extend(Phrase4)
            else
              @index = i11
              r11 = nil
            end
            if r11
              r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
              r0 = r11
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:phrase][start_index] = r0

        r0
      end

      def _nt_role
        start_index = index
        if node_cache[:role].has_key?(index)
          cached = node_cache[:role][index]
          if cached
            node_cache[:role][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_aggregate
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_simple_role
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:role][start_index] = r0

        r0
      end

      module Aggregate0
        def aggregate
          elements[0]
        end

        def s1
          elements[1]
        end

        def agg_of
          elements[2]
        end

        def s2
          elements[3]
        end

        def term_or_unary
          elements[4]
        end

        def s3
          elements[5]
        end

        def agg_in
          elements[6]
        end

        def s4
          elements[7]
        end

        def qualified_clauses
          elements[9]
        end

        def s5
          elements[10]
        end

      end

      module Aggregate1
        def ast
          raise "Not implemented: AST for '#{aggregate.text_value} of #{term_or_unary.text_value}'"
          # This returns just the role with the nested clauses, which doesn't even work:
          term.ast(
            nil,      # No quantifier
            nil,      # No function call
            nil,      # No role_name
            nil,      # No value_constraint
            nil,      # No literal
            qualified_clauses.ast
          )
        end
      end

      def _nt_aggregate
        start_index = index
        if node_cache[:aggregate].has_key?(index)
          cached = node_cache[:aggregate][index]
          if cached
            node_cache[:aggregate][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_id
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_agg_of
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                r5 = _nt_term_or_unary
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    r7 = _nt_agg_in
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                      if r8
                        if (match_len = has_terminal?('(', false, index))
                          r9 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'(\'')
                          r9 = nil
                        end
                        s0 << r9
                        if r9
                          r10 = _nt_qualified_clauses
                          s0 << r10
                          if r10
                            r11 = _nt_s
                            s0 << r11
                            if r11
                              if (match_len = has_terminal?(')', false, index))
                                r12 = true
                                @index += match_len
                              else
                                terminal_parse_failure('\')\'')
                                r12 = nil
                              end
                              s0 << r12
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Aggregate0)
          r0.extend(Aggregate1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:aggregate][start_index] = r0

        r0
      end

      module RoleQuantifier0
        def quantifier
          elements[0]
        end

        def mapping_pragmas
          elements[1]
        end

        def enforcement
          elements[2]
        end

        def cn
          elements[3]
        end
      end

      module RoleQuantifier1
        def ast
          Compiler::Quantifier.new(
            quantifier.value[0],
            quantifier.value[1],
            enforcement.ast,
            cn.empty? ? nil : cn.ast,
            mapping_pragmas.value
          )
        end
      end

      def _nt_role_quantifier
        start_index = index
        if node_cache[:role_quantifier].has_key?(index)
          cached = node_cache[:role_quantifier][index]
          if cached
            node_cache[:role_quantifier][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_quantifier
        s0 << r1
        if r1
          r2 = _nt_mapping_pragmas
          s0 << r2
          if r2
            r3 = _nt_enforcement
            s0 << r3
            if r3
              r5 = _nt_context_note
              if r5
                r4 = r5
              else
                r4 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r4
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RoleQuantifier0)
          r0.extend(RoleQuantifier1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:role_quantifier][start_index] = r0

        r0
      end

      module SimpleRole0
        def literal
          elements[0]
        end

        def u
          elements[1]
        end
      end

      module SimpleRole1
        def value_constraint
          elements[0]
        end

        def enforcement
          elements[1]
        end
      end

      module SimpleRole2
        def q
          elements[0]
        end

        def player
          elements[1]
        end

        def lr
          elements[2]
        end

        def oj
          elements[3]
        end
      end

      module SimpleRole3
        def ast
          if !q.empty? && q.quantifier.value
            quantifier = q.ast
          end
          if !lr.empty?
            if lr.respond_to?(:literal)
              literal = Compiler::Literal.new(lr.literal.value, lr.u.empty? ? nil : lr.u.text_value)
            end
            value_constraint = Compiler::ValueConstraint.new(lr.value_constraint.ast, lr.enforcement.ast) if lr.respond_to?(:value_constraint)
            raise "It is not permitted to provide both a literal value and a value constraint" if value_constraint and literal
          end

          nested_clauses =
            if oj.empty?
              nil
            else
              ast = oj.ast
              ast[0].conjunction = 'where'
              ast
            end
          player.ast(quantifier, value_constraint, literal, nested_clauses)
        end
      end

      def _nt_simple_role
        start_index = index
        if node_cache[:simple_role].has_key?(index)
          cached = node_cache[:simple_role][index]
          if cached
            node_cache[:simple_role][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r2 = _nt_role_quantifier
        if r2
          r1 = r2
        else
          r1 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r1
        if r1
          r3 = _nt_derived_variable
          s0 << r3
          if r3
            i5 = index
            i6, s6 = index, []
            r7 = _nt_literal
            s6 << r7
            if r7
              r9 = _nt_unit
              if r9
                r8 = r9
              else
                r8 = instantiate_node(SyntaxNode,input, index...index)
              end
              s6 << r8
            end
            if s6.last
              r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
              r6.extend(SimpleRole0)
            else
              @index = i6
              r6 = nil
            end
            if r6
              r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
              r5 = r6
            else
              i10, s10 = index, []
              r11 = _nt_value_constraint
              s10 << r11
              if r11
                r12 = _nt_enforcement
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(SimpleRole1)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                r5 = r10
              else
                @index = i5
                r5 = nil
              end
            end
            if r5
              r4 = r5
            else
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
            if r4
              r14 = _nt_objectification_step
              if r14
                r13 = r14
              else
                r13 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r13
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SimpleRole2)
          r0.extend(SimpleRole3)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:simple_role][start_index] = r0

        r0
      end

      module ObjectificationStep0
        def s1
          elements[1]
        end

        def in_which
          elements[2]
        end

        def s2
          elements[3]
        end

        def facts
          elements[4]
        end

        def s3
          elements[5]
        end

        def s4
          elements[7]
        end
      end

      module ObjectificationStep1
        def ast
          facts.ast
        end
      end

      def _nt_objectification_step
        start_index = index
        if node_cache[:objectification_step].has_key?(index)
          cached = node_cache[:objectification_step][index]
          if cached
            node_cache[:objectification_step][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('(', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'(\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_in_which
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                r5 = _nt_query_clauses
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    if (match_len = has_terminal?(')', false, index))
                      r7 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\')\'')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ObjectificationStep0)
          r0.extend(ObjectificationStep1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:objectification_step][start_index] = r0

        r0
      end

      module RoleName0
        def s1
          elements[1]
        end

        def as
          elements[2]
        end

        def S
          elements[3]
        end

        def r
          elements[4]
        end

        def s2
          elements[5]
        end

        def s3
          elements[7]
        end
      end

      module RoleName1
        def value; r.value; end
      end

      def _nt_role_name
        start_index = index
        if node_cache[:role_name].has_key?(index)
          cached = node_cache[:role_name][index]
          if cached
            node_cache[:role_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('(', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'(\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            r3 = _nt_as
            s0 << r3
            if r3
              r4 = _nt_S
              s0 << r4
              if r4
                r5 = _nt_term
                s0 << r5
                if r5
                  r6 = _nt_s
                  s0 << r6
                  if r6
                    if (match_len = has_terminal?(')', false, index))
                      r7 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\')\'')
                      r7 = nil
                    end
                    s0 << r7
                    if r7
                      r8 = _nt_s
                      s0 << r8
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RoleName0)
          r0.extend(RoleName1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:role_name][start_index] = r0

        r0
      end

      module Subscript0
      end

      module Subscript1
        def s1
          elements[1]
        end

        def i
          elements[2]
        end

        def s2
          elements[3]
        end

        def s3
          elements[5]
        end
      end

      module Subscript2
        def value; i.text_value.to_i; end
      end

      def _nt_subscript
        start_index = index
        if node_cache[:subscript].has_key?(index)
          cached = node_cache[:subscript][index]
          if cached
            node_cache[:subscript][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if (match_len = has_terminal?('(', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'(\'')
          r1 = nil
        end
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            i3, s3 = index, []
            if has_terminal?(@regexps[gr = '\A[1-9]'] ||= Regexp.new(gr), :regexp, index)
              r4 = true
              @index += 1
            else
              terminal_parse_failure('[1-9]')
              r4 = nil
            end
            s3 << r4
            if r4
              s5, i5 = [], index
              loop do
                if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
                  r6 = true
                  @index += 1
                else
                  terminal_parse_failure('[0-9]')
                  r6 = nil
                end
                if r6
                  s5 << r6
                else
                  break
                end
              end
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              s3 << r5
            end
            if s3.last
              r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
              r3.extend(Subscript0)
            else
              @index = i3
              r3 = nil
            end
            s0 << r3
            if r3
              r7 = _nt_s
              s0 << r7
              if r7
                if (match_len = has_terminal?(')', false, index))
                  r8 = true
                  @index += match_len
                else
                  terminal_parse_failure('\')\'')
                  r8 = nil
                end
                s0 << r8
                if r8
                  r9 = _nt_s
                  s0 << r9
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Subscript1)
          r0.extend(Subscript2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:subscript][start_index] = r0

        r0
      end

    end

    class FactTypesParser < Treetop::Runtime::CompiledParser
      include FactTypes
    end

  end
end
