#
# Autogenerated from a Treetop grammar. Edits may be lost.


#       ActiveFacts CQL Parser.
#       Parse rules relating to Transformation Rules.
#
# Copyright (c) 2017 Factil Pty Ltd. Read the LICENSE file.
#
module ActiveFacts
  module CQL
    module TransformRules
      include Treetop::Runtime

      def root
        @root ||= :transform_rule
      end

      module TransformRule0
        def ctr
          elements[0]
        end

        def s
          elements[1]
        end

      end

      module TransformRule1
        def ast
          Compiler::TransformRule.new(ctr.ast)
        end
      end

      def _nt_transform_rule
        start_index = index
        if node_cache[:transform_rule].has_key?(index)
          cached = node_cache[:transform_rule][index]
          if cached
            node_cache[:transform_rule][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_compound_transform_matching
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?(';', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\';\'')
              r3 = nil
            end
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TransformRule0)
          r0.extend(TransformRule1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:transform_rule][start_index] = r0

        r0
      end

      module CompoundTransformMatching0
        def s1
          elements[0]
        end

        def tl
          elements[1]
        end

        def s2
          elements[2]
        end

        def s3
          elements[4]
        end

        def tq
          elements[5]
        end

        def s4
          elements[6]
        end

        def tr
          elements[8]
        end

        def s5
          elements[9]
        end

      end

      module CompoundTransformMatching1
        def ast
          Compiler::CompoundTransformMatching.new(tl.ast, tq.empty? ? nil : tq.ast, tr.ast)
        end
      end

      def _nt_compound_transform_matching
        start_index = index
        if node_cache[:compound_transform_matching].has_key?(index)
          cached = node_cache[:compound_transform_matching][index]
          if cached
            node_cache[:compound_transform_matching][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_term_list
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              if (match_len = has_terminal?('<==', false, index))
                r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'<==\'')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  r7 = _nt_transform_query
                  if r7
                    r6 = r7
                  else
                    r6 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r6
                  if r6
                    r8 = _nt_s
                    s0 << r8
                    if r8
                      if (match_len = has_terminal?('{', false, index))
                        r9 = true
                        @index += match_len
                      else
                        terminal_parse_failure('\'{\'')
                        r9 = nil
                      end
                      s0 << r9
                      if r9
                        r10 = _nt_transform_matchings
                        s0 << r10
                        if r10
                          r11 = _nt_s
                          s0 << r11
                          if r11
                            if (match_len = has_terminal?('}', false, index))
                              r12 = true
                              @index += match_len
                            else
                              terminal_parse_failure('\'}\'')
                              r12 = nil
                            end
                            s0 << r12
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CompoundTransformMatching0)
          r0.extend(CompoundTransformMatching1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:compound_transform_matching][start_index] = r0

        r0
      end

      module SimpleTransformMatching0
        def s1
          elements[0]
        end

        def tl
          elements[1]
        end

        def s2
          elements[2]
        end

        def s3
          elements[4]
        end

        def te
          elements[5]
        end
      end

      module SimpleTransformMatching1
        def ast
          Compiler::SimpleTransformMatching.new(tl.ast, te.empty? ? nil : te.ast)
        end
      end

      def _nt_simple_transform_matching
        start_index = index
        if node_cache[:simple_transform_matching].has_key?(index)
          cached = node_cache[:simple_transform_matching][index]
          if cached
            node_cache[:simple_transform_matching][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_term_list
          s0 << r2
          if r2
            r3 = _nt_s
            s0 << r3
            if r3
              if (match_len = has_terminal?('<--', false, index))
                r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'<--\'')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  r7 = _nt_transform_expr
                  if r7
                    r6 = r7
                  else
                    r6 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(SimpleTransformMatching0)
          r0.extend(SimpleTransformMatching1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:simple_transform_matching][start_index] = r0

        r0
      end

      module TransformQuery0
        def t
          elements[0]
        end
      end

      module TransformQuery1
        def ast; t.ast; end;
      end

      module TransformQuery2
        def cl
          elements[0]
        end
      end

      module TransformQuery3
        def ast; cl.ast; end;
      end

      def _nt_transform_query
        start_index = index
        if node_cache[:transform_query].has_key?(index)
          cached = node_cache[:transform_query][index]
          if cached
            node_cache[:transform_query][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_term
        s1 << r2
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(TransformQuery0)
          r1.extend(TransformQuery1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i3, s3 = index, []
          r4 = _nt_clauses_list
          s3 << r4
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(TransformQuery2)
            r3.extend(TransformQuery3)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r0 = r3
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:transform_query][start_index] = r0

        r0
      end

      module TransformMatchings0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def r1
          elements[3]
        end
      end

      module TransformMatchings1
        def s
          elements[0]
        end

        def r0
          elements[1]
        end

        def tail
          elements[2]
        end
      end

      module TransformMatchings2
        def ast
          [r0.ast, *tail.elements.map{|e| e.r1.ast }]
        end
      end

      def _nt_transform_matchings
        start_index = index
        if node_cache[:transform_matchings].has_key?(index)
          cached = node_cache[:transform_matchings][index]
          if cached
            node_cache[:transform_matchings][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_transform_matching
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4, s4 = index, []
              r5 = _nt_s
              s4 << r5
              if r5
                if (match_len = has_terminal?(',', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\',\'')
                  r6 = nil
                end
                s4 << r6
                if r6
                  r7 = _nt_s
                  s4 << r7
                  if r7
                    r8 = _nt_transform_matching
                    s4 << r8
                  end
                end
              end
              if s4.last
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
                r4.extend(TransformMatchings0)
              else
                @index = i4
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TransformMatchings1)
          r0.extend(TransformMatchings2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:transform_matchings][start_index] = r0

        r0
      end

      module TransformMatching0
        def str
          elements[0]
        end
      end

      module TransformMatching1
        def ast; str.ast; end;
      end

      module TransformMatching2
        def ctr
          elements[0]
        end
      end

      module TransformMatching3
        def ast; ctr.ast; end;
      end

      def _nt_transform_matching
        start_index = index
        if node_cache[:transform_matching].has_key?(index)
          cached = node_cache[:transform_matching][index]
          if cached
            node_cache[:transform_matching][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_simple_transform_matching
        s1 << r2
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(TransformMatching0)
          r1.extend(TransformMatching1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i3, s3 = index, []
          r4 = _nt_compound_transform_matching
          s3 << r4
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(TransformMatching2)
            r3.extend(TransformMatching3)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r0 = r3
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:transform_matching][start_index] = r0

        r0
      end

      module TermList0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def t1
          elements[3]
        end
      end

      module TermList1
        def s
          elements[0]
        end

        def t0
          elements[1]
        end

        def tail
          elements[2]
        end
      end

      module TermList2
        def ast
          if tail.elements.empty?
            [t0.ast]
          else
            [t0.ast, *tail.elements.map{|t| t.t1.ast }]
          end
        end
      end

      def _nt_term_list
        start_index = index
        if node_cache[:term_list].has_key?(index)
          cached = node_cache[:term_list][index]
          if cached
            node_cache[:term_list][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_term
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4, s4 = index, []
              r5 = _nt_s
              s4 << r5
              if r5
                if (match_len = has_terminal?('.', false, index))
                  r6 = true
                  @index += match_len
                else
                  terminal_parse_failure('\'.\'')
                  r6 = nil
                end
                s4 << r6
                if r6
                  r7 = _nt_s
                  s4 << r7
                  if r7
                    r8 = _nt_term_list
                    s4 << r8
                  end
                end
              end
              if s4.last
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
                r4.extend(TermList0)
              else
                @index = i4
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TermList1)
          r0.extend(TermList2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:term_list][start_index] = r0

        r0
      end

      module TransformExpr0
        def s1
          elements[0]
        end

        def c
          elements[1]
        end

        def s2
          elements[2]
        end

        def s3
          elements[4]
        end

        def t0
          elements[5]
        end

        def s4
          elements[6]
        end

        def s5
          elements[8]
        end

        def t1
          elements[9]
        end
      end

      module TransformExpr1
        def ast
          Compiler::Ternary.new(c.ast, t0.ast, t1.ast)
        end
      end

      module TransformExpr2
        def s1
          elements[0]
        end

        def o
          elements[1]
        end

        def S
          elements[2]
        end

        def agg_of
          elements[3]
        end

        def s2
          elements[4]
        end

        def t
          elements[5]
        end
      end

      module TransformExpr3
        def ast
          Compiler::Aggregate.new(o.text_value, t.ast)
        end
      end

      module TransformExpr4
        def s
          elements[0]
        end

        def t0
          elements[1]
        end
      end

      module TransformExpr5
        def ast; t0.ast; end;
      end

      def _nt_transform_expr
        start_index = index
        if node_cache[:transform_expr].has_key?(index)
          cached = node_cache[:transform_expr][index]
          if cached
            node_cache[:transform_expr][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_s
        s1 << r2
        if r2
          r3 = _nt_logical_texpr
          s1 << r3
          if r3
            r4 = _nt_s
            s1 << r4
            if r4
              if (match_len = has_terminal?('?', false, index))
                r5 = true
                @index += match_len
              else
                terminal_parse_failure('\'?\'')
                r5 = nil
              end
              s1 << r5
              if r5
                r6 = _nt_s
                s1 << r6
                if r6
                  r7 = _nt_logical_texpr
                  s1 << r7
                  if r7
                    r8 = _nt_s
                    s1 << r8
                    if r8
                      if (match_len = has_terminal?(':', false, index))
                        r9 = true
                        @index += match_len
                      else
                        terminal_parse_failure('\':\'')
                        r9 = nil
                      end
                      s1 << r9
                      if r9
                        r10 = _nt_s
                        s1 << r10
                        if r10
                          r11 = _nt_logical_texpr
                          s1 << r11
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(TransformExpr0)
          r1.extend(TransformExpr1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i12, s12 = index, []
          r13 = _nt_s
          s12 << r13
          if r13
            r14 = _nt_aggregate_op
            s12 << r14
            if r14
              r15 = _nt_S
              s12 << r15
              if r15
                r16 = _nt_agg_of
                s12 << r16
                if r16
                  r17 = _nt_s
                  s12 << r17
                  if r17
                    r18 = _nt_logical_texpr
                    s12 << r18
                  end
                end
              end
            end
          end
          if s12.last
            r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
            r12.extend(TransformExpr2)
            r12.extend(TransformExpr3)
          else
            @index = i12
            r12 = nil
          end
          if r12
            r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
            r0 = r12
          else
            i19, s19 = index, []
            r20 = _nt_s
            s19 << r20
            if r20
              r21 = _nt_logical_texpr
              s19 << r21
            end
            if s19.last
              r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
              r19.extend(TransformExpr4)
              r19.extend(TransformExpr5)
            else
              @index = i19
              r19 = nil
            end
            if r19
              r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
              r0 = r19
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:transform_expr][start_index] = r0

        r0
      end

      def _nt_aggregate_op
        start_index = index
        if node_cache[:aggregate_op].has_key?(index)
          cached = node_cache[:aggregate_op][index]
          if cached
            node_cache[:aggregate_op][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if (match_len = has_terminal?('sum', false, index))
          r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'sum\'')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('average', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'average\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            if (match_len = has_terminal?('max', false, index))
              r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'max\'')
              r3 = nil
            end
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              if (match_len = has_terminal?('min', false, index))
                r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'min\'')
                r4 = nil
              end
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                if (match_len = has_terminal?('count', false, index))
                  r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                  @index += match_len
                else
                  terminal_parse_failure('\'count\'')
                  r5 = nil
                end
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end

        node_cache[:aggregate_op][start_index] = r0

        r0
      end

      module LogicalTexpr0
        def s1
          elements[0]
        end

        def op
          elements[1]
        end

        def s2
          elements[2]
        end

        def t1
          elements[3]
        end
      end

      module LogicalTexpr1
        def s
          elements[0]
        end

        def t0
          elements[1]
        end

        def tail
          elements[2]
        end
      end

      module LogicalTexpr2
        def ast
          if tail.elements.empty?
            t0.ast
          else
            Compiler::LogicalOr.new(t0.ast, *tail.elements.map{|e| e.t1.ast})
          end
        end
      end

      def _nt_logical_texpr
        start_index = index
        if node_cache[:logical_texpr].has_key?(index)
          cached = node_cache[:logical_texpr][index]
          if cached
            node_cache[:logical_texpr][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_logical_and_texpr
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4, s4 = index, []
              r5 = _nt_s
              s4 << r5
              if r5
                r6 = _nt_or
                s4 << r6
                if r6
                  r7 = _nt_s
                  s4 << r7
                  if r7
                    r8 = _nt_logical_and_texpr
                    s4 << r8
                  end
                end
              end
              if s4.last
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
                r4.extend(LogicalTexpr0)
              else
                @index = i4
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(LogicalTexpr1)
          r0.extend(LogicalTexpr2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:logical_texpr][start_index] = r0

        r0
      end

      module LogicalAndTexpr0
        def s1
          elements[0]
        end

        def op
          elements[1]
        end

        def s2
          elements[2]
        end

        def t1
          elements[3]
        end
      end

      module LogicalAndTexpr1
        def s
          elements[0]
        end

        def t0
          elements[1]
        end

        def tail
          elements[2]
        end
      end

      module LogicalAndTexpr2
        def ast
          if tail.elements.empty?
            t0.ast
          else
            Compiler::LogicalAnd.new(t0.ast, *tail.elements.map{|e| e.t1.ast})
          end
        end
      end

      def _nt_logical_and_texpr
        start_index = index
        if node_cache[:logical_and_texpr].has_key?(index)
          cached = node_cache[:logical_and_texpr][index]
          if cached
            node_cache[:logical_and_texpr][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_equality_texpr
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4, s4 = index, []
              r5 = _nt_s
              s4 << r5
              if r5
                r6 = _nt_and
                s4 << r6
                if r6
                  r7 = _nt_s
                  s4 << r7
                  if r7
                    r8 = _nt_equality_texpr
                    s4 << r8
                  end
                end
              end
              if s4.last
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
                r4.extend(LogicalAndTexpr0)
              else
                @index = i4
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(LogicalAndTexpr1)
          r0.extend(LogicalAndTexpr2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:logical_and_texpr][start_index] = r0

        r0
      end

      module EqualityTexpr0
        def s1
          elements[0]
        end

        def op
          elements[1]
        end

        def s2
          elements[2]
        end

        def t1
          elements[3]
        end
      end

      module EqualityTexpr1
        def s
          elements[0]
        end

        def t0
          elements[1]
        end

        def operation
          elements[2]
        end
      end

      module EqualityTexpr2
        def ast
          if operation.empty?
            t0.ast
          else
            Compiler::Comparison.new(op.text_value, t0.ast, operation.t1.ast)
          end
        end
      end

      def _nt_equality_texpr
        start_index = index
        if node_cache[:equality_texpr].has_key?(index)
          cached = node_cache[:equality_texpr][index]
          if cached
            node_cache[:equality_texpr][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_relational_texpr
          s0 << r2
          if r2
            i4, s4 = index, []
            r5 = _nt_s
            s4 << r5
            if r5
              r6 = _nt_equality_op
              s4 << r6
              if r6
                r7 = _nt_s
                s4 << r7
                if r7
                  r8 = _nt_relational_texpr
                  s4 << r8
                end
              end
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(EqualityTexpr0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(EqualityTexpr1)
          r0.extend(EqualityTexpr2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:equality_texpr][start_index] = r0

        r0
      end

      def _nt_equality_op
        start_index = index
        if node_cache[:equality_op].has_key?(index)
          cached = node_cache[:equality_op][index]
          if cached
            node_cache[:equality_op][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if (match_len = has_terminal?('=', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'=\'')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('!=', false, index))
            r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'!=\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:equality_op][start_index] = r0

        r0
      end

      module RelationalTexpr0
        def s1
          elements[0]
        end

        def op
          elements[1]
        end

        def s2
          elements[2]
        end

        def t1
          elements[3]
        end
      end

      module RelationalTexpr1
        def s
          elements[0]
        end

        def t0
          elements[1]
        end

        def operation
          elements[2]
        end
      end

      module RelationalTexpr2
        def ast
          if operation.empty?
            t0.ast
          else
            Compiler::Comparison.new(op.text_value, t0.ast, operation.t1.ast)
          end
        end
      end

      def _nt_relational_texpr
        start_index = index
        if node_cache[:relational_texpr].has_key?(index)
          cached = node_cache[:relational_texpr][index]
          if cached
            node_cache[:relational_texpr][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_additive_texpr
          s0 << r2
          if r2
            i4, s4 = index, []
            r5 = _nt_s
            s4 << r5
            if r5
              r6 = _nt_relational_op
              s4 << r6
              if r6
                r7 = _nt_s
                s4 << r7
                if r7
                  r8 = _nt_additive_texpr
                  s4 << r8
                end
              end
            end
            if s4.last
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              r4.extend(RelationalTexpr0)
            else
              @index = i4
              r4 = nil
            end
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(RelationalTexpr1)
          r0.extend(RelationalTexpr2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:relational_texpr][start_index] = r0

        r0
      end

      def _nt_relational_op
        start_index = index
        if node_cache[:relational_op].has_key?(index)
          cached = node_cache[:relational_op][index]
          if cached
            node_cache[:relational_op][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if (match_len = has_terminal?('<', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'<\'')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('>', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('\'>\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            if (match_len = has_terminal?('>=', false, index))
              r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'>=\'')
              r3 = nil
            end
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              if (match_len = has_terminal?('<=', false, index))
                r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'<=\'')
                r4 = nil
              end
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:relational_op][start_index] = r0

        r0
      end

      module AdditiveTexpr0
        def s1
          elements[0]
        end

        def op
          elements[1]
        end

        def s2
          elements[2]
        end

        def t1
          elements[3]
        end
      end

      module AdditiveTexpr1
        def s
          elements[0]
        end

        def t0
          elements[1]
        end

        def tail
          elements[2]
        end
      end

      module AdditiveTexpr2
        def ast
          if tail.elements.empty?
            t0.ast
          else
            Compiler::Sum.new(
              t0.ast,
              *tail.elements.map{|e| e.op.text_value == '-' ? Compiler::Negate.new(e.t1.ast) : e.t1.ast}
            )
          end
        end
      end

      def _nt_additive_texpr
        start_index = index
        if node_cache[:additive_texpr].has_key?(index)
          cached = node_cache[:additive_texpr][index]
          if cached
            node_cache[:additive_texpr][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_multiplicative_texpr
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4, s4 = index, []
              r5 = _nt_s
              s4 << r5
              if r5
                r6 = _nt_additive_op
                s4 << r6
                if r6
                  r7 = _nt_s
                  s4 << r7
                  if r7
                    r8 = _nt_multiplicative_texpr
                    s4 << r8
                  end
                end
              end
              if s4.last
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
                r4.extend(AdditiveTexpr0)
              else
                @index = i4
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(AdditiveTexpr1)
          r0.extend(AdditiveTexpr2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:additive_texpr][start_index] = r0

        r0
      end

      def _nt_additive_op
        start_index = index
        if node_cache[:additive_op].has_key?(index)
          cached = node_cache[:additive_op][index]
          if cached
            node_cache[:additive_op][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if (match_len = has_terminal?('+', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'+\'')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('-', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('\'-\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:additive_op][start_index] = r0

        r0
      end

      module MultiplicativeTexpr0
        def s1
          elements[0]
        end

        def op
          elements[1]
        end

        def s2
          elements[2]
        end

        def t1
          elements[3]
        end
      end

      module MultiplicativeTexpr1
        def s
          elements[0]
        end

        def t0
          elements[1]
        end

        def tail
          elements[2]
        end
      end

      module MultiplicativeTexpr2
        def ast
          if tail.elements.empty?
            t0.ast
          else
            Compiler::Product.new(
              t0.ast,
              *tail.elements.map{|e| e.op.text_value == '/' ? Compiler::Reciprocal.new(e.t1.ast) : e.t1.ast}
            )
          end
        end
      end

      def _nt_multiplicative_texpr
        start_index = index
        if node_cache[:multiplicative_texpr].has_key?(index)
          cached = node_cache[:multiplicative_texpr][index]
          if cached
            node_cache[:multiplicative_texpr][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_unary_texpr
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4, s4 = index, []
              r5 = _nt_s
              s4 << r5
              if r5
                r6 = _nt_multiplicative_op
                s4 << r6
                if r6
                  r7 = _nt_s
                  s4 << r7
                  if r7
                    r8 = _nt_unary_texpr
                    s4 << r8
                  end
                end
              end
              if s4.last
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
                r4.extend(MultiplicativeTexpr0)
              else
                @index = i4
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MultiplicativeTexpr1)
          r0.extend(MultiplicativeTexpr2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:multiplicative_texpr][start_index] = r0

        r0
      end

      def _nt_multiplicative_op
        start_index = index
        if node_cache[:multiplicative_op].has_key?(index)
          cached = node_cache[:multiplicative_op][index]
          if cached
            node_cache[:multiplicative_op][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if (match_len = has_terminal?('*', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'*\'')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('/', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('\'/\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:multiplicative_op][start_index] = r0

        r0
      end

      module UnaryTexpr0
        def s1
          elements[0]
        end

        def u
          elements[1]
        end

        def s2
          elements[2]
        end

        def t
          elements[3]
        end
      end

      module UnaryTexpr1
        def ast
          if u.empty?
            t.ast
          else
            u.text_value == '-' ? Compiler::Negate.new(t.ast) : Compiler::Negation.new(t.ast)
          end
        end
      end

      def _nt_unary_texpr
        start_index = index
        if node_cache[:unary_texpr].has_key?(index)
          cached = node_cache[:unary_texpr][index]
          if cached
            node_cache[:unary_texpr][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r3 = _nt_unary_op
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            r4 = _nt_s
            s0 << r4
            if r4
              r5 = _nt_primary_texpr
              s0 << r5
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(UnaryTexpr0)
          r0.extend(UnaryTexpr1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:unary_texpr][start_index] = r0

        r0
      end

      def _nt_unary_op
        start_index = index
        if node_cache[:unary_op].has_key?(index)
          cached = node_cache[:unary_op][index]
          if cached
            node_cache[:unary_op][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        if (match_len = has_terminal?('-', false, index))
          r1 = true
          @index += match_len
        else
          terminal_parse_failure('\'-\'')
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('!', false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('\'!\'')
            r2 = nil
          end
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:unary_op][start_index] = r0

        r0
      end

      module PrimaryTexpr0
        def t
          elements[0]
        end
      end

      module PrimaryTexpr1
        def ast
          t.ast
        end
      end

      module PrimaryTexpr2
        def l
          elements[0]
        end
      end

      module PrimaryTexpr3
        def ast
          Compiler::Literal.new(l.value, nil)
        end
      end

      def _nt_primary_texpr
        start_index = index
        if node_cache[:primary_texpr].has_key?(index)
          cached = node_cache[:primary_texpr][index]
          if cached
            node_cache[:primary_texpr][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_term
        s1 << r2
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(PrimaryTexpr0)
          r1.extend(PrimaryTexpr1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i3, s3 = index, []
          r4 = _nt_literal
          s3 << r4
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(PrimaryTexpr2)
            r3.extend(PrimaryTexpr3)
          else
            @index = i3
            r3 = nil
          end
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r0 = r3
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:primary_texpr][start_index] = r0

        r0
      end

    end

    class TransformRulesParser < Treetop::Runtime::CompiledParser
      include TransformRules
    end

  end
end
