<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>CQL Introduction</title>
<meta name="description" content="CQL Introduction" />
<meta name="keywords" content="infinuendo, data constellation,information management,semantic modelling,activefacts" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link rel="icon" href="/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="css/style.css" media="screen" type="text/css" />
<link rel="stylesheet" href="css/screen.css" media="screen" type="text/css" />
<!--[if lte IE 6]>
  <link rel="stylesheet" href="css/screen.ie6.css" media="screen" type="text/css" />
<![endif]-->
<link rel="stylesheet" href="css/print.css" media="print" type="text/css" />
<link rel="stylesheet" href="css/railroad-diagrams.css">
<link rel="stylesheet" href="css/local.css" media="screen" type="text/css" />
<style>
body svg.railroad-diagram {
	background-color: hsl(30,20%, 95%);
}
h2 {
	font-family: sans-serif;
	font-size: 1em;
}
svg.railroad-diagram path,
svg.railroad-diagram rect
{
	stroke-width: 2px;
}
.railroad-diagram .terminal text {
	fill: #44F;
}
div svg.railroad-diagram {
	width: 80%;  /* Scale to the width of the parent */
	height: 100%;  /* Preserve the ratio. Could be related to https://bugs.webkit.org/show_bug.cgi?id=82489 */
}
</style>
</head>
<body>

<link rel="stylesheet" href="css/offline.css" media="screen" type="text/css" />

<style type="text/css" id="internalStyle">
dt {
	font-weight: bold;
	padding-bottom: 5px;
}
dd {
	padding-bottom: 10px;
}
</style>

<style>
div svg.railroad-diagram {
	width: 80%;  /* Scale to the width of the parent */
	height: 100%;  /* Preserve the ratio. Could be related to https://bugs.webkit.org/show_bug.cgi?id=82489 */
}
</style>
<script src='railroad-diagrams.js'></script>

<!--title>Introduction to the</title-->
<h1>
Introduction to the Constellation Query Language
</h1>
<p>The Constellation Query Language (<b>CQL</b>) is a language for
constructing and querying fact-based information models. It is based
on the graphical <a href="#ftn1" title="ORM Foundation">
<b>Object Role Modeling</b></a> language, with some terminology
adopted from the <a href="#ftn2" title="SBVR"><b>Semantics of
Business Vocabulary and Business Rules</b></a>.</p>

<p>Because CQL has an open vocabulary, and because it is designed to
resemble natural language, the formal grammar has potential ambiguities.
Most of these ambiguities can be automatically resolved, and the
resolutions will become obvious as the syntax rules unfold.  As
described here, CQL uses English language keywords and expressions,
though variants of CQL are being defined that substitute keywords and
expressions from other languages. Some of these keywords are disallowed
as open vocabulary, where they would create unresolvable ambiguities.
This includes all the logical operators, such as <tt>and</tt>, <tt>or</tt>, <tt>maybe</tt>,
<tt>not</tt>, <tt>none</tt>, <tt>no</tt>, <tt>only if</tt>, etc. Other keywords such as <tt>is</tt>,
<tt>identified</tt>, <tt>kind</tt>, <tt>of</tt>, <tt>as</tt>, <tt>at</tt>, etc, are allowed to be used anywhere
open vocabulary is allowed, and their special meaning applies only in
the specific places noted.</p>

<p>CQL is <em>case sensitive</em>. <tt>Person</tt> is not the same
thing as <tt>person</tt>. It's conventional, though not required, to
use a capital letter for all object type names.
White space and comments as used in C and C++ are allowed:
<tt>/*&nbsp;comment<br>may&nbsp;span&nbsp;lines&nbsp;*/</tt> and
<tt>//&nbsp;introduces&nbsp;a&nbsp;comment&nbsp;to&nbsp;end&nbsp;of&nbsp;the&nbsp;current&nbsp;line.</tt>
</p>

<p>
Parsing a CQL statement consists of identifying recognised expressions and
terms (with any applicable adjectives) while ignoring the residual predicate text.
The combination of the object types (as designated by terms) and the predicate
text is used to designate fact types.
</p>

<p>
At a lexical level, CQL supports the full range of primitive data types commonly found in modern programming languages including BOOLEAN, STRING, DECIMAL, REAL, EXPONENTIAL.  CQL suports expressions on these primitive data types.  Full details of the lexical and expression rules are contained in the Lexical Rules section below.  
</p>

<h2>CQL Model</h2>

<p>A fact-based model (known in CQL as a <b>vocabulary</b>) comprises definitions of the following kinds:</p>

<ul type="disc">

<li><b>Object Types</b> are designated by name. Objects types include <b>value types</b>, <b>entity types</b>
and <b>named fact types</b>.
</li>

<li><b>Fact Types</b> are designated by one or more <b>readings</b>.
Fact types declare a relationship between object types,
or a boolean property of a single object type.
A fact type may be designated by a name (objectified),
which allows its use as an object type in other fact types.
A fact type may be derived from a query, analogous to an SQL view.
</li>

<li><b>Constraints</b> which restrict the allowed object instances
and facts within a valid <b>population</b>.</li>

<li><b>Instances</b> of object types and fact types as examples
or as reference data.
</li>

<li><b>Units</b> used to automate value conversion.</li>

</ul>

<p>A CQL file must start with a vocabulary definition,
and may import elements from one or more other vocabularies.</p>

<dl>
  <dt>statement:</dt>
  <dd>
	  <script>
		Diagram(
			Choice(0,
				Sequence(
					NonTerminal('definition'),
					"';'"
				),
				Sequence(
					NonTerminal('query'),
					"'?'"
				)
			)
		).addTo();
	  </script>
  <dt>definition:</dt>
  <dd>
	  <script>
	  Diagram(
	    Choice(0, 
	      Sequence("'vocabulary'", 'ID'), 
	      NonTerminal('import_def'),
	      NonTerminal('object_type'),
		  NonTerminal('fact_type'),
	      NonTerminal('constraint'),
	      NonTerminal('unit_def')
	  )).addTo();
	  </script>
  </dd>
</dl>

<p>An import definition imports object type names from another
vocabulary, possibly using the <b>alias</b> syntax to rename some
terms. In addition, fact type readings from the imported vocabulary
may subsequently be included in new definitions which provide
translations specific to this vocabulary.</p>

<dl>
  <dt>import_def:</dt>
  <dd>
	  <script>
	  Diagram(
	    Sequence(
	      "'import'",
	      'ID',
	      ZeroOrMore(
	          Sequence(
	              "','", "'alias'", 'ID', "'as'", 'ID'
	          )
	      )
	  )).addTo();
	  </script>
  </dd>
</dl>

<h2>Object Types</h2>

<p>
An object type represents a type of thing that can be perceived or conceived.
Each object type has at least one name (or <b>term</b>), and the word
object type as used throughout this document implies the use of one of these
terms. An object type definition starts with its name, and is one of the
following kinds.  Names in CQL are case sensitive, and it&rsquo;s
conventional practice to use initial capital letters for object type names
(this is required in Object Role Modeling but not in CQL).  It is however
a good way of allowing object type names to be to be distinguished from the
same words in lower case, where they may occur in fact type readings.
</p>

<dl>
  <dt>object type:
  <dd>
  <script>
  Diagram(
    Choice(0,
     NonTerminal('value_type'),
     NonTerminal('entity_type'),
     NonTerminal('named_fact_type')
  )).addTo();
  </script>
</dl>

<h3>Value Types</h3>

<p>A Value Type is a kind of thing which has a single value that may be
written down, that is, a lexical type, like a number, a name, a date,
etc.
</p>

<p>
A value type is usually derived from another value type, where top-level
value types are defined in an imported vocabulary.  A value type may
refine its supertype by the use of <b>length</b> and <b>scale</b>
parameters where relevant. (The ability to define custom parameters is
anticipated in a revision of the language.) A value restriction might
also limit the allowable values from those allowed by the supertype;
these restrictions are discussed below.
</p>

<dl>
  <dt>value_type:
  <dd>
	  <script>
	  Diagram(
	    Sequence(
		  Optional("'each'"),
	      'ID',
	      "'is written as'",
		  Optional("'any'"),
	    'ID',
	    Optional(NonTerminal('vt_parameters')),
	    Optional(NonTerminal('value_constaint'))
	  )).addTo();
	  </script>
  <dt>vt_parameters:
  <dd>
	  <script>
	  Diagram(
		  Optional(
		    Sequence(
			   "'('",
			   NonTerminal('number'),
			   ZeroOrMore(
			   	Sequence("','", NonTerminal('number'))
			   ),
			   "')'"
		   )
	  )).addTo();
	  </script>
</dl>

<p>
Top-level value types are defined by self-reference, e.g.
</p>
<pre>
Integer is written as Integer;
</pre>
<p>
or implicitly by being used as a supertype for another value type.
However, top-level types must be known to any underlying mapping
layer, such as a procedural language or relational database, in
order to be used with that layer.
</p>

<p>Continuing the examples from an model from the Insurance industry:</p>

<pre>
Name is written as String(256);
Price is written as Decimal(18,2);
</pre>

Restrictions can be placed on the values taken by value types.

<dl>
<dt>value_constraint:
<dd>
	<script>
	Diagram(
	   Sequence(
	      "'restricted to'",
	      "'{'",
	      NonTerminal('range'),
	      ZeroOrMore(
	         Sequence(
	            "','",
	            NonTerminal('range')
	         )
	      ),
	     "'}'"
	 )).addTo();
	</script>
<dt>range:
<dd>
	<script>
	Diagram(
	    Choice(0,
	       NonTerminal('numeric_range'),
	       NonTerminal('string_range')
	 )).addTo();
	</script>
<dt>numeric_range:
<dd>
	<script>
	Diagram(
	    Choice(0,
	       Sequence(
	            NonTerminal('number'),
	            Optional(
	                Sequence(
	                    "'..'",
	                    Optional(NonTerminal('number'))
	                )
	            )
	       ),
	      Sequence(
	           "'..'",
	           NonTerminal('number')
	       )
	 )).addTo();
	</script>
<dt>string_range:
<dd>
	<script>
	Diagram(
	    Choice(0,
	       Sequence(
	            NonTerminal('string'),
	            Optional(
	                Sequence(
	                    "'..'",
	                    NonTerminal('string')
	                )
	            )
	       ),
	      Sequence(
	           "'..'",
	           NonTerminal('string')
	       )
	 )).addTo();
	</script>
</dl>

<p>Note that the ranges in a value restriction may be open ended at
one end.</p>

<p>Continuing examples from the Insurance industry model:</p>

<pre>
Claim Sequence is written as Unsigned Integer(32) restricted to {1..999};
Contact Method is written as Char(1) restricted to {'B', 'H', 'M'};
</pre>

<h3>Entity Types</h3>

<p>
Each Entity Type plays roles in at least one fact type, and is identified
by the combination of one or more such roles. At least one identifying role
is mandatory. CQL uses the closed-world assumption for non-mandatory
identifying roles, which means that the same identifier (with the same
role missing) may not occur more than once in a population.
</p>

<dl>
  <dt>entity_type:
  <dd>
	  <script>
	  Diagram(
		  Sequence(
			  Optional("'each'"),
			  "ID",
			  "'is'",
        	   Choice(0,
			       Sequence(
					   Optional("'independent'"),
		   	           NonTerminal('identification')
			       ),
			      Sequence(
			           NonTerminal('entity_subtype'),
			           Optional(
			                 NonTerminal('identification')
			           )
			      )
			  ),
			  Optional(
			  	Sequence(
					  "'where'",
					  NonTerminal('reading')
			  	)
			  )

	  )).addTo();
	  </script>
  <dt>entity_subtype:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
	        Choice(0, "'is a subtype of'", "'is a kind of'"),
			 Optional("'independent'"),
	        'ID',
	        ZeroOrMore(
	           Sequence(
	               "','", 'ID'
	           )
	        )
	  )).addTo();
	  </script>
  <dt>identification:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
	        "'identified by'",
	        Choice(0,
	            Sequence(
	                "'its'",
	                'ID',
	                NonTerminal('vt_parameters'),
					Optional(
						Sequence(
							NonTerminal('value_constraint'),
							NonTerminal('enforcement')
						)
					)
	             ),
	             NonTerminal('role_list')
	        )
	   )).addTo();
	  </script>
</dl>

<p>The simplest form of entity identification scheme is by a single
role value, for which the reference mode shorthand is provided, as in:
</p>
<pre>
    Thing is identified by its Value;
</pre>

<p>
<tt>Value</tt> is assumed to be (or created as) a value type.
A subtype of <tt>Value</tt> is assumed (or created) called <tt>ThingValue</tt>.
The <tt>Thing</tt> is then associated in an identifying one-to-one
fact type with <tt>ThingValue</tt>. The result is equivalent to saying:
</p>
<pre>
    ThingValue is written as Thing;
    Thing is identified by ThingValue where
	Thing has one ThingValue,
	ThingValue is of at most one Thing;
</pre>

<p>
If the default fact type readings (<em>has/is of</em>) aren't appropriate,
you can provide one or more alternative readings. The required uniqueness
and mandatory constraints are still added where needed.
</p>
<pre>
    Thing is identified by its Name where
	Thing is called ThingName;
</pre>

<p>Continuing the examples from an model from the Insurance industry:</p>

<pre>
Asset is identified by its ID;
Hospital is identified by its Name;

Liability is identified by its Code restricted to {'D', 'L', 'R', 'U'};
</pre>

<h3>Subtypes</h3>

<p>An entity type may be declared to be a subtype (or more informally,
using the word &ldquo;kind&rdquo;) of one or more other entity types,
the supertypes.  Any subtype may play any of the roles of its supertypes.
A subtype may have its own identification scheme, but doesn't need to.
It will be identified by its relationship with its first supertype.
</p>

<pre>
    Apple is a kind of Fruit;

    Employee is a kind of Person identified by its Number;
</pre>

<pre>
    ShelfLife is written as Time in days;
    Perishable has at most one ShelfLife;
    Fruit has one Price per kg;
    Apple is a kind of Fruit, Perishable;
</pre>

<p>In these fact types, each apple must have a price and may record
a shelf life.</p>

<p>Declaring a subtype creates subtyping fact types, which is useful
when subtyping relationships must be constrained.</p>

<p>Continuing the examples from an model from the Insurance industry:</p>

<pre>
Person is a kind of Party;
Vehicle is a kind of Asset identified by VIN
</pre>

<h3>Identification</h3>

<p>Explanation TBC</p>

<p>Continuing the examples from an model from the Insurance industry:</p>

<pre>
State is independent identified by its Code;
</pre>

<h3>Role References</h3>

<p>
The full form of identification must be used where a new entity type is
identified by its relationship to another entity type, where adjectives
are applied, or where the entity type has more than one identifying role.
In this last case, at least one reading must be provided for each fact
type involved in the identification. Normally these readings will
embed the appropriate uniqueness constraints to create each one-to-many
relationship.  Each fact type reading in an entity type definition must
involve the entity type and one of the identifying roles, and no other
roles.
</p>

<dl>
  <dt>role_list:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
			 Optional("'any'"),
			 NonTerminal('role_ref'),
             ZeroOrMore(
                Sequence(
                     Choice(0, "'and'", "','"),
                     NonTerminal('role_ref')
                )
             )
	   )).addTo();
	  </script>
  <dt>role_ref:
  <dd>
	  <script>
	  Diagram(
	  		  Choice(0,
	  	 	     Sequence(
	  	 	        ZeroOrMore(
	  	 	           Sequence(
	  	 	               'ID', Optional("'-'")
	  	 	           )
	  	 	        ),
	  	 	        'ID',
	  	 	        ZeroOrMore(
	  	 	            Sequence(
	  	 	               Optional("'-'"),
	  	 	               'ID'
	  	 	            )
	  	 	        )
	  			),
	  			Sequence('ID', "'('", "'as'", 'ID', "')'"),
	  			Sequence('ID', "'('", NonTerminal('decimal'), "')'")
	   )).addTo();
	  </script>
</dl>

<p>
Note that hyphens are used here to indicate the use of adjectives, which
can be either leading or trailing as required by the language. The hyphen
is only required once within a declaration, and this associates the
adjective with that role player throughout this declaration.
</p>

<pre>
    Person is identified by given-Name and family-Name where
	Person is called one given Name, given Name is of Person,
	Person has one family Name, family Name is of Person;
</pre>

<p>Note that the uniqueness constraints for these fact types are
shown. They could alternatively be provided later, but must be
included within the same vocabulary.
</p>

<p>
Hyphens may be used to designate multiple adjectives, but must
have a space beside the hyphen, on the side of the existing object
type name. Otherwise the pair of (previously unseen) words is treated
as a simple hyphenated term:
</p>

<pre>
    suitably- trained Person is allowed to drive semi-trailer;
</pre>

<p>
Finally, when the full form of identification is used, but there are fact type
readings all referring to the same roles <em>none of which is the defined entity
type</em>, these are the readings of a new fact type, which is objectified (named)
as the new entity type. This is discussed below, but in this case, the entity type
has an identification scheme which is not drawn from the fact type roles.
</p>

<h2>Fact Types</h2>

<p>
Fact types are declared as one or more fact type readings. Each
reading provides a verbal description of the relationship between
two or more object types, or a property of a single object type.
Each object type is referred to as "playing a role" in the fact
type.
</p>

<p>
All the readings of a fact type must have the same set of role
players.  The first reading of a fact type is the default reading,
and provides the identification scheme when needed (when the fact
type is objectified).
</p>

<dl>
  <dt>named_fact_type:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
			 'ID', "'is where'",
	       NonTerminal('fact_type')
	   )).addTo();
	  </script>
  <dt>fact_type:
  <dd>
	  <script>
	  Diagram(
	  	     Sequence(
	  	           NonTerminal('reading'),
				  ZeroOrMore(
				  	Sequence(
				  		"','",
						NonTerminal('reading')
				  	)
				  )
	  	   )).addTo();
	  </script>
  <dt>reading or query_clauses:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
		   NonTerminal('qualified_clauses'),
		   ZeroOrMore(
		       Choice(0, "'and'", "'or'"),
		       NonTerminal('qualified_clauses')
		   )
	   )).addTo();
	  </script>
</dl>	   
	   
<p>Each fact type reading may contain a quantifier expression before the
last role player, which can assert mandatory, uniqueness or frequency
constraints over the allowed population of instances of that fact. A
qualifier that asserts a ring constraint (see below) may also follow a
reading.
</p>

<p>Note that a fact type does not have to be named; it can simply
be a set of readings.  Naming makes the fact type an <em>object
type</em>, and is required whenever no unique quantifier exists in
the fact type, or where there are more than two roles.  Where a
fact type isn&rsquo;t named, it cannot play roles in other fact
types. This example shows an un-named and a named (objectified)
fact type:
</p>

<pre>
    Person was born at one birth-Place;
    Directorship is where Person directs Company;
</pre>

<p>
If an object type plays more than one role in a fact type, the
separate roles must be distinguished by either adjectives or a
defined role name. See the resolution rules under Resolving roles for
more details.
</p>

<h3>Certainty and Qualifiers</h3>

<p>Certainty TBC</p>

<p>The qualifiers are encased in square brackets, and are most commonly
used for ring constraints. See the section on constraints for more
details. The <tt>maybe</tt> outer-join qualifier is only used in
derivation clauses. Derivations are discussed below, under queries.</p>
	   
<dl>	   
  <dt>qualified_clauses:
  <dd>
	  <script>
	  Diagram(
	  	     Sequence(
                 NonTerminal('certainty'),	  		   
                 NonTerminal('contracted_clauses'),
                 Optional(NonTerminal('qualifiers'))
	   	   )).addTo();
	  </script>
  <dt>certainty:
  <dd>
	  <script>
	  Diagram(
 		   Choice(0,
                 Skip(),
                "'definitely'",
                "'maybe'",
                "'it is not the case that'"
            )
	  ).addTo();
	  </script>
  <dt>qualifiers:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
	       "'['",
	       NonTerminal('qualifier'),
	       ZeroOrMore(
	            Sequence(
	               "','",
	               NonTerminal('qualifier')
	            )
	        ),
	       "']'"
	   )).addTo();
	  </script>
  <dt>qualifier:
  <dd>
	  <script>
	  Diagram(
  	     Choice(0,
           "'static'",
           "'transient'",
           "'intransitive'",
           "'strongly intransitive'",
           "'transitive'",
           "'acyclic'",
           "'symmetric'",
           "'antisymmetric'",
           "'reflexive'",
           "'irreflexive'"
	   	   )).addTo();
	  </script>
</dl>

<pre>
Product may be substituted by alternate-Product in Season [acyclic, intransitive]
Topic belongs to at most one parent-Topic [acyclic];
Girl (as Girlfriend) is going out with at most one Boy (as Boyfriend) [symmetric]
</pre>

<h3>Contraction</h3>

<dl>  
   <dt>contracted_clauses:
   <dd>
 	  <script>
	   Diagram(
   	     Choice(0,
	           NonTerminal('comparison'),
	           OneOrMore(
	               Choice(0,
	                  NonTerminal('contraction'),
	                  NonTerminal('phrase')
	               )
	           )
	   	   )).addTo();
	  </script>
   <dt>contraction:
   <dd>
 	  <script>
	   Diagram(
   	     Choice(0,
               NonTerminal('reading_contraction'),
               NonTerminal('condition_contraction')
	   	   )).addTo();
	  </script>
   <dt>reading_contraction:
   <dd>
 	  <script>
	   Diagram(
   	     Sequence(
               NonTerminal('role'),
               Optional(NonTerminal('qualifiers')),
               Choice(0, "'that'","'who'"),
               NonTerminal('certainty'),
               NonTerminal('contracted_clauses')
	   	   )).addTo();
	  </script>
   <dt>condition_contraction:
   <dd>
 	  <script>
	   Diagram(
	   	     Sequence(
	                   NonTerminal('role'),
	                   Optional(NonTerminal('qualifiers')),
	                   NonTerminal('certainty'),
	                   NonTerminal('comparator'),
	                   NonTerminal('expression')
	   	   )).addTo();
	  </script>
   <dt>comparison:
   <dd>
 	  <script>
	   Diagram(
	     Choice(0,
	   	     Sequence(
	                   NonTerminal('expression'),
	                   NonTerminal('certainty'),
	                   NonTerminal('comparator'),
	                   NonTerminal('contraction'),
	                   Optional(NonTerminal('qualifiers'))
	               ),
	              Sequence(
	                  NonTerminal('certainty'),
	                  NonTerminal('expression'),
	                  NonTerminal('comparator'),
	                  NonTerminal('expression')
	              )
	   	   )).addTo();
	  </script>	   
</dl>

<h3>Roles in Fact Types</h3>

<dl>  
   <dt>phrase:
   <dd>
 	  <script>
	   Diagram(
	      Choice(0,
	   	      NonTerminal('role'),
	          NonTerminal('role_ref')
	   	   )).addTo();
	  </script>
   <dt>role:
   <dd>
 	  <script>
	   Diagram(
	        Choice(0,
	            NonTerminal('aggregate'),
	            NonTerminal('simple_role')
	   	   )).addTo();
	  </script>
   <dt>aggregate:
   <dd>
 	  <script>
	   Diagram(
        Sequence(
            NonTerminal('ID'),
            "'of'",
            NonTerminal('role_ref'),
            "'in'",
            "'('",
            NonTerminal('reading'),
            "')'"
	   	   )).addTo();
	  </script>
   <dt>simple_role:
   <dd>
 	  <script>
	   Diagram(
        Sequence(
            Optional(
                 Sequence(
                     NonTerminal('qualifier'),
                     NonTerminal('enforcement')
                 )
            ),
            NonTerminal('role_ref'),
            Choice(0,
                  Sequence(
                        NonTerminal('literal'),
                        Optional(NonTerminal('unit'))
                  ),
                  Sequence(
                        NonTerminal('value_constraint'),
                        NonTerminal('enforcement')
                   )                  
             ),
            Optional(NonTerminal('objectification'))
	   	   )).addTo();
	  </script>
</dl>

<p>
The syntax here is ambiguous, because a fact_role consists of one or
more IDs with optional hyphens to indicate adjectives, interspersed
with arbitrary linking words (also IDs).  So how is the ambiguity resolved?
</p>

<p>
First of all, CQL looks through all the readings in this definition,
and finds the occurrences of known object type names. Each occurrence
may be followed by the definition of a role name, or may have
one or more associated adjectives attached using a hyphen (dash).
Adjectives may not be the same as the name of any object type,
or of any local role name, and the complete term (with adjectives)
must likewise be unique.
</p>

<p>
A subsequent scan finds all occurrences of these role names and
terms with adjectives (which now don't require the hyphen).  Any
remaining words are the open vocabulary which forms the reading
that designates this fact type.
</p>

<p>
When a fact type reading is re-iterated in order to invoke an
existing fact type, for example in a constraint, in a derivation
or to add a new reading to an existing fact type, there may be
adjectives in the definition of the invoked fact type. These also
must be matched in the reading.
</p>

<h4>Quantifiers</h4>

<p>
The final role in a reading may be preceeded by a quantifier, which does
not form a part of the reading. These are normally used to apply a
uniqueness constraint (<tt>at most one</tt>), a mandatory constraint
(<tt>at least one</tt>) or both (<tt>exactly one</tt> or just
<tt>one</tt>). Other forms allow various other role frequency
constraints. The <tt>quantity</tt> here may be a positive integer or the
word <tt>one</tt>. Note that some quantifiers are only used in derivations
or in constraints.
</p>

<dl>
<dt>quantifier:
<dd>
	<script>
	Diagram(
	   Choice(0,
	      "'some'",
	      "'that'",
	      "'one'",
	      Sequence("'exactly'", NonTerminal('quantity')),
	      Sequence("'at least'", NonTerminal('quantity')),
	      Sequence("'at most'", NonTerminal('quantity')),
	      Sequence(
	            "'at least'", NonTerminal('quantity'), "'and at most'", NonTerminal('quantity')
	      ),
	      Sequence(
	           "'from'", NonTerminal("decimal"), "'to'", NonTerminal('decimal')
	      )
	 )).addTo();
	</script>
<dt>quantity:
<dd>
	<script>
	Diagram(
		Choice(0, "'one'", NonTerminal('number'))
	).addTo();
	</script>
</dl>

<p>In this way, CQL absorbs many of the uniqueness, mandatory and
frequency constraints of Object Role Modeling.
</p>

<p>The only ORM
characteristic that cannot be expressed this way is a non-mandatory
constraint having a minimum frequency above one; for example a
constraint that allows zero, or more than two, occurrences. For
example, in a footy tipping competition, it might be the case that
if a participant submits no tips this week, they get the tips
published by a known tipster, but if they do submit tips, they must
submit at least eight. This kind of non-mandatory frequency
constraint may be expressed in CQL using the <b>maybe</b>
qualifier, which is also used in outer join derivations.</p>

<pre>
    maybe Participant entered at least 8 Tips
</pre>

<h3>Value Restrictions</h4>

<p>
A value restriction may follow a role reference where the role is
played by a value type (or by an entity type ultimately identified
by a single value type), and this constrains the allowed values of
that value type in this role. In addition to fact type definitions,
a value or a value restriction may be applied to fact instances
and in derivations, where it has the obvious effect.
</p>

<h3>Objectification</h3>

<dl>
   <dt>objectification:
   <dd>
 	  <script>
	   Diagram(
        Sequence(
            "'('", "'in which'", NonTerminal('reading'), "')'"
	   	   )).addTo();
	  </script>
</dl>


<pre>
Service (in which Waiter served Meal) earned a tip of Amount
</pre>

<h2>Constraints</h2>

<p>Quantifiers allow the definition of the most common kinds of
constraints, the mandatory, uniqueness and frequency constraints
(collectively, CQL calls these <b>presence constraints</b>). Often
there are constraints that cannot be expressed in this form
however, such as when an object type must play one of many unrelated
roles. This is handled in CQL by the use of an external constraint
definition, or with a ring constraint qualifier.</p>

<dl>
<dt>constraint
<dd>
	<script>
	Diagram(
	    Choice(0,
	       NonTerminal('presence_constraint'),
	       NonTerminal('subset_constraint'),
	       NonTerminal('set_constraint'),
	       NonTerminal('equality_constraint')
	 )).addTo();
	</script>

</dl>
	 
<h3>Presence constraints</h3>

<p>When a single role player must play one and only one (or at
least one) of a set of roles, we can say:</p>

<dl>
<dt>presence_constraint:
<dd>
	<script>
	Diagram(
	    Choice(0,
	        Sequence(
	           "'each'",
				Optional("'combination'"),
			   NonTerminal('role_list'),
	           "'occurs'",
	           NonTerminal('quantifier'),
	           Choice(0, "'time'", "'times'"), 
	           NonTerminal('enforcement'),
	           "'in'",
	           NonTerminal('clauses_list')
	        ),
	       Sequence(
	            Optional("'either'"),
	            NonTerminal('clauses'),
	            "'or'",
	            NonTerminal('clauses'),
	            NonTerminal('enforcement')
	       )
	 )).addTo();
	</script>
<dt>clauses_list:
<dd>
	<script>
	Diagram(
		Sequence(
			NonTerminal('clauses'),
			ZeroOrMore(
				"','",
				NonTerminal('clauses')
			)
		)
	).addTo();
	</script>
<dt>clauses:
<dd>
	<script>
	Diagram(
		Sequence(
			NonTerminal('contracted_clauses'),
			ZeroOrMore(
				"'and'",
				NonTerminal('contracted_clauses')
			)
		)
	).addTo();
	</script>
</dl>
 
For example:
 
<pre><b>each</b> Range <b>occurs</b> at least one <b>time in</b>
	Range has minimum-Bound,
	Range has maximum-Bound;
</pre>

<p>For example, supposing that we were to identify Person instances
by given name and family name (not a good idea in a real system!)
we need to ensure that the <b>combination</b> given name, family
name is unique. We can say:</p>

<pre>
<b>each</b> family Name, given Name <b>occurs</b> at most one<b> time in</b>
	Person is known by given-Name,
	Person has family-Name;
</pre>

<h3>Set Constraints</h3>

<dl>
<dt>set_constraint
<dd>
	<script>
	Diagram(
	    Choice(0,
	        Sequence(
	           "'for each'",
	           NonTerminal('role_list'),
	           NonTerminal('quantifier'),
	           "'of these holds'",
	           NonTerminal('enforcement'),
	           "':'",
	           NonTerminal('clauses_list')
	        ),
	       Sequence(
	            Optional("'either'"),
	            NonTerminal('clauses'),
	            "'or'",
	            NonTerminal('clauses'),
	            "'but not both'",
	            NonTerminal('enforcement')
	       )
	 )).addTo();
	</script>

</dl>

<pre>
<b>for each</b> ReceivedItem exactly one<b> of these holds:</b>
	ReceivedItem is for PurchaseOrderItem,
	ReceivedItem is for TransferRequest;
</pre>

<pre>
<b>for each</b> Unit exactly one <b>of these holds</b>:
	Unit is fundamental,
	that Unit is derived from some base-Unit;
</pre>

In the case where one of two fact types applies, you can use the more
natural form:

<pre>
<b>either</b> Unit is fundamental
<b>or</b> Unit is derived from some base-Unit
<b>but not both</b>;
</pre>

<h3>Subset Constraints</h3>

<p>When one role may be played only if another is, you can use a
subset constraint:</p>

<dl>
<dt>subset_constraint
<dd>
	<script>
Diagram(
    Sequence(
        NonTerminal('clauses'),
                'only if', NonTerminal('clauses'),
       NonTerminal('enforcement')
 )).addTo();
 </script>
</dl>
 
 For example:
 
<pre>
	Address has third-StreetLine
	<b>only if</b>
	Address has second-StreetLine;
</pre>

<p>Note that this example didn&rsquo;t use the first and second
StreetLine, as we assume that the first StreetLine is a mandatory
part of the address, so the subset constraint would be
redundant.</p>

<h3>Equality Constraints</h3>

<p>Equality constraints declare that the populations of two or more
roles (or sequences of roles) are the same. They are expressed using
&lsquo;if and only if&rsquo;:</p>

<dl>
<dt>equality_constraint
<dd>
	<script>
	Diagram(
	    Sequence(
	        NonTerminal('clauses'),
	        OneOrMore(
	             Sequence(
	                'if and only  if', NonTerminal('clauses')
	             )
	        ),
	       NonTerminal('enforcement')
	 )).addTo();
	</script>
</dl>

For example:

<pre>
Competition is in Series
	<b>if and only if</b>
	Competition has series-Number;
</pre>

<h3>Ring Constraints</h3>

<p>When a fact type includes the same object type more than once, or
includes a supertype and its subtype, there&rsquo;s the possibility
of the same instance playing both roles. This is often not desired,
but further it introduces a whole class of further situations which
can be restricted using ring constraints. The CQL keywords used in
fact clause qualifiers for ring constraints are the following:</p>

<p><b>intransitive</b>,<b> transitive</b>,<b> acyclic</b> and <b>
symmetric</b>. Intransitive means that just because &ldquo;A
relates to B&rdquo;, and &ldquo;B relates to C&rdquo;, that
doesn&rsquo;t mean that&nbsp; &ldquo;A relates to C&rdquo;.
Transitive means the opposite. Acyclic means that no A may relate
to itself, or to any B that has that relation to A, and so on.
Symmetric means that if A relates to B, B also relates to A (so
there is only one fact instance possible between A and B).</p>

<p>This method for defining ring constraints is not fully general,
and a new syntax is required for covering complex cases</p>

<h3>Join constraints</h3>

<p>Most of the above constraint types may use joins, where more
than one fact type is joined together with the <b>and</b> keyword.
A full discussion is beyond the scope of this paper, but
here&rsquo;s a small example of a subset constraint using a
join:</p>

<pre>
Diplomat speaks Language;
Country uses Language, Language is spoken in Country;
Diplomat serves in Country;

Diplomat serves in Country
	<b>only if</b>
	Country uses Language <b>and</b> Diplomat speaks Language;
</pre>

<p>This constraint requires that in order to serve in a country, a
diplomat must speak at least one language used in that country.
Many joins may be <em>contracted</em> using <em>who</em> or <em>that</em>.
This example contracts like this:
</p>

<pre>
Diplomat serves in Country
	<b>only if</b>
	Diplomat speaks Language <b>that</b> is spoken in Country;
</pre>

<h3>Enforcement</h3>

<p>To be completed.</p>

<dl>
<dt>enforcement:
<dd>
	<script>
	Diagram(
	     Sequence(
	         "'('",
	         "'otherwise'",
	         NonTerminal('action'),
	        "')'"
	   )).addTo();
	</script>
</dl>	

<h2>Instances</h2>

<h3>Value Instance</h3>

<p>A value instance is defined by stating the name of the value type followed by
the lexical representation of the value. An entity having a single identifying role
may be defined exactly the same way, which also defines the required identifying
instance (in the third example here, a value). Within a vocabulary, an instance
is asserted into the sample population, but in other contexts another population
may be the target (the metamodel supports arbitrary named populations).</p>

<pre>
    CompanyName 'Microsoft';
    Year 1999;
    Company 'Microsoft';
</pre>
	
<h3>Fact Instances</h3>

<p>When a fact reading is invoked with values, a fact instance
is created. The simplest is where a declaration is just an object type
name followed by a value:</p>

<pre>
    Name &lsquo;Fred&rsquo;;
</pre>

<p>This form is allowed for any value type, or any entity type
that&rsquo;s identified by a single value type (or an entity
identified by a single entity identified by a single value type,
etc). In more complex cases, it might be necessary to invoke more
than one fact type to define the instance:</p>

<pre>
    Person is called given name &lsquo;Fred&rsquo;,
	Person has family Name &lsquo;Bloggs&rsquo;;
</pre>

<p>or</p>

<pre>
    given Name &lsquo;Fred&rsquo; is of Person <b>who</b> has family Name &lsquo;Bloggs&rsquo;;
</pre>

<p>The Person instance being defined is a reference to the same
instance in each fact type reading; there is an implicit join over
the two clauses.
</p>

<p>
An <em>objectification join</em> allows traversal of an objectified
fact type:
</p>

<pre>
    Directorship <b>(where</b> Person &lsquo;Fred Bloggs&rsquo; directs Company &lsquo;Acme, Inc&rsquo;<b>)</b>
      began on appointment Date &lsquo;2010-04-27&rsquo;;
</pre>

<h2>Fact Derivation (Queries)</h3>

<p>Fact derivation is a large subject by itself, so we&rsquo;ll
leave a detailed coverage for a future paper. Here&rsquo;s a short
introduction however.</p>

<p>When a fact type has the optional clauses that define its
derivation, the population of that fact type is derived as a <b>
query</b> over the fact types it invokes. Each condition clause is
either a comparison, which compares a role value with a constant or
another role value, or a fact type reading.</p>

<p>For a reading, at least one role must match an occurrence of
that role in the new fact type or in another reading in the
derivation. This match defines a logical <b>join</b> operation
across the fact populations. Where the same object type occurs in
different roles, and those roles are not to be joined, additional
adjectives or defined role names may be used to separate the
roles.</p>

<!--p>The values may be modified by functions, such as the built-in
functions on the Date value type which can extract the year, month,
day, etc from the Date.</p-->

<p>It&rsquo;s possible to negate any invoked fact type by inserting
the word <b>no</b> into it as a quantifier, or <b>not</b> as an
additional linking word. Here are some examples of fact type
derivations (the full fact type definition is elided):</p>



<pre>
    Person has family Name,
	family Name = &lsquo;Bloggs&rsquo;,
	Person is <b>not</b> called given Name &lsquo;Fred&rsquo;,
	Person is a kind of Employee,
	Employee is managed by <b>no</b> Manager<b>;</b>
</pre>

<h3>Result Constellations</h4>

<p>A fact derivation may include a <b>returning</b> clause.
Normally, when processing a query, only the object instances that
play the roles of the derived fact type (and satisfy the query)
will be available in the results, and there is no defined ordering
in the values. When the returning clause is used, additional
object and fact instances may be accessible from the result,
which may also be sorted. This extension of the result set is
transitive, so that if a derived fact type invokes another derived
fact type, the returned instances from the invoked fact
type&rsquo;s returning clause will also be available.</p>

<p>The results now include more than just a simple table of the
instances that play the roles of the derived fact type. Instead,
each object instance may be associated with additional facts for
other roles it plays, and the roles of those facts will be
populated by further object instances, and so on. This data
structure is hereby defined as a <b>constellation</b>, which is
where CQL gets its name. The query has selected certain instances
from the entire fact population, much as an astronomer might select
stars from the night sky.</p>

<p>The use of <b>returning</b> doesn&rsquo;t change the contents of
the defined fact type, it&rsquo;s merely a pragmatic instruction to
the query engine about which additional instances will be useful to
the calling program, and in what order.<br clear="all" />
</p>


<dl>
  <dt>query:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
			NonTerminal('query_clauses'), 
	        Optional(
	            Sequence(
	                "'where'",
	                NonTerminal('query_clauses')
	            )
	       ),
	       Optional(
	           NonTerminal('returning_clause')
	       )
	   )).addTo();
	  </script>
  <dt>returning_clause:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
			"'returning'", 
	        ZeroOrMore(
	            Sequence(
	                "','",
	                NonTerminal('phrase')
	            )
	       )
	   )).addTo();	  
	  </script>
</dl>

<h2>Unit Definitions</h2>

<p>A unit definition defines a new unit identifier in terms of an
optional coefficient (real number or integer fraction) multiplied by one
or more base units, each raised to an integer power. It's common to
define the singular form of a unit, then also define the plural as
equivalent.
</p>

Units are defined by declaring conversion formulae involving base units. Both
singular and plural names may be given. If a base unit is not otherwise defined,
it is assumed to be fundamental. Formulae are limited to a coeficient and an
offset (<it>ax</it> + <it>c</it>), where <it>x</it> may be any number of existing units each raised to
any integer power. Conversion coeficients have a real numerator and an integral
denominator which defaults to 1. The formula may be written in either direction,
but the constants must be on the side of the base units. An extensive library
of standard unit conversions is available. Ephemeral conversions can be defined;
the conversion factor at a particular time is assumed to be available from some
source. Approximate conversions can be annotated.

<dl>
<dt>unit_def:
<dd>
    <script>
	Diagram(
		  Sequence(
			 Optional(NonTerminal('coefficient')),
		     Optional(NonTerminal('units')),
		     Optional(
				 Sequence(
					 "[+-]",
				 	NonTerminal('number')
				 )
				 
			 ),
			 "'converts to'",
			 'ID',
			 Optional(
			 	Sequence("'/'", 'ID')
			 ),
			 Choice(0,
				 Skip(),
			 	 "'approximately'",
				 "'ephemera'"
			 )
		)).addTo();
	</script>
<dt>coefficient:
<dd>
	<script>
	Diagram(
	  Sequence(
		  NonTerminal('number'),
		  Optional(
		  	Sequence("'/'", NonTerminal('number'))
		  )
	  )).addTo();
	  </script>
<dt>units:
<dd>
	<script>
	Diagram(
	  Sequence(
	     NonTerminal('power_unit'),
		 ZeroOrMore(NonTerminal('power_unit')),
		 Optional(
	         Sequence(
	             "'/'",
			     NonTerminal('power_unit'),
				 ZeroOrMore(NonTerminal('power_unit'))
	         )
		)
	)).addTo();
	</script>
<dt>power_unit:
<dd>
	<script>
	Diagram(
		Sequence(
			'ID',
			Optional(
				Sequence(
					"'^'",
					Optional("'-'"),
					'[0-9]' 
				)	
		)
	)).addTo();
	</script>
</dl>

<pre>
25.4 millimeters converts to inch/inches;
kelvin + 273.15 converts to celsius;
9/5 celsius + 32 converts to fahrenheit;
acceleration converts to metres second^-2;
g converts to 9.8 acceleration approximately;
0.853 dollarUS converts to dollarAU ephemeral;
</pre>

The use of units in defining value types and in query literals allows dimensional
analysis and automatic conversions. This example shows a derived fact
type ("Pane has Area") and a query that uses units conversion to list large
panes of glass. Notice that the literal in last line has an associated unit (this line
also has a contracted join, see below).

<pre>
Dimension is written as Real in millimeters;
Width is written as Dimension; Height is written as Dimension;
Pane has one Width; Pane has one Height;
Pane has Area where
Pane has Width, Pane has Height,
Area = Width * Height;
Pane has Area > 5 foot^2?
</pre>

<h2>Expressions and Lexical Rules</h2>

Expressions and lexical rules follow standard C, UNIX and HTTP conventions.

<dl>
	<dt>expression:
	<dd>
		<script>
		Diagram(
			Sequence(
				NonTerminal('sum'),
				ZeroOrMore(
					NonTerminal('comparator'),
					NonTerminal('sum')
				)
			)
		).addTo();
		</script>
	<dt>sum:
	<dd>
		<script>
		Diagram(
			Sequence(
				NonTerminal('product'),
				ZeroOrMore(
					Choice(0, "'+'", "'-'"),
					NonTerminal('product')
				)
			)
		).addTo();
		</script>
	<dt>product:
	<dd>
		<script>
		Diagram(
			Sequence(
				NonTerminal('factor'),
				ZeroOrMore(
					Choice(0, "'*'", "'/'", "'%'"),
					NonTerminal('factor')
				)
			)
		).addTo();
		</script>
   <dt>factor:
   <dd>
	<script>
	Diagram(
		Choice(0,
			Sequence(
				NonTerminal('literal'),
				Optional(NonTerminal('unit'))
			),
			NonTerminal('role_ref'),
			Sequence(
				"'('",
				NonTerminal('expression'),
				"')'"
			)
		)
	).addTo();
	</script>
   <dt>comparator:
   <dd>
 	  <script>
	   Diagram(
            Choice(0,
	   	       "'<='", "'<>'" , "'<'" , "'='" , "'>='" , "'>'" , '!='
	   	   )).addTo();
	  </script>
	<dt>literal
	<dd>
		<script>
		Diagram(
			  Choice(0,
		 	     NonTerminal('boolean'),
	             NonTerminal('string'),
	             NonTerminal('number')
			)).addTo();
		</script>
	<dt>boolean
	<dd>
		<script>
		Diagram(
		    Choice(0,
		        "'true'", "'false'"
		 )).addTo();
		</script>
	<dt>string
	<dd>
		<script>
		Diagram(
		    Sequence(
		        "'", ZeroOrMore('CHAR'), "'"
		 )).addTo();
		</script>
	<dt>number
	<dd>
		<script>
		Diagram(
		  Choice(0,
			 Sequence("'", 'CHAR', "'")
	 	     NonTerminal('decimal'),
			 NonTerminal('real'),
             NonTerminal('octalnumber'),
             NonTerminal('hex number')
		)).addTo();
		</script>
	<dt>decimal
	<dd>
		<script>
		Diagram(
				  Sequence(
			 	     Choice(0, Skip(), "'+'", "'-'"),
		             Choice(0,
                          Sequence("[1-9]", ZeroOrMore("[0-9]")),
                          "0"
                     )
				)).addTo();
		</script>
	<dt>real
	<dd>
		<script>
		Diagram(
				  Sequence(
			 	     Choice(0, Skip(), "'+'", "'-'"),
		                     Choice(0,
		                          Sequence("[1-9]", ZeroOrMore("[0-9]"), Optional(NonTerminal('fraction'))),
		                          Sequence("0", NonTerminal('fraction'))
		                     ),
		                    Optional('exponent')
				)).addTo();
		</script>
	<dt>fraction
	<dd>
		<script>
		Diagram(
				  Sequence(
			 	     "'.'", OneOrMore("[0-9]")
				)).addTo();
		</script>
	<dt>exponent
	<dd>
		<script>
		Diagram(
				  Sequence(
			 	     "'('", "[Ee]", Choice(0, Skip(), "'+'", "'-'"), OneOrMore("[0-9]"), "')'"
				)).addTo();
		</script>
	<dt>hexnumber
	<dd>
		<script>
		Diagram(
				  Sequence(
			 	     "'0x'", OneOrMore("[0-9A-Fa-f]")
				)).addTo();
		</script>
	<dt>octalnumber
	<dd>
		<script>
		Diagram(
				  Sequence(
			 	     "'0'", OneOrMore("[0-7]")
				)).addTo();
		</script>
	<dt>regular_expression
	<dd>UNIX-style regular expression
	<dt>url
	<dd>HTTP-stule URL
</dl>

<h4>Footnotes</h4>
<ol>
  <li><a href="http://ormfoundation.org/" name="ftn1" title="">The ORM Foundation</a>
  </li>

  <li><a href="http://en.wikipedia.org/wiki/Semantics_of_Business_Vocabulary_and_Business_Rules" name="ftn2"
    title="Semantics of Business Vocabulary and Business Rules">Semantics
    of Business Vocabulary and Business Rules</a>
  </li>
</ol>
</div>


	</div>
</div>
<div id="footer" class="noprint">
	<p>Copyright &copy; 2015 Infinuendo</p>
</div>
</body>
</html>


