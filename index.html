<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>CQL Introduction</title>
<meta name="description" content="CQL Introduction" />
<meta name="keywords" content="fact based modeling, fact based modelling, data constellation, information management, semantic modelling,activefacts" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link rel="icon" href="/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="css/style.css" media="screen" type="text/css" />
<link rel="stylesheet" href="css/screen.css" media="screen" type="text/css" />
<!--[if lte IE 6]>
  <link rel="stylesheet" href="css/screen.ie6.css" media="screen" type="text/css" />
<![endif]-->
<link rel="stylesheet" href="css/print.css" media="print" type="text/css" />
<link rel="stylesheet" href="css/railroad-diagrams.css">
<link rel="stylesheet" href="css/local.css" media="screen" type="text/css" />
<style>
body svg.railroad-diagram {
	background-color: hsl(30,20%, 95%);
}
h2 {
	font-family: sans-serif;
	font-size: 1em;
}
svg.railroad-diagram path,
svg.railroad-diagram rect
{
	stroke-width: 2px;
}
.railroad-diagram .terminal text {
	fill: #44F;
}
div svg.railroad-diagram {
	width: 80%;  /* Scale to the width of the parent */
	height: 100%;  /* Preserve the ratio. Could be related to https://bugs.webkit.org/show_bug.cgi?id=82489 */
}
</style>
</head>
<body>

<link rel="stylesheet" href="css/offline.css" media="screen" type="text/css" />

<style type="text/css" id="internalStyle">
dt {
	font-weight: bold;
	padding-bottom: 5px;
}
dd {
	padding-bottom: 10px;
}
</style>

<style>
div svg.railroad-diagram {
	width: 80%;  /* Scale to the width of the parent */
	height: 100%;  /* Preserve the ratio. Could be related to https://bugs.webkit.org/show_bug.cgi?id=82489 */
}
</style>
<script src='js/railroad-diagrams.js'></script>

<h1>
Introduction to the Constellation Query Language
</h1>
<p>The Constellation Query Language (<strong>CQL</strong>) is a language for constructing and querying
<strong>fact-based information models</strong>. It is a textual representation of the graphical
<a href="#ftn1" title="ORM Foundation"><strong>Object Role Modeling</strong></a> language, which
fully implements semantics isomorphic to Codd's Relational Calculus.
</p>

<h5>Open Vocabulary</h5>

<p>
CQL has an open vocabulary (almost any linking words or expressions may be used in defining fact types)
because it is designed to resemble natural language. Only certain key words and key phrases are restricted.
Some keywords are disallowed in any open text, because they always have their special meaning,
whereas others are only special in certain contexts.
In most cases the individual words of key phrases are not restricted; only the complete phrase is special.
CQL allows free use of whitespace and comments, even in the middle of key phrases.
</p>

<h5>Keywords and phrases</h5>

<p>
This introduction to CQL uses English language keywords and phrases,
though CQL also has variants in other natural languages.

Keywords that are special everywhere include the logical operators, such as
<tt>and</tt>, <tt>or</tt>, <tt>maybe</tt>, <tt>not</tt>, <tt>none</tt>, <tt>no</tt>, <tt>if</tt>,
and designators like
<tt>some</tt>, <tt>that</tt>, etc.

Other words of key phrases such as <tt>is</tt>, <tt>identified</tt>, <tt>kind</tt>, <tt>of</tt>,
<tt>as</tt>, <tt>at</tt>, etc, may be used anywhere open vocabulary is allowed.
Their special meaning applies only in the specific places they appear in the grammar.
</p>

<p>
CQL statement are parsed by first identifying key expressions and terms
(including role names and adjectives) while skipping the linking text.
This allows identification of all the object types in each clause.
Each clause is then matched to a fact type which has compatible object types
by using the linking text and adjectives (whether or not a hyphen has been used),
and the whole expression is then analysed. The remaining words of linking text
(with the object types) form a reading which designates this the fact type.
</p>

<h5>Case and Whitespace</h5>

<p>
CQL is <em>case sensitive</em>. <tt>Person</tt> is not the same thing as <tt>person</tt>.
It's convenient however to use a capital letter for the names of all object types (called <strong>terms</strong>,
because the specific sequence of words in an object type name will <em>always</em> designate that
object type, and sometimes the lower-cased version of a name will appear in linking text.
</p>

<p>
White space and comments as similar to C and C++:
<tt>/*&nbsp;comment<br>may&nbsp;span&nbsp;lines&nbsp;*/</tt> and
<tt>//&nbsp;introduces&nbsp;a&nbsp;comment&nbsp;to&nbsp;end&nbsp;of&nbsp;the&nbsp;current&nbsp;line.</tt>
</p>

<h5>Data types and values</h5>

<p>
CQL requires lexical support for only a rudimentary set of data types and literals;
boolean (true/false), numbers (integer, real, scientific), character strings, and
ranges of numbers and strings (ranges may be open at either end).
</p>

<p>
Data types can be refined through the use of parameters to match concrete types
available in typical target data environments and languages, and code generators
will assume reasonable defaults even without that.  You can also define entirely
new data types and their parameters, for use in specialised code generators or
where a target language has a data type that is not special in the code generators.
The syntax for value literals is near the end of this document.
</p>

<h5>CQL Schema</h5>

<p> Every CQL file must begin with a schema definition statement,
then may import (all or part of) other schemas, before starting
new definitions.
</p>

<h5>CQL Definitions</h5>

<dl>
<dt><a href="#ObjectTypes">Object Types</a></dt>
<dd>
Every <strong>Object Type</strong> has a name (a <strong>Term</strong>) consisting of one or more words.
Each word starts with a letter and continues with any alphanumeric or underscore characters.
A Term may be a prefix of another Term, but may not overlap (end with a suffix that's a prefix of another Term).
</dd>

<dt><a href="#Identification">Identification</a></dt>
<dd>
Every instance of an object type is <strong>distinguishable</strong> (intrinsically identifiable),
such that any copy always refers to the same instance. There is no mechanism for
extrinsic identification as in many object-oriented languages.
This idea is critical to the application of formal logic - individual things must be identifiable
even when there are multiple references to them.
</dd>

<dt><a href="#ValueTypes">Value Types</a></dt>
<dd>A <strong>Value Type</strong> is an Object Type defined using the key phase <strong>is written as</strong>,
since value instances are distinguished by a written form.
</dd>

<dt><a href="#EntityTypes">Entity Types</a></dt>
<dd>An <strong>Entity Type</strong> is an Object Type of which each instance is distinguished by
roles in its <em>existential</em> facts. The ultimate identifier of an entity instance will be
a set of value instances that play these roles (but this may be indirect).
The key phase <strong>is identified by</strong> is the most common way to introduce an entity type.
</dd>

<dt><a href="#NamedObjectTypes">Named Object Types</a></dt>
<dd>A <strong>Named Object Type</strong> is an Entity Type which is the objectification of one Fact Type.
Each instance exists as one instance of a Fact of that Type. The key phrase is <strong>is where</strong>,
e.g. <em>Directorship <strong>is where</strong> some Person directs some Company</em>.
Each instance of the Object Type is identified by the unique roles in the fact,
but an alternate identifier may be preferred.
</dd>

<dt><a href="#SubType">Subtypes</a></dt>
<dd>A <strong>Subtype</strong> is an Entity Type which is a sub-type of some other Entity Type
(or perhaps even more than one) introduced by the key phrase <strong>is a kind of</strong>.
Every instance of a subtype is also an instance of its supertype, and so is identifiable
the same way, though a subtype may introduce a new preferred identification scheme as well.
</dd>

<dt><a href="#FactType">Fact Types</a></dt>
<dd>A <strong>Fact Type</strong> declares the possibility of a specific relationship between
instances of two or more object types, or a characteristic of an instance of a single object type.
The Fact Type does this by providing one or more <strong>readings</strong> which are phrases
that include linking words and the object type names. Linking words may occur at the start
or end of a reading, and it is common for a fact type to have multiple readings, usually with
the object types in a different order.
</dd>

<dt><a href="#FactInstances">Fact Instances</a></dt>
<dd>
A Fact instance must have exactly one object instance compatible with each such role of
its object types. The Fact cannot be asserted if it has any missing object instances;
nothing resembling an SQL NULL is possible.
</dd>

<dt><a href="#DerivedFactTypes">Derived Fact Types</a></dt>
<dd>A <strong>Derived Fact Type</strong> is a Fact Type whose member instances may be computed
from a logical expression over other facts (analogous to an SQL view). A Derived Fact Type may
be fully derived (all instances are derived) or semi-derived (some instances are derived,
others may be asserted). Entity subtyping may also be derived, in a similar fashion.
</dd>

<dt><a href="#Constraints">Constraints</a></dt>
<dd>A <strong>Constraint</strong> restricts the instances of objects and facts that are
possible (alethic) or permissable (deontic) in a valid <strong>Population</strong>.
Instances that break deontic constraints may be asserted, but are associated with some
enforcement action introduced by a parenthesised expression starting with the keyword <strong>otherwise</strong>.
There are many types of constraints, as you will see below.
</dd>

<dt><a href="#Instances">Instances</a></dt>
<dd>An <strong>Instance</strong> of an object type or fact type, including at least the
literal values to identify the instance. It is common for a single instance expression to
define multiple fact and object instances. Each instance belongs to one <strong>Population</strong>.
The default anonymous population is the <strong>seed</strong> data for the model, meaning
that these instances must be present in any operational system, often as reference data.
Other populations may define example data or specific test case scenarios.
</dd>

<dt><a href="#Units">Units</a></dt>
<dd>A <strong>Unit</strong> definition can provide automated conversion between numeric values,
including for ephemeral conversions like currency exchange rates, by reference to an external
source of the ephemera.
</dd>
</dl>

<a name="Schemas"></a>
<p>A CQL file must start with a schema definition:</p>

<dl>
<dt id='cql_file'>cql_file</dt>
<dd><script src="js/diagrams/cql_file.js"></a></script></dd>

<dt id='definition'>definition<a name='definition'></a></dt>
<dd><script src="js/diagrams/definition.js"></a></script></dd>

<dt id='schema_definition'>schema_definition<a name='schema_definition'></a></dt>
<dd><script src="js/diagrams/schema_definition.js"></a></script></dd>

<dt id='schema_name'>schema_name<a name='schema_name'></a></dt>
<dd><script src="js/diagrams/schema_name.js"></a></script></dd>

<dt id='version_number'>version_number<a name='version_number'></a></dt>
<dd><script src="js/diagrams/version_number.js"></a></script></dd>
</dl>

<p>An import definition imports object type names from another
schema, possibly using the <b>alias</b> syntax to rename some
terms. In addition, fact type readings from the imported vocabulary
may subsequently be included in new definitions which provide
translations specific to this vocabulary.</p>

<dl>
<dt id='import_definition'>import_definition<a name='import_definition'></a></dt>
<dd><script src="js/diagrams/import_definition.js"></a></script></dd>

<dt id='version_pattern'>version_pattern<a name='version_pattern'></a></dt>
<dd><script src="js/diagrams/version_pattern.js"></a></script></dd>

<dt id='alias_list'>alias_list<a name='alias_list'></a></dt>
<dd><script src="js/diagrams/alias_list.js"/></script></dd>
</dl>

<p>
Other definitions and informal descriptions may follow:
</p>
<dl>
<dt id='statement'>statement<a name='statement'></a></dt>
<dd><script src="js/diagrams/statement.js"/></script></dd>
<dt id='informal_description'>informal_description<a name='informal_description'></a></dt>
<dd><script src="js/diagrams/informal_description.js"/></script></dd>
<dt id='informal_description_subject'>informal_description_subject<a name='informal_description_subject'></a></dt>
<dd><script src="js/diagrams/informal_description_subject.js"/></script></dd>
<dt id='informal_description_body'>informal_description_body<a name='informal_description_body'></a></dt>
<dd><script src="js/diagrams/informal_description_body.js"/></script></dd>
</dl>

<a name="ObjectTypes"></a>
<h3>Object Types</h3>

<dl>
<dt id='object_type'>object_type<a name='object_type'></a></dt>
<dd><script src="js/diagrams/object_type.js"/></script></dd>
</dl>

<a name="ValueTypes"></a>
<h3>Value Types</h3>

<p>A Value Type is a kind of thing which has a single value that may be
written down, that is, a lexical type, like a number, a name, a date, etc.
CQL literals may provide more than one way to write the same thing,
for example the integer 16 may be written as the hexadecimal 0x10, but
the uniqueness of these is determined by the underlying canonical value.
</p>

<p>
A value type is usually derived from another value type, whether or not that value type
has been defined in an imported vocabulary. A top-level value type is merely one whose
existence is presumed, or is written as itself in a circular fashion.
Many top-level names are detected and handled by code generators that receive CQL,
but CQL itself does not do this.
</p>

<p>
A value type may define named parameters, and may assign or restrict parameter values.
For legacy reasons, there are two positional parameters called <b>length</b> and <b>scale</b>.
</p>

<p>
A numeric literal or a Value Type may be assigned a specific unit of measure
</p>

<p>
A value type value constraint can restrict the allowable values from those
allowed by the supertype.
</p>

<dl>
<dt id='value_type'>value_type<a name='value_type'></a></dt>
<dd><script src="js/diagrams/value_type.js"/></script></dd>
<dt id='value_type_parameters'>value_type_parameters<a name='value_type_parameters'></a></dt>
<dd><script src="js/diagrams/value_type_parameters.js"/></script></dd>
<dt id='auto_assignment'>auto_assignment<a name='auto_assignment'></a></dt>
<dd><script src="js/diagrams/auto_assignment.js"/></script></dd>
<dt id='parameter'>parameter<a name='parameter'></a></dt>
<dd><script src="js/diagrams/parameter.js"/></script></dd>
<dt id='named_parameter'>named_parameter<a name='named_parameter'></a></dt>
<dd><script src="js/diagrams/named_parameter.js"/></script></dd>
<dt id='parameter_restriction'>parameter_restriction<a name='parameter_restriction'></a></dt>
<dd><script src="js/diagrams/parameter_restriction.js"/></script></dd>
<dt id='parameter_literal'>parameter_literal<a name='parameter_literal'></a></dt>
<dd><script src="js/diagrams/parameter_literal.js"/></script></dd>
</dl>

<h5> Examples </h5>
<pre>
each Month Nr is written as an Integer restricted to {1..12};
each Currency Amount is written as a Decimal(Precision: 14, Scale: 2);
each Name is written as a String(64, accepts Encoding as String restricted to {'ASCII', 'UTF-8'});
each Claim Sequence Nr is written as an Integer restricted to {1..999};
each Contact Method is written as a Char(1) restricted to {'B', 'H', 'M'};
each Glass Area is written as an Integer in mm^2;
each Acceleration is written as a Real in m/s^2;
</pre>

<a name="Units"></a>
<h3>Unit Definitions</h3>
<p>
A unit definition defines a new unit identifier in terms of an
a conversion to and from other more fundamental units. It allows an
optional coefficient (real number or integer fraction) multiplied by one
or more base units, each raised to an integer power. It's common to
define the singular form of a unit, then also define the plural as
equivalent.
</p>

<dl>
<dt id='unit_definition'>unit_definition<a name='unit_definition'></a></dt>
<dd><script src="js/diagrams/unit_definition.js"/></script></dd>
<dt id='unit_coefficient'>unit_coefficient<a name='unit_coefficient'></a></dt>
<dd><script src="js/diagrams/unit_coefficient.js"/></script></dd>
<dt id='unit_offset'>unit_offset<a name='unit_offset'></a></dt>
<dd><script src="js/diagrams/unit_offset.js"/></script></dd>
<dt id='units'>units<a name='units'></a></dt>
<dd><script src="js/diagrams/units.js"/></script></dd>
</dl>

<h5> Examples </h5>
<pre>
0.01 m^3 converts to cc;
1000.0 cc converts to liter;
299792458.0 m sec^-1 converts to lightspeed approximately;
0.00000000011125945705385 C^2 N^-1 e^-2 electronmass^-1 hbar^2 m^-2 converts to bohrradius;
</pre>

Units are defined by declaring conversion formulae involving base units. Both
singular and plural names may be given. If a base unit is not otherwise defined,
it is assumed to be fundamental. Formulae are limited to a coeficient and an
offset (<it>ax</it> + <it>c</it>), where <it>x</it> may be any number of existing units each raised to
any integer power. Conversion coeficients have a real numerator and an integral
denominator which defaults to 1. The formula may be written in either direction,
but the constants must be on the side of the base units. An extensive library
of standard unit conversions is available. Ephemeral conversions can be defined;
the conversion factor at a particular time is assumed to be available from some
source. Approximate conversions can be annotated.

<pre>
25.4 millimeters converts to inch/inches;
kelvin + 273.15 converts to celsius;
9/5 celsius + 32 converts to fahrenheit;
acceleration converts to metres second^-2;
g converts to 9.8 acceleration approximately;
0.853 dollarUS converts to dollarAU ephemeral;
</pre>

The use of units in defining value types and in query literals allows dimensional
analysis and automatic conversions. This example shows a derived fact
type ("Pane has Area") and a query that uses units conversion to list large
panes of glass. Notice that the literal in last line has an associated unit (this line
also has a contracted join, see below).

<pre>
Dimension is written as Real in millimeters;
Width is written as Dimension; Height is written as Dimension;
Pane has one Width; Pane has one Height;
Pane has Area where
Pane has Width, Pane has Height,
Area = Width * Height;
Pane has Area > 5 foot^2?
</pre>

<a name="EntityTypes"></a>
<h3>Entity Types</h3>

<p>
Each Entity Type plays roles in at least one fact type, and is identified
by the combination of the counterparts of one or more such roles.
At least one identifying role must be mandatory.
<!--CQL uses the closed-world assumption for non-mandatory
identifying roles, which means that the same identifier (with the same
role missing) may not occur more than once in a population.
-->
</p>

<dl>
<dt id='entity_type'>entity_type<a name='entity_type'></a></dt>
<dd><script src="js/diagrams/entity_type.js"/></script></dd>

<dt id='identification'>identification<a name='identification'></a></dt>
<dd><script src="js/diagrams/identification.js"/></script></dd>

<dt id='supertype_list'>supertype_list<a name='supertype_list'></a></dt>
<dd><script src="js/diagrams/supertype_list.js"/></script></dd>

<dt id='role_list'>role_list<a name='role_list'></a></dt>
<dd><script src="js/diagrams/role_list.js"/></script></dd>

<dt id='term_or_unary'>term_or_unary<a name='term_or_unary'></a></dt>
<dd><script src="js/diagrams/term_or_unary.js"/></script></dd>

<dt id='reading_clauses'>reading_clauses<a name='reading_clauses'></a></dt>
<dd><script src="js/diagrams/reading_clauses.js"/></script></dd>
</dl>

<a name="Identification"></a>
<p>The simplest form of entity identification scheme is by a single value,
similar to the General reference mode in ORM:
<pre>
    each Concept is identified by GUID;
</pre>

Here, GUID is an existing object type, or will be asserted as a value type,
and CQL will create the existential fact type "Concept has one GUID" with
the alternate reading "GUID is of at most one Concept". If you don't want
to use <em>has/is of</em>, you can provide your own reading, and still get the other.
</p>

<p>
Popular reference modes from ORM derive a new value type that is a subtype
of the specified type, and whose name includes the name of the new entity type.
A value type restriction may also be appended:
<pre>
    each Item is identified by its Number(Digits: 14);
    each Year is identified by its Number restricted to {1900..};
</pre>

Here, each Item has one Item Number. If Item Number has not already been declared,
it will be defined as a subtype of Number, which will in turn be defined as
a new value type if necessary. Again, you can use the default <em>has/is of</em>
or can provide your own readings. Note the open-ended range in the definition of
Year Number.
</p>

<p>
You can define identification patterns long-hand, and this is the only
way to define multi-part identifiers. Here's the equivalent to the above,
and a multi-part definition:
<pre>
    each GUID is written as a GUID;
    each Concept is identified by a GUID where
	that Concept has one GUID,
	that GUID is of at most one Concept;

    each Number is written as a Number;
    each Item Number is written as a Number(Digits: 14);
    each Item is identified by an Item Number where
	that Item has one Item Number,
	that Item Number is of at most one Item;

    each Policy is identified by a Year and a sequence- Number where
	that Policy was issued in one Year,
	that Policy is assigned one sequence- Number;
</pre>
Note that <em>that</em> is optional, as are the (equivalent) indefinite articles
<em>a/an</em> and even the initial <em>each</em>. We think it's nicer to use
the longer form however.
</p>

<p>
Note that in defining single-role identification, both roles must be unique (a 1-to-1 relationship),
and the new entity type's role must be mandatory. To use the inline definition of mandatory and
uniqueness (<em>one</em> in the above), there must be two readings (one in each direction)
because inline quantifiers like this may only be placed on the last role in a fact type reading.
</p>

<p>
In defining a multi-part identifier, the entity type's counterparts must be unique
(but not vice versa; we can issue more than one Policy in a Year!),
and at least one must be mandatory. Note the hyphenation used with the word <em>sequence</em>.
This binds the adjective sequence to Number, which verbalises properly and flows to column names.
Adjectives may also be bound following the Term, for use e.g. in French.
</p>

<p>
In all cases, any identifying role may be played by either a Value Type or an Entity Type.
</p>

<p>
If the default fact type readings (<em>has/is of</em>) aren't appropriate,
you can provide your preferred readings. The required uniqueness and
mandatory constraints are still added where needed.
<pre>
Item is identified by its Number where
    Item is called Item Number;
</pre>
</p>

<p>
Some code generators make use of pragmas to control their behaviour:
<dl>
<dt id='mapping_pragmas'>mapping_pragmas<a name='mapping_pragmas'></a></dt>
<dd><script src="js/diagrams/mapping_pragmas.js"/></script></dd>

<dt id='mapping_pragma'>mapping_pragma<a name='mapping_pragma'></a></dt>
<dd><script src="js/diagrams/mapping_pragma.js"/></script></dd>
</dl>
</p>

<a name="SubType"></a>
<h3>Subtypes</h3>

<p>An entity type may be declared to be a subtype of one or more other entity types, the supertypes.
A subtype instance is also an instance of each supertype, so it must play all their mandatory roles
(it may play any others) and thus shares their identifiers. It may also have its own identification
scheme (though this is not common; it will be identified by its relationship with its first supertype).
</p>

<pre>
each Asset is identified by Asset ID;
each Vehicle is a kind of Asset identified by VIN;

each Employee is a kind of Person identified by its Number;
</pre>

<pre>
each Apple is a kind of Fruit;
each Shelf Life is written as Time in days;
Fruit has at most one Shelf Life;
Fruit has one Price per kg;
Apple Type is a kind of Fruit;
Apple Type 'Jonathon' has Shelf Life 31 and has Price 3.20 per kg;
</pre>

<p>In these fact types, each fruit (and so each apple type) must have a price and maybe a shelf life.</p>

<p>Declaring a subtype creates subtyping fact types, which is useful
when subtyping relationships must be explicitly queried.</p>

<p>
An object type that can have instances which play no roles (other than
its identifying roles) should be declared <em>independent</em>:
<pre>
State is independent identified by its Code;
</pre>
</p>

<!--
<h3>Extended Role Names</h3>

<p>
The hyphens are used here to indicate the use of adjectives, which
can be either leading or trailing as required by the language. The hyphen
is only required once within a declaration, and this associates the
adjective with that role player throughout this declaration.
</p>

<pre>
Person is identified by given-Name and family-Name where
    Person is called one given Name, given Name is of Person,
    Person has one family Name, family Name is of Person;
</pre>

<p>
Hyphens may be used to designate multiple adjectives, but must
have a space beside the hyphen, on the side of the existing object
type name. Otherwise the pair of (previously unseen) words is treated
as a simple hyphenated term:
</p>

<pre>
    suitably- trained Person is allowed to drive semi-trailer;
</pre>

<p>
Finally, when the full form of identification is used, but there are fact type
readings all referring to the same roles <em>none of which is the defined entity
type</em>, these are the readings of a new fact type, which is objectified (named)
as the new entity type. This is discussed below, but in this case, the entity type
has an identification scheme which is not drawn from the fact type roles.
</p>
-->

<a name="FactType"></a>
<h3>Fact Types</h3>

<p>
A Fact Type is an <em>expression of possibility</em>
consisting of an optional naming expression,
one or more fact type readings,
optionally followed by a query (for a derived fact type).
A Fact Type expresses a possible relationship between two or more objects
or a characteristic of a single object.
The objects are said to <em>play a role</em> in the instances of this fact type.
The same object or (two objects of the same type) may play more than one role in the same fact.
</p>

<p>
Each reading provides a different verbal expression for the same meaning,
so must have the same set of <em>role players</em>, often in a different order.
When a named fact type is defined, each role player also has a <b>link fact</b> with
the objectifying entity, so readings for these fact types may also be included.
The first reading for a new fact type is preferred, and sets a default priority
order when sorting fact instances.
</p>

<dl>
<dt id='fact_type'>fact_type<a name='fact_type'></a></dt>
<dd><script src="js/diagrams/fact_type.js"/></script></dd>

<dt id='anonymous_fact_type'>anonymous_fact_type<a name='anonymous_fact_type'></a></dt>
<dd><script src="js/diagrams/anonymous_fact_type.js"/></script></dd>

<dt id='reading_clauses'>reading_clauses<a name='reading_clauses'></a></dt>
<dd><script src="js/diagrams/reading_clauses.js"/></script></dd>

<dt id='reading_clause'>reading_clause<a name='reading_clause'></a></dt>
<dd><script src="js/diagrams/reading_clause.js"/></script></dd>
</dl>

<a name="NamedObjectTypes"></a>
<p>
If a fact type is named, its instances can play a role in other facts.
In some cases, a code generator will require that a fact type is named, especially
if it has two roles with no uniqueness constraint, or has more than two roles.
This example shows an un-named and a named (objectified)
fact type:
</p>

<pre>
Person smokes;			  /* Unary fact type (characteristic) */
Person was born at one birth-Place;
Directorship is where
   Person directs Company, Company is run by Person,  /* Two readings */
   Person holds Directorship;     /* Link fact reading */
</pre>

<p>
If an object type plays more than one role in the same fact type, the
separate roles must be distinguished by either adjectives, subscripts,
or a defined role name. See the resolution rules under Resolving roles for
more details.
</p>

<p>
A derived fact type also has a query. This query must contain at least one
occurrence of the roles of the new fact type, but may link them together
in a logical expression that allows computation of the population of the
derived fact type. See the discussion of queries below.
</p>

<h4>Construction of Readings</h4>

<p>
A Reading is made up of noun phrases (involving an object type)
and linking words (which can be any non-special text).
Some of the optional elements in the discussion below are only usable in queries
or in other special contexts, but we need to introduce them here.
A Fact literal will for example include one <em>literal</em>
for every value role.
Queries may include <em>aggregate</em> or <em>objectification_step</em>
elements, which will be explained later.
</p>

<dl>
<dt id='linking_word'>linking_word<a name='linking_word'></a></dt>
<dd><script src="js/diagrams/linking_word.js"/></script></dd>
<dt id='noun_phrase'>noun_phrase<a name='noun_phrase'></a></dt>
<dd><script src="js/diagrams/noun_phrase.js"/></script></dd>
<dt id='simple_noun_phrase'>simple_noun_phrase<a name='simple_noun_phrase'></a></dt>
<dd><script src="js/diagrams/simple_noun_phrase.js"/></script></dd>
<dt id='variable'>variable<a name='variable'></a></dt>
<dd><script src="js/diagrams/variable.js"/></script></dd>
<dt id='role_name'>role_name<a name='role_name'></a></dt>
<dd><script src="js/diagrams/role_name.js"/></script></dd>
<dt id='subscript'>subscript<a name='subscript'></a></dt>
<dd><script src="js/diagrams/subscript.js"/></script></dd>
</dl>

<p>
Every role in a fact type must have a unique full name.
Where the same object type plays two roles, this can be achieved by adding
a numeric subscript to each, adding an explicit role name, or using
distinctive leading or trailing adjectives (as in given-Name, family-Name).
The adjectives are introduced by proper placement of a hyphen and perhaps white-space,
and are detected by scanning the whole definition before attempting to parse it.
See the discussion of Terms for more information.
</p>

<h4>Embedded constraints</h4>

<p>
Various constraints may be included in a noun phrase of a fact type definition.
The simplest are <em>quantifiers</em>, which require that an instance of the object type
may play this role at most once, exactly once, or at least once. Only the last
role in any reading may have an embedded quantifier. Thus to define a one-to-one
fact type using embedded constraints, it is essential to have two readings.
The alternative is to verbalise a separate constraint elsewhere, which is much
less concise.
</p>

<dl>
<dt id='role_quantifier'>role_quantifier<a name='role_quantifier'></a></dt>
<dd><script src="js/diagrams/role_quantifier.js"/></script></dd>
<dt id='quantifier'>quantifier<a name='quantifier'></a></dt>
<dd><script src="js/diagrams/quantifier.js"/></script></dd>
<dt id='quantity'>quantity<a name='quantity'></a></dt>
<dd><script src="js/diagrams/quantity.js"/></script></dd>
</dl>

<p>
In some contexts, there is no need for a quantifier, but another article may be needed
in the same place. The keywords <em>some</em> and <em>that</em> may be used to resolve
ambiguous references to the same object type, or to make it clear where a name refers
to the same instance previously mentioned in the same definition. In a query, the
keyword <em>which</em> indicates that the population of this role should be included
in the query result.
</p>

<p>
The keyword <em>no</em> (as a quantifier) or <em>not</em> (as any linking word)
indicates that there must be no matching instance of the corresponding fact.
</p>

<h4>Contracted Readings</h4>

<p>
In the definition of some entity types, and in many queries, a fact reading may
start or end with an term that starts the next reading or comparison expression.
This allows the use of more concise verbal forms called contractions.
The three cases are:
</p>
<ul>
<li> Left contraction: the repeated term is at the start, as in "Person drives car and smokes".
This has the same meaning as "Person drives car and that Person smokes".
<li> Right contraction: the repeated term is at the end, as in "Person saw Doctor who is experienced".
This has the same meaning as "Person saw Doctor and that Doctor is experienced".
Note that either the keywords <em>who</em> or <em>that</em> may be used.
<li> Comparison contraction: Right contraction of a comparison operation, e.g. "Person is of Age >= 21",
which means the same as "Person is of Age and that Age >= 21".
</ul>

<dl>
<dt id='contracted_clauses'>contracted_clauses<a name='contracted_clauses'></a></dt>
<dd><script src="js/diagrams/contracted_clauses.js"/></script></dd>
<dt id='contraction'>contraction<a name='contraction'></a></dt>
<dd><script src="js/diagrams/contraction.js"/></script></dd>
<dt id='reading_contraction'>reading_contraction<a name='reading_contraction'></a></dt>
<dd><script src="js/diagrams/reading_contraction.js"/></script></dd>
<dt id='comparison_contraction'>comparison_contraction<a name='comparison_contraction'></a></dt>
<dd><script src="js/diagrams/comparison_contraction.js"/></script></dd>
<dt id='comparator'>comparator<a name='comparator'></a></dt>
<dd><script src="js/diagrams/comparator.js"/></script></dd>
<dt id='comparison'>comparison<a name='comparison'></a></dt>
<dd><script src="js/diagrams/comparison.js"/></script></dd>
<dt id='post_qualifiers'>post_qualifiers<a name='post_qualifiers'></a></dt>
<dd><script src="js/diagrams/post_qualifiers.js"/></script></dd>
<dt id='post_qualifier'>post_qualifier<a name='post_qualifier'></a></dt>
<dd><script src="js/diagrams/post_qualifier.js"/></script></dd>
</dl>

<p><b>Qualifiers</b> are keywords enclosed in square brackets after a clause,
which apply some condition to that clause. The most common case is to define
a Ring Constraint - see the section on that</p>

<a name="DerivedFactTypes"></a>
<h3>Queries</h3>

<p>
Many queries look like a statement of fact, but end with a question mark.
Each term in the query corresponds to a variable.
Except for the question mark, the body of a query may also occur in a derived fact type.
Some of the variables may be bound to a specific value, while others may be free.
Free variables may be preceded by the keyword "which" (indicating the value is sought)
or "some" indicating that some value must exist, but we don't care to see it.
The response to the query includes all sets of identifying values for the free variables
which satisfy the conditions of the query. If a query has no free variables,
the response is either "yes" or "no", indicating whether the conditions are met.
Except for the question mark, the body of a query may also occur in a derived fact type.
<p>

<dl>
<dt id='query'>query<a name='query'></a></dt>
<dd><script src="js/diagrams/query.js"/></script></dd>

<dt id='query_clauses'>query_clauses<a name='query_clauses'></a></dt>
<dd><script src="js/diagrams/query_clauses.js"/></script></dd>

<dt id='objectification_step'>objectification_step<a name='objectification_step'></a></dt>
<dd><script src="js/diagrams/objectification_step.js"/></script></dd>

<dt id='returning_clause'>returning_clause<a name='returning_clause'></a></dt>
<dd><script src="js/diagrams/returning_clause.js"/></script></dd>

<dt id='ordering_prefix'>ordering_prefix<a name='ordering_prefix'></a></dt>
<dd><script src="js/diagrams/ordering_prefix.js"/></script></dd>

<dt id='qualified_clauses'>qualified_clauses<a name='qualified_clauses'></a></dt>
<dd><script src="js/diagrams/qualified_clauses.js"/></script></dd>

<dt id='certainty'>certainty<a name='certainty'></a></dt>
<dd><script src="js/diagrams/certainty.js"/></script></dd>
</dl>

<pre>
Country Code 'CH'?  /* Does 'CH' exist as a Country Code? */
Person 'Daniel' drives some Car?  /* Does Daniel drive any Car? */
Person 'Daniel' drives which Car? /* What Car does Daniel drive? */
Person 'Daniel' drives some Car and speeds?  /* Does Daniel drive any Car and does he speed? */
sum of Fine in (Person 'Daniel' received Fine for Driving Offence); /* total fines incurred */
</pre>

<p>When a query involves a named fact type that has no suitable link fact readings,
it may necessary to use a special expression (an <b>objectification_step</b>) to
join the contents of the fact.
In this expression, a parenthesised sub-expression follows the term, starting with
the text <b>(in which</b> and ending with a closing parenthesis. So if we have
a named fact type Booking as the objectification of "Person booked Table", we
might say <em>Booking (in which some Person booked some Table)...</em>.

<pre>
// Ask which Waiters received which tip Amounts
Service (in which which Waiter served some Meal) earned a tip of which Amount?
</pre>

<p>
<b>Certainty</b> keywords may be used to indicate whether a given fact <em>must</em>
be matched (the default), <em>may</em> be matched (outer join semantics) or
<em>must not</em> be matched (anti-join). Note that inserting the quantifier
<em>no</em> anywhere into a clause also means that fact must not be matched.
</p>

<h3>Result Constellations</h4>

<p>
The <b>returning clause</b> indicates which <em>other</em> roles in the query
expression should be made available to a program that requests a derived fact.
The behaviour is transitive; if the query uses other derived fact types with
a returning clause, those roles also should be returned. These extra roles
do not affect the population or behaviour of the derived fact type, but can
be useful in justifying an individual instance.
</p>

<p>
Normally, when processing a query, only the object instances that
play the roles of the derived fact type (and satisfy the query)
will be available in the results, and there is no defined ordering
in the values. When the returning clause is used, additional
object and fact instances may be accessible from the result,
which may also be sorted. This extension of the result set is
transitive, so that if a derived fact type invokes another derived
fact type, the returned instances from the invoked fact
type&rsquo;s returning clause will also be available.</p>

<p>The results now include more than just a simple table of the
instances that play the roles of the derived fact type. Instead,
each object instance may be associated with additional facts for
other roles it plays, and the roles of those facts will be
populated by further object instances, and so on. This data
structure is hereby defined as a <b>constellation</b>, which is
where CQL gets its name. The query has selected certain instances
from the entire fact population, much as an astronomer might select
stars from the night sky.</p>

<p>The use of <b>returning</b> doesn&rsquo;t change the contents of
the defined fact type, it&rsquo;s merely a pragmatic instruction to
the query engine about which additional instances will be useful to
the calling program, and in what order.<br clear="all" />
</p>

<h3>Expressions</h3>

<p>
Algebraic and aggregate expressions follow simple patterns:
</p>

<dl>
<dt id='expression'>expression<a name='expression'></a></dt>
<dd><script src="js/diagrams/expression.js"/></script></dd>
<dt id='sum'>sum<a name='sum'></a></dt>
<dd><script src="js/diagrams/sum.js"/></script></dd>
<dt id='product'>product<a name='product'></a></dt>
<dd><script src="js/diagrams/product.js"/></script></dd>
<dt id='factor'>factor<a name='factor'></a></dt>
<dd><script src="js/diagrams/factor.js"/></script></dd>
<dt id='aggregate'>aggregate<a name='aggregate'></a></dt>
<dd><script src="js/diagrams/aggregate.js"/></script></dd>
<dt id='aggregate_operation'>aggregate_operation<a name='aggregate_operation'></a></dt>
<dd><script src="js/diagrams/aggregate_operation.js"/></script></dd>
</dl>

<pre>
Product may be substituted by alternate-Product in Season [acyclic, intransitive]
Topic belongs to at most one parent-Topic [acyclic];
Girl (as Girlfriend) is going out with at most one Boy (as Boyfriend) [symmetric]
</pre>

<a name="Constraints"></a>
<h3>Constraints</h3>

<h4>Value Constraints</h4>

<p>
A value constraint may follow apply to a value type, or to a role
played by a value type (or by an entity type ultimately identified
by a single value type), and this constrains the allowed values of
that value. In addition to fact type definitions, a value constraint
may be applied in derivations and to fact instances (one value only!),
where it has the obvious effect.
</p>

<dl>
<dt id='value_constraint'>value_constraint<a name='value_constraint'></a></dt>
<dd><script src="js/diagrams/value_constraint.js"/></script></dd>

<dt id='range_list'>range_list<a name='range_list'></a></dt>
<dd><script src="js/diagrams/range_list.js"/></script></dd>
</dl>

<h4>Presence Constraints</h4>

<p>Embedded quantifiers allow the definition of the most common kinds of
constraints, the internal mandatory, uniqueness and frequency constraints
(collectively, CQL calls these <b>presence constraints</b>). Often
there are constraints that cannot be expressed in this form, such as
when an object type must play one or at most one of many unrelated roles
(an external mandatory constraint, possibly disjunctive).
</p>

<dl>
<dt id='presence_constraint'>presence_constraint<a name='presence_constraint'></a></dt>
<dd><script src="js/diagrams/presence_constraint.js"/></script></dd>

<dt id='each_occurs_in_clauses'>each_occurs_in_clauses<a name='each_occurs_in_clauses'></a></dt>
<dd><script src="js/diagrams/each_occurs_in_clauses.js"/></script></dd>

<dt id='for_each_how_many'>for_each_how_many<a name='for_each_how_many'></a></dt>
<dd><script src="js/diagrams/for_each_how_many.js"/></script></dd>

<dt id='clauses_list'>clauses_list<a name='clauses_list'></a></dt>
<dd><script src="js/diagrams/clauses_list.js"/></script></dd>

<dt id='clauses'>clauses<a name='clauses'></a></dt>
<dd><script src="js/diagrams/clauses.js"/></script></dd>
</dl>

<p>When a single role player must play one and only one (or at
least one) of a set of roles, we can say:</p>

In this example, a Range must have either a minimum Bound or a maximum
Bound, or both:

<pre><b>each</b> Range <b>occurs</b> at least one <b>time in</b>
	Range has minimum-Bound,
	Range has maximum-Bound;
</pre>

<p>In another example, supposing that we were to identify Person instances
by given name and family name (not a good idea in a real system!)
we need to ensure that the <b>combination</b> given name, family
name is unique. We can say:</p>

<pre>
<b>each</b> family Name, given Name <b>occurs</b> at most one<b> time in</b>
	Person is known by given-Name,
	Person has family-Name;
</pre>

<p>
Note that with "each Person occurs at most one time", this syntax is an
Exclusion Constraint (disjunction), not a Presence Constraint.
With "exactly one" it is also Mandatory (exactly one).  In both cases,
a more succinct syntax may be available.
</p>

<p>
The only ORM characteristic that cannot be expressed this way is a non-mandatory
constraint having a minimum frequency above one; for example a constraint that
allows zero, or more than two, occurrences. For example, in a footy tipping
competition, it might be the case that if a participant submits no tips this week,
they get the tips published by a known tipster, but if they do submit tips,
they must submit at least eight. This kind of non-mandatory frequency constraint
may be expressed in CQL using the <b>maybe</b> qualifier, which is also used in
outer join derivations.</p>

<pre>
    maybe Participant entered at least 8 Tips
</pre>

<h4>External Mandatory Constraints</h4>

<dl>
<dt id='either_or'>either_or<a name='either_or'></a></dt>
<dd><script src="js/diagrams/either_or.js"/></script></dd>

<pre>
either Person abstains from smoking or Person is at risk of cancer;
</pre>

<h3>Set Constraints</h3>
<p>
Set constraints compare two or more sets of one or more roles each.
</p>

<dt id='set_constraint'>set_constraint<a name='set_constraint'></a></dt>
<dd><script src="js/diagrams/set_constraint.js"/></script></dd>

<h4>Exclusion Constraints</h4>

<dt id='either_or_not_both'>either_or_not_both<a name='either_or_not_both'></a></dt>
<dd><script src="js/diagrams/either_or_not_both.js"/></script></dd>

<pre>
<b>for each</b> ReceivedItem exactly one<b> of these holds:</b>
	ReceivedItem is for PurchaseOrderItem,
	ReceivedItem is for TransferRequest;
</pre>

<pre>
<b>for each</b> Unit exactly one <b>of these holds</b>:
	that Unit is fundamental,
	that Unit is derived from some base-Unit;
</pre>

In the case where exactly one of two fact types applies, you can use the more
natural form:

<pre>
<b>either</b> Unit is fundamental
<b>or</b> that Unit is derived from some base-Unit
<b>but not both</b>;
</pre>

<h4>Subset Constraints</h4>
<p>
A subset constraint says that one thing is the case only if some other thing is.
</p>

<dt id='subset_constraint'>subset_constraint<a name='subset_constraint'></a></dt>
<dd><script src="js/diagrams/subset_constraint.js"/></script></dd>

<dt id='a_only_if_b'>a_only_if_b<a name='a_only_if_b'></a></dt>
<dd><script src="js/diagrams/a_only_if_b.js"/></script></dd>

<dt id='if_b_then_a'>if_b_then_a<a name='if_b_then_a'></a></dt>
<dd><script src="js/diagrams/if_b_then_a.js"/></script></dd>

<pre>
Address has third-StreetLine
    <b>only if</b>
    that Address has some second-StreetLine;
</pre>

<p>Note that this example didn't use the first and second StreetLine,
as we assume that the first StreetLine is a mandatory
part of the address, so the subset constraint would be
redundant.</p>

<h4>Equality Constraints</h4>
<p>Equality constraints declare that the populations of two or more
roles (or sequences of roles) are the same. They are expressed using
&lsquo;if and only if&rsquo;:</p>

<dt id='equality_constraint'>equality_constraint<a name='equality_constraint'></a></dt>
<dd><script src="js/diagrams/equality_constraint.js"/></script></dd>

<dt id='if_and_only_if'>if_and_only_if<a name='if_and_only_if'></a></dt>
<dd><script src="js/diagrams/if_and_only_if.js"/></script></dd>

For example:

<pre>
Competition is in Series
	<b>if and only if</b>
	Competition has series-Number;
</pre>

<h3>Ring Constraints</h3>

<p>When a fact type includes the same object type more than once, or
includes a supertype and its subtype, there&rsquo;s the possibility
of the same instance playing both roles. This is often not desired,
but further it introduces a whole class of further situations which
can be restricted using ring constraints. The CQL keywords used in
fact clause qualifiers for ring constraints are the following:</p>

<p><b>intransitive</b>,<b> transitive</b>,<b> acyclic</b> and <b>
symmetric</b>. Intransitive means that just because &ldquo;A
relates to B&rdquo;, and &ldquo;B relates to C&rdquo;, that
doesn&rsquo;t mean that&nbsp; &ldquo;A relates to C&rdquo;.
Transitive means the opposite. Acyclic means that no A may relate
to itself, or to any B that has that relation to A, and so on.
Symmetric means that if A relates to B, B also relates to A (so
there is only one fact instance possible between A and B).</p>

<p>This method for defining ring constraints is not fully general,
and a new syntax is required for covering complex cases</p>

<h4>Deontic Constraints</h4>
<p>
A <strong>Constraint</strong> restricts the instances of objects and facts that are
possible (alethic) or permissable (deontic) in a valid <strong>Population</strong>.
Instances that break deontic constraints may be asserted, but are associated with some
enforcement action introduced by a parenthesised expression starting with the keyword <strong>otherwise</strong>.
</p>
<dt id='enforcement'>enforcement<a name='enforcement'></a></dt>
<dd><script src="js/diagrams/enforcement.js"/></script></dd>
</dl>

<h4>Join constraints</h4>

<p>Most of the above constraint types may use joins (or more complex derivations),
where more than one fact type is joined together with the <b>and</b> keyword.
In general, any expression in a constraint may be an arbitrary derivation,
and the constraint compares the population of specific roles that are projected
from the derivations. Effectively the constraint applies over one or more derived
fact types, but those fact types do not need to be given readings.
Here is a small example of a subset constraint using derivations:</p>

<pre>
Diplomat speaks Language;
Country uses Language, Language is spoken in Country;
Diplomat serves in Country;

Diplomat serves in Country
	<b>only if</b>
	Country uses Language <b>and</b> Diplomat speaks Language;
</pre>

<p>This constraint requires that in order to serve in a country, a
diplomat must speak at least one language used in that country.
The use of a contraction makes this more succinct (and dressed up
with some/that):
</p>

<pre>
some Diplomat serves in some Country
	<b>only if</b>
	that Diplomat speaks some Language <b>that</b> is spoken in that Country;
</pre>

<a name="Instances"></a>
<h3>Instances</h3>

<p>A value instance is defined by stating the name of the value type followed by
the lexical representation of the value. An entity having a single identifying role
may be defined exactly the same way, which also defines the required identifying
instance (in the third example here, a value). Within a vocabulary, an instance
is asserted into the sample population, but in other contexts another population
may be the target (the metamodel supports arbitrary named populations).</p>

<pre>
    CompanyName 'Microsoft';
    Year 1999;
    Company 'Microsoft';      /* Entity identified by a single value */
</pre>

<a name="FactInstances"></a>
<h3>Fact Instances</h3>

<p>When a fact reading is invoked with values, a fact instance
is created. The simplest is where a declaration is just an object type
name followed by a value:</p>

<pre>
    Name &lsquo;Fred&rsquo;;
</pre>

<p>This form is allowed for any value type, or any entity type
that&rsquo;s identified by a single value type (or an entity
identified by a single entity identified by a single value type,
etc). In more complex cases, it might be necessary or convenient
to invoke more than one fact type to define the instance:</p>

<pre>
    Person is called given name &lsquo;Fred&rsquo;,
	Person has family Name &lsquo;Bloggs&rsquo;;
</pre>

<p>or</p>

<pre>
    given Name &lsquo;Fred&rsquo; is of Person <b>who</b> has family Name &lsquo;Bloggs&rsquo;;
</pre>

<p>The Person instance being defined is a reference to the same
instance in each fact type reading; there is an implicit join over
the two clauses.
</p>

<pre>
    Person has family Name,
	family Name = &lsquo;Bloggs&rsquo;,
	Person is <b>not</b> called given Name &lsquo;Fred&rsquo;,
	Person is a kind of Employee,
	Employee is managed by <b>no</b> Manager<b>;</b>
</pre>

<h3>Context Notes</h3>
<p>
Business context such as the reasons for certain modeling decisions may
need to be recorded. Although CQL is perhaps not the ideal way to do that,
it is supported to support model exchange.
</p>
<dl>
<dt id='context_note'>context_note<a name='context_note'></a></dt>
<dd><script src="js/diagrams/context_note.js"/></script></dd>
<dt id='agents'>agents<a name='agents'></a></dt>
<dd><script src="js/diagrams/agents.js"/></script></dd>
<dt id='description'>description<a name='description'></a></dt>
<dd><script src="js/diagrams/description.js"/></script></dd>
<dt id='as_agreed_by'>as_agreed_by<a name='as_agreed_by'></a></dt>
<dd><script src="js/diagrams/as_agreed_by.js"/></script></dd>
</dl>

<h3>Terms</h3>
<p>
A term also allows zero or more leading adjectives and/or trailing adjectives.
Leading adjectives are indicated by a hyphen after the first adjective,
and trailing adjectives are indicated by a hyphen before the last adjective.
This makes it complicated because (like a linking word) an adjective may be hyphenated.
If adjectives are introduced by a hyphenated word, the hyphen is doubled instead of being adjacent.
Accordingly, there are very precise rules about where spaces and hyphens are allowed inside terms.
</p>

<dl>
<dt id='term'>term<a name='term'></a></dt>
<dd><script src="js/diagrams/term.js"/></script></dd>
</dl>

<h3>Lexical Rules</h3>
<p>
Lexical rules mostly follow standard C, UNIX and HTTP conventions.
</p>

<dl>
<dt id='range'>range<a name='range'></a></dt>
<dd><script src="js/diagrams/range.js"/></script></dd>
<dt id='numeric_range'>numeric_range<a name='numeric_range'></a></dt>
<dd><script src="js/diagrams/numeric_range.js"/></script></dd>
<dt id='string_range'>string_range<a name='string_range'></a></dt>
<dd><script src="js/diagrams/string_range.js"/></script></dd>
<dt id='literal'>literal<a name='literal'></a></dt>
<dd><script src="js/diagrams/literal.js"/></script></dd>
<dt id='boolean_literal'>boolean_literal<a name='boolean_literal'></a></dt>
<dd><script src="js/diagrams/boolean_literal.js"/></script></dd>
<dt id='string'>string<a name='string'></a></dt>
<dd><script src="js/diagrams/string.js"/></script></dd>
<dt id='string_char'>string_char<a name='string_char'></a></dt>
<dd><script src="js/diagrams/string_char.js"/></script></dd>
<dt id='number'>number<a name='number'></a></dt>
<dd><script src="js/diagrams/number.js"/></script></dd>
<dt id='real'>real<a name='real'></a></dt>
<dd><script src="js/diagrams/real.js"/></script></dd>
<dt id='fractional_real'>fractional_real<a name='fractional_real'></a></dt>
<dd><script src="js/diagrams/fractional_real.js"/></script></dd>
<dt id='fraction'>fraction<a name='fraction'></a></dt>
<dd><script src="js/diagrams/fraction.js"/></script></dd>
<dt id='exponent'>exponent<a name='exponent'></a></dt>
<dd><script src="js/diagrams/exponent.js"/></script></dd>
<dt id='hexnumber'>hexnumber<a name='hexnumber'></a></dt>
<dd><script src="js/diagrams/hexnumber.js"/></script></dd>
<dt id='octalnumber'>octalnumber<a name='octalnumber'></a></dt>
<dd><script src="js/diagrams/octalnumber.js"/></script></dd>
<dt>regular_expression
<dd>UNIX-style regular expression
<dt>url
<dd>HTTP-style URL
</dl>

<h4>Footnotes</h4>
<ol>
  <li><a href="http://ormfoundation.org/" name="ftn1" title="">The ORM Foundation</a>
  </li>

  <li><a href="http://en.wikipedia.org/wiki/Semantics_of_Business_Vocabulary_and_Business_Rules" name="ftn2"
    title="Semantics of Business Vocabulary and Business Rules">Semantics
    of Business Vocabulary and Business Rules</a>
  </li>
</ol>
</div>
</div>
</div>
<div id="footer" class="noprint">
	<p>Copyright &copy; 2015 Infinuendo</p>
</div>
</body>
</html>


