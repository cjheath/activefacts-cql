<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>CQL Introduction</title>
<meta name="description" content="CQL Introduction" />
<meta name="keywords" content="fact based modeling, fact based modelling, data constellation, information management, semantic modelling,activefacts" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
<link rel="icon" href="/favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="css/style.css" media="screen" type="text/css" />
<link rel="stylesheet" href="css/screen.css" media="screen" type="text/css" />
<!--[if lte IE 6]>
  <link rel="stylesheet" href="css/screen.ie6.css" media="screen" type="text/css" />
<![endif]-->
<link rel="stylesheet" href="css/print.css" media="print" type="text/css" />
<link rel="stylesheet" href="css/railroad-diagrams.css">
<link rel="stylesheet" href="css/local.css" media="screen" type="text/css" />
<style>
body svg.railroad-diagram {
	background-color: hsl(30,20%, 95%);
}
h2 {
	font-family: sans-serif;
	font-size: 1em;
}
svg.railroad-diagram path,
svg.railroad-diagram rect
{
	stroke-width: 2px;
}
.railroad-diagram .terminal text {
	fill: #44F;
}
div svg.railroad-diagram {
	width: 80%;  /* Scale to the width of the parent */
	height: 100%;  /* Preserve the ratio. Could be related to https://bugs.webkit.org/show_bug.cgi?id=82489 */
}
</style>
</head>
<body>

<link rel="stylesheet" href="css/offline.css" media="screen" type="text/css" />

<style type="text/css" id="internalStyle">
dt {
	font-weight: bold;
	padding-bottom: 5px;
}
dd {
	padding-bottom: 10px;
}
</style>

<style>
div svg.railroad-diagram {
	width: 80%;  /* Scale to the width of the parent */
	height: 100%;  /* Preserve the ratio. Could be related to https://bugs.webkit.org/show_bug.cgi?id=82489 */
}
</style>
<script src='js/railroad-diagrams.js'></script>

<!--title>Introduction to the</title-->
<h1>
Introduction to the Constellation Query Language
</h1>
<p>The Constellation Query Language (<strong>CQL</strong>) is a language for constructing and querying
<strong>fact-based information models</strong>. It is a textual representation of the graphical
<a href="#ftn1" title="ORM Foundation"><strong>Object Role Modeling</strong></a> language, which
fully implements semantics isomorphic to Codd's Relational Calculus.
</p>

<h5>Open Vocabulary</h5>

<p>
CQL has an open vocabulary (almost any linking words or expressions may be used in defining fact types)
because it is designed to resemble natural language. Only certain key words and key phrases are restricted.
Some keywords are disallowed in any open text, because they always have their special meaning,
whereas others are only special in certain contexts.
In most cases the individual words of key phrases are not restricted; only the complete phrase is special.
CQL allows free use of whitespace and comments, even in the middle of key phrases.
</p>

<h5>Keywords and phrases</h5>

<p>
This introduction to CQL uses English language keywords and phrases,
though CQL also has variants in other natural languages.

Keywords that are special everywhere include the logical operators, such as
<tt>and</tt>, <tt>or</tt>, <tt>maybe</tt>, <tt>not</tt>, <tt>none</tt>, <tt>no</tt>, <tt>if</tt>,
and designators like
<tt>some</tt>, <tt>that</tt>, etc.

Other words of key phrases such as <tt>is</tt>, <tt>identified</tt>, <tt>kind</tt>, <tt>of</tt>,
<tt>as</tt>, <tt>at</tt>, etc, may be used anywhere open vocabulary is allowed.
Their special meaning applies only in the specific places they appear in the grammar.
</p>

<p>
CQL statement are parsed by first identifying key expressions and terms while skipping the linking text.
Next, each clause is matched to a fact type by using the linking text and the object types indicated,
and the whole expression is then analysed.
</p>

<h5>Case and Whitespace</h5>

<p>
CQL is <em>case sensitive</em>. <tt>Person</tt> is not the same thing as <tt>person</tt>.
It's convenient however to use a capital letter for the names of all object types (called <strong>terms</strong>,
because the specific sequence of words in an object type name will <em>always</em> designate that
object type, and sometimes the lower-cased version of a name will appear in linking text.
</p>

<p>
White space and comments as similar to C and C++:
<tt>/*&nbsp;comment<br>may&nbsp;span&nbsp;lines&nbsp;*/</tt> and
<tt>//&nbsp;introduces&nbsp;a&nbsp;comment&nbsp;to&nbsp;end&nbsp;of&nbsp;the&nbsp;current&nbsp;line.</tt>
</p>

<h5>Data types and values</h5>

<p>
CQL requires lexical support for only a rudimentary set of data types and literals;
boolean (true/false), numbers (integer, real, scientific), character strings, and
ranges of numbers and strings (ranges may be open at either end).
</p>

<p>
Data types can be refined through the use of parameters to match concrete types
available in typical target data environments and languages, and code generators
will assume reasonable defaults even without that.  You can also define entirely
new data types and their parameters, for use in specialised code generators or
where a target language has a data type that is not special in the code generators.
The syntax for value literals is near the end of this document.
</p>

<h5>CQL Schema</h5>

<p> Every CQL file must begin with a schema definition statement,
then may import (all or part of) other schemas, before starting
new definitions.
</p>

<h5>Kinds of CQL definition</h5>

<ul type="disc">
<li>
Every <strong>Object Type</strong> has a name (a <strong>Term</strong>) consisting of one or more words.
Each word starts with a letter and continues with any alphanumeric or underscore characters.
A Term may be a prefix of another Term, but may not overlap (end with a suffix that's a prefix of another Term).
</li>

<li>
Every instance of an object type is <strong>distinguishable</strong> (intrinsically identifiable),
such that any copy always refers to the same instance. There is no mechanism for
extrinsic identification as in many object-oriented languages.
This idea is critical to the application of formal logic - individual things must be identifiable
even when there are multiple references to them.
</li>

<li>A <strong>Value Type</strong> is an Object Type defined using the key phase <strong>is written as</strong>,
since value instances are distinguished by a written form.
</li>

<li>An <strong>Entity Type</strong> is an Object Type of which each instance is distinguished by
roles in its <em>existential</em> facts. The ultimate identifier of an entity instance will be
a set of value instances that play these roles (but this may be indirect).
The key phase <strong>is identified by</strong> is the most common way to introduce an entity type.
</li>

<li>A <strong>Named Object Type</strong> is an Entity Type which is the objectification of one Fact Type.
Each instance exists as one instance of a Fact of that Type. The key phrase is <strong>is where</strong>,
e.g. <em>Directorship <strong>is where</strong> some Person directs some Company</em>.
Each instance of the Object Type is identified by the unique roles in the fact,
but an alternate identifier may be preferred.
</li>

<li>A <strong>Subtype</strong> is an Entity Type which is a sub-type of some other Entity Type
(or perhaps even more than one) introduced by the key phrase <strong>is a kind of</strong>.
Every instance of a subtype is also an instance of its supertype, and so is identifiable
the same way, though a subtype may introduce a new preferred identification scheme as well.
</li>

<li>A <strong>Fact Type</strong> declares the possibility of a specific relationship between
instances of two or more object types, or a characteristic of an instance of a single object type.
The Fact Type does this by providing one or more <strong>readings</strong> which are phrases
that include linking words and the object type names. Linking words may occur at the start
or end of a reading, and it is common for a fact type to have multiple readings, usually with
the object types in a different order.
</li>

<li>
A Fact instance must have exactly one object instance compatible with each such role of
its object types. The Fact cannot be asserted if it has any missing object instances;
nothing resembling an SQL NULL is possible.
</li>

<li>A <strong>Derived Fact Type</strong> is a Fact Type whose member instances may be computed
from a logical expression over other facts (analogous to an SQL view). A Derived Fact Type may
be fully derived (all instances are derived) or semi-derived (some instances are derived,
others may be asserted). Entity subtyping may also be derived, in a similar fashion.
</li>

<li>A <strong>Constraint</strong> restricts the instances of objects and facts that are
possible (alethic) or permissable (deontic) in a valid <strong>Population</strong>.
Instances that break deontic constraints may be asserted, but are associated with some
enforcement action introduced by a parenthesised expression starting with the keyword <strong>otherwise</strong>.
There are many types of constraints, as you will see below.
</li>

<li>An <strong>Instance</strong> of an object type or fact type, including at least the
literal values to identify the instance. It is common for a single instance expression to
define multiple fact and object instances. Each instance belongs to one <strong>Population</strong>.
The default anonymous population is the <strong>seed</strong> data for the model, meaning
that these instances must be present in any operational system, often as reference data.
Other populations may define example data or specific test case scenarios.
</li>

<li>A <strong>Unit</strong> definition can provide automated conversion between numeric values,
including for ephemeral conversions like currency exchange rates, by reference to an external
source of the ephemera.
</li>
</ul>

<p>A CQL file must start with a schema definition:</p>

<dl>
<dt id='cql_file'>cql_file</dt>
<dd><script src="js/diagrams/cql_file.js"></a></script></dd>

<dt id='definition'>definition<a name='definition'></a></dt>
<dd><script src="js/diagrams/definition.js"></a></script></dd>

<dt id='schema_definition'>schema_definition<a name='schema_definition'></a></dt>
<dd><script src="js/diagrams/schema_definition.js"></a></script></dd>

<dt id='schema_name'>schema_name<a name='schema_name'></a></dt>
<dd><script src="js/diagrams/schema_name.js"></a></script></dd>

<dt id='version_number'>version_number<a name='version_number'></a></dt>
<dd><script src="js/diagrams/version_number.js"></a></script></dd>
</dl>

<p>An import definition imports object type names from another
schema, possibly using the <b>alias</b> syntax to rename some
terms. In addition, fact type readings from the imported vocabulary
may subsequently be included in new definitions which provide
translations specific to this vocabulary.</p>

<dl>
<dt id='import_definition'>import_definition<a name='import_definition'></a></dt>
<dd><script src="js/diagrams/import_definition.js"></a></script></dd>

<dt id='version_pattern'>version_pattern<a name='version_pattern'></a></dt>
<dd><script src="js/diagrams/version_pattern.js"></a></script></dd>

<dt id='alias_list'>alias_list<a name='alias_list'></a></dt>
<dd><script src="js/diagrams/alias_list.js"/></script></dd>
</dl>

<p>
Other definitions and informal descriptions may follow:
</p>
<dl>
<dt id='statement'>statement<a name='statement'></a></dt>
<dd><script src="js/diagrams/statement.js"/></script></dd>
<dt id='informal_description'>informal_description<a name='informal_description'></a></dt>
<dd><script src="js/diagrams/informal_description.js"/></script></dd>
<dt id='informal_description_subject'>informal_description_subject<a name='informal_description_subject'></a></dt>
<dd><script src="js/diagrams/informal_description_subject.js"/></script></dd>
<dt id='informal_description_body'>informal_description_body<a name='informal_description_body'></a></dt>
<dd><script src="js/diagrams/informal_description_body.js"/></script></dd>
</dl>

<h3>Object Types</h3>

<dl>
<dt id='object_type'>object_type<a name='object_type'></a></dt>
<dd><script src="js/diagrams/object_type.js"/></script></dd>
</dl>

<h3>Value Types</h3>

<p>A Value Type is a kind of thing which has a single value that may be
written down, that is, a lexical type, like a number, a name, a date, etc.
CQL literals may provide more than one way to write the same thing,
for example the integer 16 may be written as the hexadecimal 0x10, but
the uniqueness of these is determined by the underlying canonical value.
</p>

<p>
A value type is usually derived from another value type, whether or not that value type
has been defined in an imported vocabulary. A top-level value type is merely one whose
existence is presumed, or is written as itself in a circular fashion.
Many top-level names are detected and handled by code generators that receive CQL,
but CQL itself does not do this.
</p>

<p>
A value type may define named parameters, and may assign or restrict parameter values.
For legacy reasons, there are two positional parameters called <b>length</b> and <b>scale</b>.
</p>

<p>
A numeric literal or a Value Type may be assigned a specific unit of measure
</p>

<p>
A value type value constraint can restrict the allowable values from those
allowed by the supertype.
</p>

<dl>
<dt id='value_type'>value_type<a name='value_type'></a></dt>
<dd><script src="js/diagrams/value_type.js"/></script></dd>
<dt id='value_type_parameters'>value_type_parameters<a name='value_type_parameters'></a></dt>
<dd><script src="js/diagrams/value_type_parameters.js"/></script></dd>
<dt id='auto_assignment'>auto_assignment<a name='auto_assignment'></a></dt>
<dd><script src="js/diagrams/auto_assignment.js"/></script></dd>
<dt id='parameter'>parameter<a name='parameter'></a></dt>
<dd><script src="js/diagrams/parameter.js"/></script></dd>
<dt id='named_parameter'>named_parameter<a name='named_parameter'></a></dt>
<dd><script src="js/diagrams/named_parameter.js"/></script></dd>
<dt id='parameter_restriction'>parameter_restriction<a name='parameter_restriction'></a></dt>
<dd><script src="js/diagrams/parameter_restriction.js"/></script></dd>
<dt id='parameter_literal'>parameter_literal<a name='parameter_literal'></a></dt>
<dd><script src="js/diagrams/parameter_literal.js"/></script></dd>
</dl>

<h5> Examples </h5>
<pre>
each Month Nr is written as an Integer restricted to {1..12};
each Currency Amount is written as a Decimal(Precision: 14, Scale: 2);
each Name is written as a String(64, accepts Encoding as String restricted to {'ASCII', 'UTF-8'});
each Claim Sequence Nr is written as an Integer restricted to {1..999};
each Contact Method is written as a Char(1) restricted to {'B', 'H', 'M'};
each Glass Area is written as an Integer in mm^2;
each Acceleration is written as a Real in m/s^2;
</pre>

<h3>Units</h3>
<p>
A unit definition defines a conversion to and from other more fundamental units, such as metres or kilowatt-hours.
</p>

<dl>
<dt id='unit_definition'>unit_definition<a name='unit_definition'></a></dt>
<dd><script src="js/diagrams/unit_definition.js"/></script></dd>
<dt id='unit_coefficient'>unit_coefficient<a name='unit_coefficient'></a></dt>
<dd><script src="js/diagrams/unit_coefficient.js"/></script></dd>
<dt id='unit_offset'>unit_offset<a name='unit_offset'></a></dt>
<dd><script src="js/diagrams/unit_offset.js"/></script></dd>
<dt id='units'>units<a name='units'></a></dt>
<dd><script src="js/diagrams/units.js"/></script></dd>
</dl>

<h5> Examples </h5>
<pre>
0.01 m^3 converts to cc;
1000.0 cc converts to liter;
299792458.0 m sec^-1 converts to lightspeed approximately;
0.00000000011125945705385 C^2 N^-1 e^-2 electronmass^-1 hbar^2 m^-2 converts to bohrradius;
</pre>

<h3>Entity Types</h3>

<p>
Each Entity Type plays roles in at least one fact type, and is identified
by the combination of the counterparts of one or more such roles.
At least one identifying role must be mandatory.
<!--CQL uses the closed-world assumption for non-mandatory
identifying roles, which means that the same identifier (with the same
role missing) may not occur more than once in a population.
-->
</p>

<dl>
<dt id='entity_type'>entity_type<a name='entity_type'></a></dt>
<dd><script src="js/diagrams/entity_type.js"/></script></dd>

<dt id='identification'>identification<a name='identification'></a></dt>
<dd><script src="js/diagrams/identification.js"/></script></dd>

<dt id='supertype_list'>supertype_list<a name='supertype_list'></a></dt>
<dd><script src="js/diagrams/supertype_list.js"/></script></dd>

<dt id='role_list'>role_list<a name='role_list'></a></dt>
<dd><script src="js/diagrams/role_list.js"/></script></dd>

<dt id='term_or_unary'>term_or_unary<a name='term_or_unary'></a></dt>
<dd><script src="js/diagrams/term_or_unary.js"/></script></dd>
</dl>

<p>The simplest form of entity identification scheme is by a single value,
similar to the General reference mode in ORM:
<pre>
    each Concept is identified by GUID;
</pre>

Here, GUID is an existing object type, or will be asserted as a value type,
and CQL will create the existential fact type "Concept has one GUID" with
the alternate reading "GUID is of at most one Concept". If you don't want
to use <em>has/is of</em>, you can provide your own reading, and still get the other.
</p>

<p>
Popular reference modes from ORM derive a new value type that is a subtype
of the specified type, and whose name includes the name of the new entity type.
A value type restriction may also be appended:
<pre>
    each Item is identified by its Number(Digits: 14);
    each Year is identified by its Number restricted to {1900..};
</pre>

Here, each Item has one Item Number. If Item Number has not already been declared,
it will be defined as a subtype of Number, which will in turn be defined as
a new value type if necessary. Again, you can use the default <em>has/is of</em>
or can provide your own readings. Note the open-ended range in the definition of
Year Number.
</p>

<p>
You can define identification patterns long-hand, and this is the only
way to define multi-part identifiers. Here's the equivalent to the above,
and a multi-part definition:
<pre>
    each GUID is written as a GUID;
    each Concept is identified by a GUID where
	that Concept has one GUID,
	that GUID is of at most one Concept;

    each Number is written as a Number;
    each Item Number is written as a Number(Digits: 14);
    each Item is identified by an Item Number where
	that Item has one Item Number,
	that Item Number is of at most one Item;

    each Policy is identified by a Year and a sequence- Number where
	that Policy was issued in one Year,
	that Policy is assigned one sequence- Number;
</pre>
Note that <em>that</em> is optional, as are the (equivalent) indefinite articles
<em>a/an</em> and even the initial <em>each</em>. We think it's nicer to use
the longer form however.
</p>

<p>
Note that in defining single-role identification, both roles must be unique (a 1-to-1 relationship),
and the new entity type's role must be mandatory. To use the inline definition of mandatory and
uniqueness (<em>one</em> in the above), there must be two readings (one in each direction)
because inline quantifiers like this may only be placed on the last role in a fact type reading.
</p>

<p>
In defining a multi-part identifier, the entity type's counterparts must be unique
(but not vice versa; we can issue more than one Policy in a Year!),
and at least one must be mandatory. Note the hyphenation used with the word <em>sequence</em>.
This binds the adjective sequence to Number, which verbalises properly and flows to column names.
Adjectives may also be bound following the Term, for use e.g. in French.
</p>

<p>
In all cases, any identifying role may be played by either a Value Type or an Entity Type.
</p>

<p>
If the default fact type readings (<em>has/is of</em>) aren't appropriate,
you can provide your preferred readings. The required uniqueness and
mandatory constraints are still added where needed.
<pre>
Item is identified by its Number where
    Item is called Item Number;
</pre>
</p>

<p>
Some code generators make use of pragmas to control their behaviour:
<dl>
<dt id='mapping_pragmas'>mapping_pragmas<a name='mapping_pragmas'></a></dt>
<dd><script src="js/diagrams/mapping_pragmas.js"/></script></dd>

<dt id='mapping_pragma'>mapping_pragma<a name='mapping_pragma'></a></dt>
<dd><script src="js/diagrams/mapping_pragma.js"/></script></dd>
</dl>
</p>

<h3>Subtypes</h3>

<p>An entity type may be declared to be a subtype of one or more other entity types, the supertypes.
A subtype instance is also an instance of each supertype, so it must play all their mandatory roles
(it may play any others) and thus shares their identifiers. It may also have its own identification
scheme (though this is not common; it will be identified by its relationship with its first supertype).
</p>

<pre>
each Asset is identified by Asset ID;
each Vehicle is a kind of Asset identified by VIN;

each Employee is a kind of Person identified by its Number;
</pre>

<pre>
each Apple is a kind of Fruit;
each Shelf Life is written as Time in days;
Fruit has at most one Shelf Life;
Fruit has one Price per kg;
Apple Type is a kind of Fruit;
Apple Type 'Jonathon' has Shelf Life 31 and has Price 3.20 per kg;
</pre>

<p>In these fact types, each fruit (and so each apple type) must have a price and maybe a shelf life.</p>

<p>Declaring a subtype creates subtyping fact types, which is useful
when subtyping relationships must be explicitly queried.</p>

<p>
An object type that can have instances which play no roles (other than
its identifying roles) should be declared <em>independent</em>:
<pre>
State is independent identified by its Code;
</pre>
</p>

<!--
<h3>Extended Role Names</h3>

<p>
Note that hyphens are used here to indicate the use of adjectives, which
can be either leading or trailing as required by the language. The hyphen
is only required once within a declaration, and this associates the
adjective with that role player throughout this declaration.
</p>

<pre>
    Person is identified by given-Name and family-Name where
	Person is called one given Name, given Name is of Person,
	Person has one family Name, family Name is of Person;
</pre>

<p>Note that the uniqueness constraints for these fact types are
shown. They could alternatively be provided later, but must be
included within the same vocabulary.
</p>

<p>
Hyphens may be used to designate multiple adjectives, but must
have a space beside the hyphen, on the side of the existing object
type name. Otherwise the pair of (previously unseen) words is treated
as a simple hyphenated term:
</p>

<pre>
    suitably- trained Person is allowed to drive semi-trailer;
</pre>

<p>
Finally, when the full form of identification is used, but there are fact type
readings all referring to the same roles <em>none of which is the defined entity
type</em>, these are the readings of a new fact type, which is objectified (named)
as the new entity type. This is discussed below, but in this case, the entity type
has an identification scheme which is not drawn from the fact type roles.
</p>
-->

<h3>Fact Types</h3>

<p>
Fact types are declared as one or more fact type readings. Each
reading provides a verbal description of the relationship between
two or more object types, or a property of a single object type.
Each object type is referred to as "playing a role" in the fact
type.
</p>

<p>
All the readings of a fact type must have the same set of role
players.  The first reading of a fact type is the default reading,
and provides the identification scheme when needed (when the fact
type is objectified).
</p>

<dl>
  <dt>named_fact_type:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
			 'ID', "'is where'",
	       NonTerminal('fact_type')
	   )).addTo();
	  </script>
  <dt>fact_type:
  <dd>
	  <script>
	  Diagram(
	  	     Sequence(
	  	           NonTerminal('reading'),
				  ZeroOrMore(
				  	Sequence(
				  		"','",
						NonTerminal('reading')
				  	)
				  )
	  	   )).addTo();
	  </script>
  <dt>reading or query_clauses:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
		   NonTerminal('qualified_clauses'),
		   ZeroOrMore(
		       Choice(0, "'and'", "'or'"),
		       NonTerminal('qualified_clauses')
		   )
	   )).addTo();
	  </script>
</dl>	   
	   
<p>Each fact type reading may contain a quantifier expression before the
last role player, which can assert mandatory, uniqueness or frequency
constraints over the allowed population of instances of that fact. A
qualifier that asserts a ring constraint (see below) may also follow a
reading.
</p>

<p>Note that a fact type does not have to be named; it can simply
be a set of readings.  Naming makes the fact type an <em>object
type</em>, and is required whenever no unique quantifier exists in
the fact type, or where there are more than two roles.  Where a
fact type isn&rsquo;t named, it cannot play roles in other fact
types. This example shows an un-named and a named (objectified)
fact type:
</p>

<pre>
    Person was born at one birth-Place;
    Directorship is where Person directs Company;
</pre>

<p>
If an object type plays more than one role in a fact type, the
separate roles must be distinguished by either adjectives or a
defined role name. See the resolution rules under Resolving roles for
more details.
</p>

<h3>Certainty and Qualifiers</h3>

<p>Certainty TBC</p>

<p>The qualifiers are encased in square brackets, and are most commonly
used for ring constraints. See the section on constraints for more
details. The <tt>maybe</tt> outer-join qualifier is only used in
derivation clauses. Derivations are discussed below, under queries.</p>
	   
<dl>	   
  <dt>qualified_clauses:
  <dd>
	  <script>
	  Diagram(
	  	     Sequence(
                 NonTerminal('certainty'),	  		   
                 NonTerminal('contracted_clauses'),
                 Optional(NonTerminal('qualifiers'))
	   	   )).addTo();
	  </script>
  <dt>certainty:
  <dd>
	  <script>
	  Diagram(
 		   Choice(0,
                 Skip(),
                "'definitely'",
                "'maybe'",
                "'it is not the case that'"
            )
	  ).addTo();
	  </script>
  <dt>qualifiers:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
	       "'['",
	       NonTerminal('qualifier'),
	       ZeroOrMore(
	            Sequence(
	               "','",
	               NonTerminal('qualifier')
	            )
	        ),
	       "']'"
	   )).addTo();
	  </script>
  <dt>qualifier:
  <dd>
	  <script>
	  Diagram(
  	     Choice(0,
           "'static'",
           "'transient'",
           "'intransitive'",
           "'strongly intransitive'",
           "'transitive'",
           "'acyclic'",
           "'symmetric'",
           "'antisymmetric'",
           "'reflexive'",
           "'irreflexive'"
	   	   )).addTo();
	  </script>
</dl>

<pre>
Product may be substituted by alternate-Product in Season [acyclic, intransitive]
Topic belongs to at most one parent-Topic [acyclic];
Girl (as Girlfriend) is going out with at most one Boy (as Boyfriend) [symmetric]
</pre>

<h3>Contraction</h3>

<dl>  
   <dt>contracted_clauses:
   <dd>
 	  <script>
	   Diagram(
   	     Choice(0,
	           NonTerminal('comparison'),
	           OneOrMore(
	               Choice(0,
	                  NonTerminal('contraction'),
	                  NonTerminal('phrase')
	               )
	           )
	   	   )).addTo();
	  </script>
   <dt>contraction:
   <dd>
 	  <script>
	   Diagram(
   	     Choice(0,
               NonTerminal('reading_contraction'),
               NonTerminal('condition_contraction')
	   	   )).addTo();
	  </script>
   <dt>reading_contraction:
   <dd>
 	  <script>
	   Diagram(
   	     Sequence(
               NonTerminal('role'),
               Optional(NonTerminal('qualifiers')),
               Choice(0, "'that'","'who'"),
               NonTerminal('certainty'),
               NonTerminal('contracted_clauses')
	   	   )).addTo();
	  </script>
   <dt>condition_contraction:
   <dd>
 	  <script>
	   Diagram(
	   	     Sequence(
	                   NonTerminal('role'),
	                   Optional(NonTerminal('qualifiers')),
	                   NonTerminal('certainty'),
	                   NonTerminal('comparator'),
	                   NonTerminal('expression')
	   	   )).addTo();
	  </script>
   <dt>comparison:
   <dd>
 	  <script>
	   Diagram(
	     Choice(0,
	   	     Sequence(
	                   NonTerminal('expression'),
	                   NonTerminal('certainty'),
	                   NonTerminal('comparator'),
	                   NonTerminal('contraction'),
	                   Optional(NonTerminal('qualifiers'))
	               ),
	              Sequence(
	                  NonTerminal('certainty'),
	                  NonTerminal('expression'),
	                  NonTerminal('comparator'),
	                  NonTerminal('expression')
	              )
	   	   )).addTo();
	  </script>	   
</dl>

<h3>Roles in Fact Types</h3>

<dl>  
   <dt>phrase:
   <dd>
 	  <script>
	   Diagram(
	      Choice(0,
	   	      NonTerminal('role'),
	          NonTerminal('role_ref')
	   	   )).addTo();
	  </script>
   <dt>role:
   <dd>
 	  <script>
	   Diagram(
	        Choice(0,
	            NonTerminal('aggregate'),
	            NonTerminal('simple_role')
	   	   )).addTo();
	  </script>
   <dt>aggregate:
   <dd>
 	  <script>
	   Diagram(
        Sequence(
            NonTerminal('ID'),
            "'of'",
            NonTerminal('role_ref'),
            "'in'",
            "'('",
            NonTerminal('reading'),
            "')'"
	   	   )).addTo();
	  </script>
   <dt>simple_role:
   <dd>
 	  <script>
	   Diagram(
        Sequence(
            Optional(
                 Sequence(
                     NonTerminal('qualifier'),
                     NonTerminal('enforcement')
                 )
            ),
            NonTerminal('role_ref'),
            Choice(0,
                  Sequence(
                        NonTerminal('literal'),
                        Optional(NonTerminal('unit'))
                  ),
                  Sequence(
                        NonTerminal('value_constraint'),
                        NonTerminal('enforcement')
                   )                  
             ),
            Optional(NonTerminal('objectification'))
	   	   )).addTo();
	  </script>
</dl>

<p>
The syntax here is ambiguous, because a fact_role consists of one or
more IDs with optional hyphens to indicate adjectives, interspersed
with arbitrary linking words (also IDs).  So how is the ambiguity resolved?
</p>

<p>
First of all, CQL looks through all the readings in this definition,
and finds the occurrences of known object type names. Each occurrence
may be followed by the definition of a role name, or may have
one or more associated adjectives attached using a hyphen (dash).
Adjectives may not be the same as the name of any object type,
or of any local role name, and the complete term (with adjectives)
must likewise be unique.
</p>

<p>
A subsequent scan finds all occurrences of these role names and
terms with adjectives (which now don't require the hyphen).  Any
remaining words are the open vocabulary which forms the reading
that designates this fact type.
</p>

<p>
When a fact type reading is re-iterated in order to invoke an
existing fact type, for example in a constraint, in a derivation
or to add a new reading to an existing fact type, there may be
adjectives in the definition of the invoked fact type. These also
must be matched in the reading.
</p>

<h4>Quantifiers</h4>

<p>
The final role in a reading may be preceeded by a quantifier, which does
not form a part of the reading. These are normally used to apply a
uniqueness constraint (<tt>at most one</tt>), a mandatory constraint
(<tt>at least one</tt>) or both (<tt>exactly one</tt> or just
<tt>one</tt>). Other forms allow various other role frequency
constraints. The <tt>quantity</tt> here may be a positive integer or the
word <tt>one</tt>. Note that some quantifiers are only used in derivations
or in constraints.
</p>

<dl>
<dt>quantifier:
<dd>
	<script>
	Diagram(
	   Choice(0,
	      "'some'",
	      "'that'",
	      "'one'",
	      Sequence("'exactly'", NonTerminal('quantity')),
	      Sequence("'at least'", NonTerminal('quantity')),
	      Sequence("'at most'", NonTerminal('quantity')),
	      Sequence(
	            "'at least'", NonTerminal('quantity'), "'and at most'", NonTerminal('quantity')
	      ),
	      Sequence(
	           "'from'", NonTerminal("decimal"), "'to'", NonTerminal('decimal')
	      )
	 )).addTo();
	</script>
<dt>quantity:
<dd>
	<script>
	Diagram(
		Choice(0, "'one'", NonTerminal('number'))
	).addTo();
	</script>
</dl>

<p>In this way, CQL absorbs many of the uniqueness, mandatory and
frequency constraints of Object Role Modeling.
</p>

<p>The only ORM
characteristic that cannot be expressed this way is a non-mandatory
constraint having a minimum frequency above one; for example a
constraint that allows zero, or more than two, occurrences. For
example, in a footy tipping competition, it might be the case that
if a participant submits no tips this week, they get the tips
published by a known tipster, but if they do submit tips, they must
submit at least eight. This kind of non-mandatory frequency
constraint may be expressed in CQL using the <b>maybe</b>
qualifier, which is also used in outer join derivations.</p>

<pre>
    maybe Participant entered at least 8 Tips
</pre>

<h3>Value Restrictions</h4>

<p>
A value restriction may follow a role reference where the role is
played by a value type (or by an entity type ultimately identified
by a single value type), and this constrains the allowed values of
that value type in this role. In addition to fact type definitions,
a value or a value restriction may be applied to fact instances
and in derivations, where it has the obvious effect.
</p>

<h3>Objectification</h3>

<dl>
   <dt>objectification:
   <dd>
 	  <script>
	   Diagram(
        Sequence(
            "'('", "'in which'", NonTerminal('reading'), "')'"
	   	   )).addTo();
	  </script>
</dl>


<pre>
Service (in which Waiter served Meal) earned a tip of Amount
</pre>

<h2>Constraints</h2>

<p>Quantifiers allow the definition of the most common kinds of
constraints, the mandatory, uniqueness and frequency constraints
(collectively, CQL calls these <b>presence constraints</b>). Often
there are constraints that cannot be expressed in this form
however, such as when an object type must play one of many unrelated
roles. This is handled in CQL by the use of an external constraint
definition, or with a ring constraint qualifier.</p>

<dl>
<dt>constraint
<dd>
	<script>
	Diagram(
	    Choice(0,
	       NonTerminal('presence_constraint'),
	       NonTerminal('subset_constraint'),
	       NonTerminal('set_constraint'),
	       NonTerminal('equality_constraint')
	 )).addTo();
	</script>

</dl>
	 
<h3>Presence constraints</h3>

<p>When a single role player must play one and only one (or at
least one) of a set of roles, we can say:</p>

<dl>
<dt>presence_constraint:
<dd>
	<script>
	Diagram(
	    Choice(0,
	        Sequence(
	           "'each'",
				Optional("'combination'"),
			   NonTerminal('role_list'),
	           "'occurs'",
	           NonTerminal('quantifier'),
	           Choice(0, "'time'", "'times'"), 
	           NonTerminal('enforcement'),
	           "'in'",
	           NonTerminal('clauses_list')
	        ),
	       Sequence(
	            Optional("'either'"),
	            NonTerminal('clauses'),
	            "'or'",
	            NonTerminal('clauses'),
	            NonTerminal('enforcement')
	       )
	 )).addTo();
	</script>
<dt>clauses_list:
<dd>
	<script>
	Diagram(
		Sequence(
			NonTerminal('clauses'),
			ZeroOrMore(
				"','",
				NonTerminal('clauses')
			)
		)
	).addTo();
	</script>
<dt>clauses:
<dd>
	<script>
	Diagram(
		Sequence(
			NonTerminal('contracted_clauses'),
			ZeroOrMore(
				"'and'",
				NonTerminal('contracted_clauses')
			)
		)
	).addTo();
	</script>
</dl>
 
For example:
 
<pre><b>each</b> Range <b>occurs</b> at least one <b>time in</b>
	Range has minimum-Bound,
	Range has maximum-Bound;
</pre>

<p>For example, supposing that we were to identify Person instances
by given name and family name (not a good idea in a real system!)
we need to ensure that the <b>combination</b> given name, family
name is unique. We can say:</p>

<pre>
<b>each</b> family Name, given Name <b>occurs</b> at most one<b> time in</b>
	Person is known by given-Name,
	Person has family-Name;
</pre>

<h3>Set Constraints</h3>

<dl>
<dt>set_constraint
<dd>
	<script>
	Diagram(
	    Choice(0,
	        Sequence(
	           "'for each'",
	           NonTerminal('role_list'),
	           NonTerminal('quantifier'),
	           "'of these holds'",
	           NonTerminal('enforcement'),
	           "':'",
	           NonTerminal('clauses_list')
	        ),
	       Sequence(
	            Optional("'either'"),
	            NonTerminal('clauses'),
	            "'or'",
	            NonTerminal('clauses'),
	            "'but not both'",
	            NonTerminal('enforcement')
	       )
	 )).addTo();
	</script>

</dl>

<pre>
<b>for each</b> ReceivedItem exactly one<b> of these holds:</b>
	ReceivedItem is for PurchaseOrderItem,
	ReceivedItem is for TransferRequest;
</pre>

<pre>
<b>for each</b> Unit exactly one <b>of these holds</b>:
	Unit is fundamental,
	that Unit is derived from some base-Unit;
</pre>

In the case where one of two fact types applies, you can use the more
natural form:

<pre>
<b>either</b> Unit is fundamental
<b>or</b> Unit is derived from some base-Unit
<b>but not both</b>;
</pre>

<h3>Subset Constraints</h3>

<p>When one role may be played only if another is, you can use a
subset constraint:</p>

<dl>
<dt>subset_constraint
<dd>
	<script>
Diagram(
    Sequence(
        NonTerminal('clauses'),
                'only if', NonTerminal('clauses'),
       NonTerminal('enforcement')
 )).addTo();
 </script>
</dl>
 
 For example:
 
<pre>
	Address has third-StreetLine
	<b>only if</b>
	Address has second-StreetLine;
</pre>

<p>Note that this example didn&rsquo;t use the first and second
StreetLine, as we assume that the first StreetLine is a mandatory
part of the address, so the subset constraint would be
redundant.</p>

<h3>Equality Constraints</h3>

<p>Equality constraints declare that the populations of two or more
roles (or sequences of roles) are the same. They are expressed using
&lsquo;if and only if&rsquo;:</p>

<dl>
<dt>equality_constraint
<dd>
	<script>
	Diagram(
	    Sequence(
	        NonTerminal('clauses'),
	        OneOrMore(
	             Sequence(
	                'if and only  if', NonTerminal('clauses')
	             )
	        ),
	       NonTerminal('enforcement')
	 )).addTo();
	</script>
</dl>

For example:

<pre>
Competition is in Series
	<b>if and only if</b>
	Competition has series-Number;
</pre>

<h3>Ring Constraints</h3>

<p>When a fact type includes the same object type more than once, or
includes a supertype and its subtype, there&rsquo;s the possibility
of the same instance playing both roles. This is often not desired,
but further it introduces a whole class of further situations which
can be restricted using ring constraints. The CQL keywords used in
fact clause qualifiers for ring constraints are the following:</p>

<p><b>intransitive</b>,<b> transitive</b>,<b> acyclic</b> and <b>
symmetric</b>. Intransitive means that just because &ldquo;A
relates to B&rdquo;, and &ldquo;B relates to C&rdquo;, that
doesn&rsquo;t mean that&nbsp; &ldquo;A relates to C&rdquo;.
Transitive means the opposite. Acyclic means that no A may relate
to itself, or to any B that has that relation to A, and so on.
Symmetric means that if A relates to B, B also relates to A (so
there is only one fact instance possible between A and B).</p>

<p>This method for defining ring constraints is not fully general,
and a new syntax is required for covering complex cases</p>

<h3>Join constraints</h3>

<p>Most of the above constraint types may use joins, where more
than one fact type is joined together with the <b>and</b> keyword.
A full discussion is beyond the scope of this paper, but
here&rsquo;s a small example of a subset constraint using a
join:</p>

<pre>
Diplomat speaks Language;
Country uses Language, Language is spoken in Country;
Diplomat serves in Country;

Diplomat serves in Country
	<b>only if</b>
	Country uses Language <b>and</b> Diplomat speaks Language;
</pre>

<p>This constraint requires that in order to serve in a country, a
diplomat must speak at least one language used in that country.
Many joins may be <em>contracted</em> using <em>who</em> or <em>that</em>.
This example contracts like this:
</p>

<pre>
Diplomat serves in Country
	<b>only if</b>
	Diplomat speaks Language <b>that</b> is spoken in Country;
</pre>

<h3>Enforcement</h3>

<p>To be completed.</p>

<dl>
<dt>enforcement:
<dd>
	<script>
	Diagram(
	     Sequence(
	         "'('",
	         "'otherwise'",
	         NonTerminal('action'),
	        "')'"
	   )).addTo();
	</script>
</dl>	

<h2>Instances</h2>

<h3>Value Instance</h3>

<p>A value instance is defined by stating the name of the value type followed by
the lexical representation of the value. An entity having a single identifying role
may be defined exactly the same way, which also defines the required identifying
instance (in the third example here, a value). Within a vocabulary, an instance
is asserted into the sample population, but in other contexts another population
may be the target (the metamodel supports arbitrary named populations).</p>

<pre>
    CompanyName 'Microsoft';
    Year 1999;
    Company 'Microsoft';
</pre>
	
<h3>Fact Instances</h3>

<p>When a fact reading is invoked with values, a fact instance
is created. The simplest is where a declaration is just an object type
name followed by a value:</p>

<pre>
    Name &lsquo;Fred&rsquo;;
</pre>

<p>This form is allowed for any value type, or any entity type
that&rsquo;s identified by a single value type (or an entity
identified by a single entity identified by a single value type,
etc). In more complex cases, it might be necessary to invoke more
than one fact type to define the instance:</p>

<pre>
    Person is called given name &lsquo;Fred&rsquo;,
	Person has family Name &lsquo;Bloggs&rsquo;;
</pre>

<p>or</p>

<pre>
    given Name &lsquo;Fred&rsquo; is of Person <b>who</b> has family Name &lsquo;Bloggs&rsquo;;
</pre>

<p>The Person instance being defined is a reference to the same
instance in each fact type reading; there is an implicit join over
the two clauses.
</p>

<p>
An <em>objectification join</em> allows traversal of an objectified
fact type:
</p>

<pre>
    Directorship <b>(where</b> Person &lsquo;Fred Bloggs&rsquo; directs Company &lsquo;Acme, Inc&rsquo;<b>)</b>
      began on appointment Date &lsquo;2010-04-27&rsquo;;
</pre>

<h2>Fact Derivation (Queries)</h3>

<p>Fact derivation is a large subject by itself, so we&rsquo;ll
leave a detailed coverage for a future paper. Here&rsquo;s a short
introduction however.</p>

<p>When a fact type has the optional clauses that define its
derivation, the population of that fact type is derived as a <b>
query</b> over the fact types it invokes. Each condition clause is
either a comparison, which compares a role value with a constant or
another role value, or a fact type reading.</p>

<p>For a reading, at least one role must match an occurrence of
that role in the new fact type or in another reading in the
derivation. This match defines a logical <b>join</b> operation
across the fact populations. Where the same object type occurs in
different roles, and those roles are not to be joined, additional
adjectives or defined role names may be used to separate the
roles.</p>

<!--p>The values may be modified by functions, such as the built-in
functions on the Date value type which can extract the year, month,
day, etc from the Date.</p-->

<p>It&rsquo;s possible to negate any invoked fact type by inserting
the word <b>no</b> into it as a quantifier, or <b>not</b> as an
additional linking word. Here are some examples of fact type
derivations (the full fact type definition is elided):</p>



<pre>
    Person has family Name,
	family Name = &lsquo;Bloggs&rsquo;,
	Person is <b>not</b> called given Name &lsquo;Fred&rsquo;,
	Person is a kind of Employee,
	Employee is managed by <b>no</b> Manager<b>;</b>
</pre>

<h3>Result Constellations</h4>

<p>A fact derivation may include a <b>returning</b> clause.
Normally, when processing a query, only the object instances that
play the roles of the derived fact type (and satisfy the query)
will be available in the results, and there is no defined ordering
in the values. When the returning clause is used, additional
object and fact instances may be accessible from the result,
which may also be sorted. This extension of the result set is
transitive, so that if a derived fact type invokes another derived
fact type, the returned instances from the invoked fact
type&rsquo;s returning clause will also be available.</p>

<p>The results now include more than just a simple table of the
instances that play the roles of the derived fact type. Instead,
each object instance may be associated with additional facts for
other roles it plays, and the roles of those facts will be
populated by further object instances, and so on. This data
structure is hereby defined as a <b>constellation</b>, which is
where CQL gets its name. The query has selected certain instances
from the entire fact population, much as an astronomer might select
stars from the night sky.</p>

<p>The use of <b>returning</b> doesn&rsquo;t change the contents of
the defined fact type, it&rsquo;s merely a pragmatic instruction to
the query engine about which additional instances will be useful to
the calling program, and in what order.<br clear="all" />
</p>


<dl>
  <dt>query:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
			NonTerminal('query_clauses'), 
	        Optional(
	            Sequence(
	                "'where'",
	                NonTerminal('query_clauses')
	            )
	       ),
	       Optional(
	           NonTerminal('returning_clause')
	       )
	   )).addTo();
	  </script>
  <dt>returning_clause:
  <dd>
	  <script>
	  Diagram(
	     Sequence(
			"'returning'", 
	        ZeroOrMore(
	            Sequence(
	                "','",
	                NonTerminal('phrase')
	            )
	       )
	   )).addTo();	  
	  </script>
</dl>

<h2>Unit Definitions</h2>

<p>A unit definition defines a new unit identifier in terms of an
optional coefficient (real number or integer fraction) multiplied by one
or more base units, each raised to an integer power. It's common to
define the singular form of a unit, then also define the plural as
equivalent.
</p>

Units are defined by declaring conversion formulae involving base units. Both
singular and plural names may be given. If a base unit is not otherwise defined,
it is assumed to be fundamental. Formulae are limited to a coeficient and an
offset (<it>ax</it> + <it>c</it>), where <it>x</it> may be any number of existing units each raised to
any integer power. Conversion coeficients have a real numerator and an integral
denominator which defaults to 1. The formula may be written in either direction,
but the constants must be on the side of the base units. An extensive library
of standard unit conversions is available. Ephemeral conversions can be defined;
the conversion factor at a particular time is assumed to be available from some
source. Approximate conversions can be annotated.

<dl>
<dt>unit_def:
<dd>
    <script>
	Diagram(
		  Sequence(
			 Optional(NonTerminal('coefficient')),
		     Optional(NonTerminal('units')),
		     Optional(
				 Sequence(
					 "[+-]",
				 	NonTerminal('number')
				 )
				 
			 ),
			 "'converts to'",
			 'ID',
			 Optional(
			 	Sequence("'/'", 'ID')
			 ),
			 Choice(0,
				 Skip(),
			 	 "'approximately'",
				 "'ephemera'"
			 )
		)).addTo();
	</script>
<dt>coefficient:
<dd>
	<script>
	Diagram(
	  Sequence(
		  NonTerminal('number'),
		  Optional(
		  	Sequence("'/'", NonTerminal('number'))
		  )
	  )).addTo();
	  </script>
<dt>units:
<dd>
	<script>
	Diagram(
	  Sequence(
	     NonTerminal('power_unit'),
		 ZeroOrMore(NonTerminal('power_unit')),
		 Optional(
	         Sequence(
	             "'/'",
			     NonTerminal('power_unit'),
				 ZeroOrMore(NonTerminal('power_unit'))
	         )
		)
	)).addTo();
	</script>
<dt>power_unit:
<dd>
	<script>
	Diagram(
		Sequence(
			'ID',
			Optional(
				Sequence(
					"'^'",
					Optional("'-'"),
					'[0-9]' 
				)	
		)
	)).addTo();
	</script>
</dl>

<pre>
25.4 millimeters converts to inch/inches;
kelvin + 273.15 converts to celsius;
9/5 celsius + 32 converts to fahrenheit;
acceleration converts to metres second^-2;
g converts to 9.8 acceleration approximately;
0.853 dollarUS converts to dollarAU ephemeral;
</pre>

The use of units in defining value types and in query literals allows dimensional
analysis and automatic conversions. This example shows a derived fact
type ("Pane has Area") and a query that uses units conversion to list large
panes of glass. Notice that the literal in last line has an associated unit (this line
also has a contracted join, see below).

<pre>
Dimension is written as Real in millimeters;
Width is written as Dimension; Height is written as Dimension;
Pane has one Width; Pane has one Height;
Pane has Area where
Pane has Width, Pane has Height,
Area = Width * Height;
Pane has Area > 5 foot^2?
</pre>

<h2>Expressions and Lexical Rules</h2>

Expressions and lexical rules follow standard C, UNIX and HTTP conventions.

<dl>
	<dt>expression:
	<dd>
		<script>
		Diagram(
			Sequence(
				NonTerminal('sum'),
				ZeroOrMore(
					NonTerminal('comparator'),
					NonTerminal('sum')
				)
			)
		).addTo();
		</script>
	<dt>sum:
	<dd>
		<script>
		Diagram(
			Sequence(
				NonTerminal('product'),
				ZeroOrMore(
					Choice(0, "'+'", "'-'"),
					NonTerminal('product')
				)
			)
		).addTo();
		</script>
	<dt>product:
	<dd>
		<script>
		Diagram(
			Sequence(
				NonTerminal('factor'),
				ZeroOrMore(
					Choice(0, "'*'", "'/'", "'%'"),
					NonTerminal('factor')
				)
			)
		).addTo();
		</script>
   <dt>factor:
   <dd>
	<script>
	Diagram(
		Choice(0,
			Sequence(
				NonTerminal('literal'),
				Optional(NonTerminal('unit'))
			),
			NonTerminal('role_ref'),
			Sequence(
				"'('",
				NonTerminal('expression'),
				"')'"
			)
		)
	).addTo();
	</script>
   <dt>comparator:
   <dd>
 	  <script>
	   Diagram(
            Choice(0,
	   	       "'<='", "'<>'" , "'<'" , "'='" , "'>='" , "'>'" , '!='
	   	   )).addTo();
	  </script>
	<dt>literal
	<dd>
		<script>
		Diagram(
			  Choice(0,
		 	     NonTerminal('boolean'),
	             NonTerminal('string'),
	             NonTerminal('number')
			)).addTo();
		</script>
	<dt>boolean
	<dd>
		<script>
		Diagram(
		    Choice(0,
		        "'true'", "'false'"
		 )).addTo();
		</script>
	<dt>string
	<dd>
		<script>
		Diagram(
		    Sequence(
		        "'", ZeroOrMore('CHAR'), "'"
		 )).addTo();
		</script>
	<dt>number
	<dd>
		<script>
		Diagram(
		  Choice(0,
			 Sequence("'", 'CHAR', "'"),
	 	     NonTerminal('decimal'),
			 NonTerminal('real'),
             NonTerminal('octalnumber'),
             NonTerminal('hex number')
		)).addTo();
		</script>
	<dt>decimal
	<dd>
		<script>
		Diagram(
				  Sequence(
			 	     Choice(0, Skip(), "'+'", "'-'"),
		             Choice(0,
                          Sequence("[1-9]", ZeroOrMore("[0-9]")),
                          "0"
                     )
				)).addTo();
		</script>
	<dt>real
	<dd>
		<script>
		Diagram(
				  Sequence(
			 	     Choice(0, Skip(), "'+'", "'-'"),
		                     Choice(0,
		                          Sequence("[1-9]", ZeroOrMore("[0-9]"), Optional(NonTerminal('fraction'))),
		                          Sequence("0", NonTerminal('fraction'))
		                     ),
		                    Optional('exponent')
				)).addTo();
		</script>
	<dt>fraction
	<dd>
		<script>
		Diagram(
				  Sequence(
			 	     "'.'", OneOrMore("[0-9]")
				)).addTo();
		</script>
	<dt>exponent
	<dd>
		<script>
		Diagram(
				  Sequence(
			 	     "'('", "[Ee]", Choice(0, Skip(), "'+'", "'-'"), OneOrMore("[0-9]"), "')'"
				)).addTo();
		</script>
	<dt>hexnumber
	<dd>
		<script>
		Diagram(
				  Sequence(
			 	     "'0x'", OneOrMore("[0-9A-Fa-f]")
				)).addTo();
		</script>
	<dt>octalnumber
	<dd>
		<script>
		Diagram(
				  Sequence(
			 	     "'0'", OneOrMore("[0-7]")
				)).addTo();
		</script>
	<dt>regular_expression
	<dd>UNIX-style regular expression
	<dt>url
	<dd>HTTP-stule URL
</dl>

<h4>Footnotes</h4>
<ol>
  <li><a href="http://ormfoundation.org/" name="ftn1" title="">The ORM Foundation</a>
  </li>

  <li><a href="http://en.wikipedia.org/wiki/Semantics_of_Business_Vocabulary_and_Business_Rules" name="ftn2"
    title="Semantics of Business Vocabulary and Business Rules">Semantics
    of Business Vocabulary and Business Rules</a>
  </li>
</ol>
</div>


	</div>
</div>
<div id="footer" class="noprint">
	<p>Copyright &copy; 2015 Infinuendo</p>
</div>
</body>
</html>


